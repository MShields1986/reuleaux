/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2017-07-11 11:47:26.771071
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45;
x0=IKcos(j[0]);
x1=IKcos(j[3]);
x2=IKcos(j[1]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[3]);
x6=IKsin(j[2]);
x7=IKsin(j[0]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKsin(j[4]);
x11=IKcos(j[4]);
x12=((0.085)*x7);
x13=((1.0)*x1);
x14=((1.0)*x11);
x15=((1.0)*x7);
x16=((1.0)*x10);
x17=((0.085)*x3);
x18=((0.5)*x7);
x19=((1.0)*x3);
x20=((1.0)*x0);
x21=((0.085)*x1);
x22=((0.085)*x0);
x23=(x4*x5);
x24=(x2*x5);
x25=(x4*x6);
x26=(x2*x6);
x27=(x1*x4);
x28=(x0*x3);
x29=(x2*x3);
x30=(x15*x6);
x31=(x16*x25);
x32=(x15*x23);
x33=((((-1.0)*x30))+((x2*x28)));
x34=(((x1*x2))+(((-1.0)*x19*x23)));
x35=(((x27*x3))+x24);
x36=((((-1.0)*x15*x26))+x28);
x37=(((x29*x7))+((x0*x6)));
x38=((((-1.0)*x15*x3))+(((-1.0)*x20*x26)));
x39=(((x20*x26))+((x15*x3)));
x40=(x11*x35);
x41=(x1*x33);
x42=(x41+(((-1.0)*x20*x23)));
x43=((((-1.0)*x32))+((x1*x37)));
IkReal x46=((1.0)*x0);
x44=((((-1.0)*x13*x4*x46))+((x5*(((((-1.0)*x19*x2*x46))+x30)))));
x45=(((x13*x4*x7))+((x5*(((((1.0)*x20*x6))+(((1.0)*x15*x29)))))));
eerot[0]=(((x8*((((x10*x38))+((x11*x42))))))+((x44*x9)));
eerot[1]=(((x44*x8))+((x9*(((((-1.0)*x14*x42))+(((-1.0)*x16*x38)))))));
eerot[2]=(((x10*x42))+((x11*x39)));
eetrans[0]=(((x18*x3))+((x10*((((x21*x33))+(((-1.0)*x22*x23))))))+((x11*((((x22*x26))+((x12*x3))))))+(((0.45)*x7))+(((0.5)*x0*x26)));
eerot[3]=(((x8*(((((-1.0)*x31))+x40))))+((x34*x9)));
eerot[4]=(((x9*(((((-1.0)*x14*x35))+x31))))+((x34*x8)));
eerot[5]=(((x10*x35))+((x11*x25)));
eetrans[1]=((((0.5)*x25))+(((0.085)*x11*x25))+((x10*(((((0.085)*x24))+((x17*x27)))))));
eerot[6]=(((x8*(((((-1.0)*x14*x43))+(((-1.0)*x16*x36))))))+((x45*x9)));
eerot[7]=(((x9*((((x10*x36))+((x11*x43))))))+((x45*x8)));
eerot[8]=(((x10*((x32+(((-1.0)*x13*x37))))))+((x11*x36)));
IkReal x47=((1.0)*x26);
eetrans[2]=((0.315)+((x10*(((((-1.0)*x21*x37))+((x12*x23))))))+(((-1.0)*x18*x47))+(((0.5)*x28))+(((0.45)*x0))+((x11*((((x0*x17))+(((-1.0)*x12*x47)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=(px+(((-0.085)*r02)));
new_r10=((-1.0)*r20);
new_r11=((-1.0)*r21);
new_r12=((-1.0)*r22);
new_py=((0.315)+(((-1.0)*pz))+(((0.085)*r22)));
new_r20=r10;
new_r21=r11;
new_r22=r12;
new_pz=((((-0.085)*r12))+py);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x48=((1.0)*px);
IkReal x49=((1.0)*pz);
IkReal x50=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x50))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x49)));
rxp0_2=((((-1.0)*r10*x48))+((py*r00)));
rxp1_0=((((-1.0)*r21*x50))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x49)));
rxp1_2=((((-1.0)*r11*x48))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x50)));
rxp2_1=((((-1.0)*r02*x49))+((px*r22)));
rxp2_2=((((-1.0)*r12*x48))+((py*r02)));
{
IkReal j1eval[2];
j1eval[0]=(pp+(((-1.0)*(pz*pz))));
j1eval[1]=((px*px)+(py*py));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x51=((0.5)*r22);
IkReal x52=((1.0)*pz);
IkReal x53=((-0.095)+(((-1.0)*r22*x52)));
IkReal x54=(x51+(((-1.0)*x52)));
IkReal x55=((-1.0)*pz);
IkReal x56=((((-1.0)*x51))+(((-1.0)*x52)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x55);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x55);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x55);
rxp2_2=0;
IkReal gconst0=x53;
IkReal gconst1=x54;
IkReal gconst2=x56;
IkReal gconst3=x53;
IkReal gconst4=x54;
IkReal gconst5=x56;
IkReal gconst6=x53;
IkReal gconst7=x54;
IkReal gconst8=x56;
IkReal gconst9=x53;
IkReal gconst10=x54;
IkReal gconst11=x56;
IkReal x57=pz*pz;
IkReal x58=r20*r20;
IkReal x59=pz*pz*pz*pz;
IkReal x60=r22*r22;
IkReal x61=r21*r21;
IkReal x62=(r20*r21);
IkReal x63=((16.0)*x59);
IkReal x64=((1.52)*x57);
IkReal x65=((4.0)*x59);
IkReal x66=((0.38)*x57);
IkReal x67=(x62*x64);
IkReal x68=((((0.0361)*x62))+((x62*x63)));
j6eval[0]=((IKabs((x67+(((-1.0)*x68)))))+(IKabs(((((-1.0)*x61*x63))+((x60*x64))+((x61*x64))+(((-0.0361)*x61))+(((-0.0361)*x60))+(((-1.0)*x60*x63)))))+(((0.5)*(IKabs(((((-0.009025)*x58))+(((-0.009025)*x60))+((x60*x66))+((x58*x66))+(((-1.0)*x58*x65))+(((-1.0)*x60*x65)))))))+(((0.5)*(IKabs(((((8.0)*x58*x59))+(((0.01805)*x58))+(((-32.0)*x59*x61))+(((-0.05415)*x60))+(((-0.76)*x57*x58))+(((-0.0722)*x61))+(((3.04)*x57*x61))+(((2.28)*x57*x60))+(((-24.0)*x59*x60)))))))+(IKabs((x68+(((-1.0)*x67))))));
if( IKabs(j6eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x69=r20*r20;
IkReal x70=pz*pz;
IkReal x71=r21*r21;
IkReal x72=r22*r22;
IkReal x73=(pz*r22);
IkReal x74=(gconst11*gconst6);
IkReal x75=((1.0)*gconst0);
IkReal x76=(gconst10*pz);
IkReal x77=(gconst3*gconst4);
IkReal x78=((8.0)*gconst2);
IkReal x79=(gconst11*gconst2);
IkReal x80=(r20*r21);
IkReal x81=(gconst8*gconst9);
IkReal x82=((4.0)*gconst8);
IkReal x83=((0.095)*gconst4);
IkReal x84=((0.095)*gconst1);
IkReal x85=(gconst5*gconst6);
IkReal x86=((0.095)*gconst2);
IkReal x87=(gconst10*gconst3);
IkReal x88=((1.0)*gconst6);
IkReal x89=(gconst11*gconst8);
IkReal x90=((0.095)*gconst7);
IkReal x91=(gconst0*gconst5);
IkReal x92=(gconst4*pz);
IkReal x93=(gconst0*gconst11);
IkReal x94=(gconst2*gconst5);
IkReal x95=((4.0)*gconst2);
IkReal x96=(gconst4*gconst9);
IkReal x97=(gconst2*gconst9);
IkReal x98=(gconst5*gconst8);
IkReal x99=(gconst10*gconst9);
IkReal x100=((0.009025)*x79);
IkReal x101=((0.009025)*x98);
IkReal x102=((0.095)*gconst10*gconst8);
IkReal x103=(gconst6*x69);
IkReal x104=((8.0)*x71);
IkReal x105=(gconst0*x69);
IkReal x106=(r22*x70);
IkReal x107=(gconst7*x99);
IkReal x108=((4.0)*x71);
IkReal x109=((0.38)*x71);
IkReal x110=((0.095)*gconst10*x81);
IkReal x111=(x74*x90);
IkReal x112=((0.095)*x103);
IkReal x113=((0.095)*x105);
IkReal x114=(x84*x91);
IkReal x115=(x77*x86);
IkReal x116=((0.19)*pz*x69);
IkReal x117=((0.76)*pz*x71);
IkReal x118=(gconst7*x73*x74);
IkReal x119=(gconst10*x73*x81);
IkReal x120=(gconst8*x116);
IkReal x121=((1.52)*x70*x80);
IkReal x122=((0.19)*x73*x79);
IkReal x123=(gconst2*x116);
IkReal x124=((0.19)*x73*x98);
IkReal x125=(gconst2*x73*x77);
IkReal x126=(gconst1*x73*x91);
IkReal x127=(gconst4*x69*x70);
IkReal x128=((1.0)*x70*x72);
IkReal x129=((2.0)*x70*x72);
IkReal x130=(gconst10*x69*x70);
IkReal x131=((16.0)*x70*x71);
IkReal x132=((2.0)*x103*x92);
IkReal x133=((2.0)*x105*x76);
IkReal x134=(x69*x73*x88);
IkReal x135=(x69*x73*x75);
IkReal x136=((2.0)*x106*x69);
IkReal x137=(gconst8*x136);
IkReal x138=(x128*x98);
IkReal x139=(x130*x95);
IkReal x140=(x128*x79);
IkReal x141=(gconst2*x136);
IkReal x142=(x127*x82);
IkReal x143=((((16.0)*x80*(x70*x70)))+(((0.0361)*x80)));
IkReal x144=(x115+x114);
IkReal x145=(x111+x110);
IkReal x146=(x126+x125);
IkReal x147=(x119+x118);
IkReal x148=(x135+x123);
IkReal x149=(x141+x113);
IkReal x150=(x137+x112);
IkReal x151=(x134+x120);
IkReal x152=((((-1.0)*x143))+x121);
IkReal x153=((((-1.0)*x121))+x143);
IkReal x154=(x133+x132+x124+x122);
IkReal x155=(x140+x142+x139+x138+x100+x101);
op[0]=((((-1.0)*x145))+(((-1.0)*x128*x89))+(((-0.009025)*x89))+(((-1.0)*x151))+(((0.19)*x73*x89))+x150+x147+(((2.0)*x103*x76))+(((-1.0)*x130*x82))+(((-1.0)*x107*x88)));
op[1]=x152;
op[2]=((((-1.0)*x81*x83))+(((-1.0)*x148))+(((-1.0)*x145))+(((-1.0)*x150))+(((-1.0)*x155))+(((-0.01805)*x89))+(((-0.095)*gconst8*x87))+((gconst6*x109))+(((-1.0)*x90*x93))+(((-1.0)*gconst1*x88*x99))+((gconst7*x73*x93))+(((-4.0)*x103*x76))+(((0.38)*x73*x89))+((gconst8*x73*x87))+x154+x147+x149+x120+((gconst7*x73*x85))+((gconst1*x73*x74))+(((-1.0)*x86*x99))+(((-1.0)*gconst8*x117))+((gconst8*x104*x106))+(((-1.0)*x74*x84))+((gconst4*x73*x81))+((gconst10*x73*x97))+(((-1.0)*gconst7*x88*x96))+((gconst6*x104*x76))+(((-1.0)*x107*x75))+(((-1.0)*gconst7*x87*x88))+(((-1.0)*gconst6*x108*x73))+(((-1.0)*x129*x89))+(((-1.0)*gconst10*gconst8*x131))+(((8.0)*gconst8*x130))+((x103*x73))+(((-1.0)*x85*x90)));
op[3]=x152;
op[4]=((((-2.0)*gconst5*gconst8*(pz*pz)*(r22*r22)))+(((-4.0)*gconst0*gconst10*pz*(r20*r20)))+((gconst6*pz*r22*(r20*r20)))+(((-4.0)*gconst4*gconst6*pz*(r20*r20)))+((gconst3*gconst4*gconst8*pz*r22))+((gconst0*gconst5*gconst7*pz*r22))+(((0.38)*gconst0*(r21*r21)))+(((8.0)*gconst10*gconst2*(pz*pz)*(r20*r20)))+((gconst5*gconst6*gconst7*pz*r22))+(((-1.0)*gconst11*gconst8*(pz*pz)*(r22*r22)))+(((0.38)*gconst11*gconst2*pz*r22))+(((-0.01805)*gconst5*gconst8))+(((-4.0)*gconst10*gconst8*(pz*pz)*(r20*r20)))+(((-0.76)*gconst2*pz*(r21*r21)))+((gconst0*gconst1*gconst11*pz*r22))+(((-0.009025)*gconst11*gconst8))+(((-2.0)*gconst11*gconst2*(pz*pz)*(r22*r22)))+(((8.0)*gconst4*gconst6*pz*(r21*r21)))+(((-16.0)*gconst4*gconst8*(pz*pz)*(r21*r21)))+(((-0.095)*gconst1*gconst5*gconst6))+(((-0.01805)*gconst11*gconst2))+(((-4.0)*gconst6*pz*r22*(r21*r21)))+(((-1.0)*gconst0*gconst10*gconst3*gconst7))+(((-0.095)*gconst0*gconst1*gconst11))+((gconst1*gconst5*gconst6*pz*r22))+(((0.38)*gconst5*gconst8*pz*r22))+(((0.19)*gconst2*pz*(r20*r20)))+(((-1.0)*gconst1*gconst4*gconst6*gconst9))+(((-0.095)*gconst10*gconst3*gconst8))+((gconst0*pz*r22*(r20*r20)))+((gconst10*gconst3*gconst8*pz*r22))+(((-1.0)*gconst0*gconst1*gconst10*gconst9))+(((-0.095)*gconst1*gconst11*gconst6))+(((-0.095)*gconst5*gconst6*gconst7))+(((-0.095)*gconst6*(r20*r20)))+(((0.19)*gconst2*gconst5*pz*r22))+((gconst0*gconst11*gconst7*pz*r22))+(((2.0)*gconst10*gconst6*pz*(r20*r20)))+(((-0.095)*gconst0*(r20*r20)))+(((0.19)*gconst8*pz*(r20*r20)))+(((-0.095)*gconst0*gconst11*gconst7))+(((-0.095)*gconst2*gconst4*gconst9))+((gconst1*gconst11*gconst6*pz*r22))+(((-0.095)*gconst10*gconst2*gconst3))+(((-0.095)*gconst10*gconst2*gconst9))+(((-16.0)*gconst10*gconst2*(pz*pz)*(r21*r21)))+(((8.0)*gconst0*gconst10*pz*(r21*r21)))+(((-0.095)*gconst0*gconst5*gconst7))+(((-1.0)*gconst2*gconst5*(pz*pz)*(r22*r22)))+(((-1.0)*gconst1*gconst10*gconst3*gconst6))+(((8.0)*gconst2*r22*(pz*pz)*(r21*r21)))+((gconst2*gconst4*gconst9*pz*r22))+(((-2.0)*gconst2*r22*(pz*pz)*(r20*r20)))+((gconst4*gconst8*gconst9*pz*r22))+((gconst10*gconst2*gconst3*pz*r22))+(((-1.0)*gconst0*gconst4*gconst7*gconst9))+(((2.0)*gconst0*gconst4*pz*(r20*r20)))+(((-0.009025)*gconst2*gconst5))+(((8.0)*gconst4*gconst8*(pz*pz)*(r20*r20)))+(((-2.0)*gconst8*r22*(pz*pz)*(r20*r20)))+(((-0.095)*gconst4*gconst8*gconst9))+(((0.19)*gconst11*gconst8*pz*r22))+(((-1.0)*gconst3*gconst4*gconst6*gconst7))+(((-4.0)*gconst2*gconst4*(pz*pz)*(r20*r20)))+(((0.38)*gconst6*(r21*r21)))+(((-0.76)*gconst8*pz*(r21*r21)))+(((-0.095)*gconst3*gconst4*gconst8))+(((-4.0)*gconst0*pz*r22*(r21*r21)))+(((8.0)*gconst8*r22*(pz*pz)*(r21*r21)))+((gconst10*gconst2*gconst9*pz*r22)));
op[5]=x153;
op[6]=((((-1.0)*x144))+(((-1.0)*x149))+(((-1.0)*gconst7*x75*x77))+(((-1.0)*gconst1*x77*x88))+(((-0.01805)*x94))+(((-1.0)*x151))+(((-1.0)*x155))+(((-0.095)*gconst8*x77))+(((-1.0)*gconst0*x108*x73))+((gconst2*x73*x87))+(((-1.0)*gconst2*x117))+((gconst2*x73*x96))+(((-1.0)*x83*x97))+(((-1.0)*x90*x91))+((gconst1*x73*x85))+((gconst7*x73*x91))+((gconst1*x73*x93))+((x105*x73))+(((-4.0)*x105*x92))+x154+x150+x146+x123+((gconst0*x104*x92))+(((-1.0)*x86*x87))+((gconst8*x73*x77))+(((0.38)*x73*x94))+((x127*x78))+(((-1.0)*gconst1*x75*x87))+(((-1.0)*gconst1*x75*x96))+(((-1.0)*x84*x85))+((x106*x71*x78))+(((-1.0)*x84*x93))+((gconst0*x109))+(((-1.0)*x129*x94))+(((-1.0)*gconst2*gconst4*x131)));
op[7]=x153;
op[8]=((((-1.0)*x144))+(((-1.0)*x148))+(((-0.009025)*x94))+(((2.0)*x105*x92))+(((-1.0)*x127*x95))+(((0.19)*x73*x94))+(((-1.0)*gconst1*x75*x77))+x146+x149+(((-1.0)*x128*x94)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[2];
IkReal x156=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x156);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x156);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x156);
rxp2_2=0;
IkReal x157=(r21*sj6);
IkReal x158=(cj6*r20);
j5eval[0]=((r22*r22)+(((-2.0)*x157*x158))+(x158*x158)+(x157*x157));
j5eval[1]=((IKabs(((((0.5)*x157))+(((-0.5)*x158)))))+(((0.5)*(IKabs(r22)))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x159=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x159);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x159);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x159);
rxp2_2=0;
IkReal x160=pz*pz;
IkReal x161=(cj6*r20);
IkReal x162=(r21*sj6);
j5eval[0]=(((x160*(x161*x161)))+(((-2.0)*x160*x161*x162))+((x160*(x162*x162)))+((x160*(r22*r22))));
j5eval[1]=((IKabs((((pz*x162))+(((-1.0)*pz*x161)))))+(IKabs((pz*r22))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x163=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x163);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x163);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x163);
rxp2_2=0;
IkReal x164=cj6*cj6;
IkReal x165=sj6*sj6;
IkReal x166=(cj6*r11);
IkReal x167=(r00*sj6);
IkReal x168=(cj6*r01);
IkReal x169=(r10*sj6);
j1eval[0]=(((x164*(r01*r01)))+(((2.0)*x166*x169))+(((2.0)*x167*x168))+((x165*(r10*r10)))+((x165*(r00*r00)))+((x164*(r11*r11))));
j1eval[1]=((IKabs(((((0.45)*x167))+(((0.45)*x168)))))+(IKabs(((((-0.45)*x166))+(((-0.45)*x169))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((0.5)*(IKabs(r22))))+(IKabs(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x170=((0.45)*cj6);
IkReal x171=((0.45)*sj6);
j1eval[0]=((IKabs((((r00*x171))+((r01*x170)))))+(IKabs(((((-1.0)*r11*x170))+(((-1.0)*r10*x171))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x172=((0.45)*cj6);
IkReal x173=((0.45)*sj6);
CheckValue<IkReal> x175 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x172))+(((-1.0)*r10*x173)))),IkReal((((r00*x173))+((r01*x172)))),IKFAST_ATAN2_MAGTHRESH);
if(!x175.valid){
continue;
}
IkReal x174=x175.value;
j1array[0]=((-1.0)*x174);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x174)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*cj6*r20))+((r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*cj6*r10))+((r11*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x176=(r02*sj1);
IkReal x177=((9.0)*cj1);
CheckValue<IkReal> x178=IKPowWithIntegerCheck(((((10.0)*r11*sj6))+(((-10.0)*cj6*r10))),-1);
if(!x178.valid){
continue;
}
if( IKabs(((x178.value)*(((((9.0)*r12*x176))+x177+(((-1.0)*x177*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x176))+(((0.9)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x178.value)*(((((9.0)*r12*x176))+x177+(((-1.0)*x177*(r12*r12)))))))+IKsqr(((((-0.9)*x176))+(((0.9)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x178.value)*(((((9.0)*r12*x176))+x177+(((-1.0)*x177*(r12*r12)))))), ((((-0.9)*x176))+(((0.9)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x179=IKcos(j5);
IkReal x180=IKsin(j5);
IkReal x181=(r01*sj6);
IkReal x182=((0.45)*sj1);
IkReal x183=(r11*sj6);
IkReal x184=(cj6*r00);
IkReal x185=(cj6*r10);
IkReal x186=((0.45)*cj1);
IkReal x187=((0.5)*x180);
IkReal x188=((0.5)*x179);
evalcond[0]=((((-1.0)*r12*x186))+x188+((r02*x182)));
evalcond[1]=(((r21*sj6*x187))+(((-1.0)*cj6*r20*x187))+((r22*x188)));
evalcond[2]=(x182+(((-1.0)*x184*x187))+((r02*x188))+((x181*x187)));
evalcond[3]=((((-1.0)*x186))+((r12*x188))+(((-1.0)*x185*x187))+((x183*x187)));
evalcond[4]=((((-1.0)*x187))+(((-1.0)*x185*x186))+((x183*x186))+((x182*x184))+(((-1.0)*x181*x182)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x737=((9.0)*sj1);
IkReal x738=(cj1*r12);
CheckValue<IkReal> x739=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x739.valid){
continue;
}
if( IKabs(((x739.value)*(((((-9.0)*r02*x738))+(((-1.0)*x737))+((x737*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x738))+(((-0.9)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x739.value)*(((((-9.0)*r02*x738))+(((-1.0)*x737))+((x737*(r02*r02)))))))+IKsqr(((((0.9)*x738))+(((-0.9)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x739.value)*(((((-9.0)*r02*x738))+(((-1.0)*x737))+((x737*(r02*r02)))))), ((((0.9)*x738))+(((-0.9)*r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x740=IKcos(j5);
IkReal x741=IKsin(j5);
IkReal x742=(r01*sj6);
IkReal x743=((0.45)*sj1);
IkReal x744=(r11*sj6);
IkReal x745=(cj6*r00);
IkReal x746=(cj6*r10);
IkReal x747=((0.45)*cj1);
IkReal x748=((0.5)*x741);
IkReal x749=((0.5)*x740);
evalcond[0]=(((r02*x743))+(((-1.0)*r12*x747))+x749);
evalcond[1]=(((r22*x749))+((r21*sj6*x748))+(((-1.0)*cj6*r20*x748)));
evalcond[2]=(((r02*x749))+((x742*x748))+(((-1.0)*x745*x748))+x743);
evalcond[3]=((((-1.0)*x746*x748))+((x744*x748))+((r12*x749))+(((-1.0)*x747)));
evalcond[4]=((((-1.0)*x746*x747))+((x744*x747))+(((-1.0)*x742*x743))+((x743*x745))+(((-1.0)*x748)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x750=(cj1*r12);
IkReal x751=(r02*sj1);
IkReal x752=((0.45)*r22);
CheckValue<IkReal> x753=IKPowWithIntegerCheck(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))),-1);
if(!x753.valid){
continue;
}
if( IKabs(((x753.value)*(((((-1.0)*x750*x752))+((x751*x752)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x750))+(((-0.9)*x751)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x753.value)*(((((-1.0)*x750*x752))+((x751*x752))))))+IKsqr(((((0.9)*x750))+(((-0.9)*x751))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x753.value)*(((((-1.0)*x750*x752))+((x751*x752))))), ((((0.9)*x750))+(((-0.9)*x751))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x754=IKcos(j5);
IkReal x755=IKsin(j5);
IkReal x756=(r01*sj6);
IkReal x757=((0.45)*sj1);
IkReal x758=(r11*sj6);
IkReal x759=(cj6*r00);
IkReal x760=(cj6*r10);
IkReal x761=((0.45)*cj1);
IkReal x762=((0.5)*x755);
IkReal x763=((0.5)*x754);
evalcond[0]=(((r02*x757))+(((-1.0)*r12*x761))+x763);
evalcond[1]=(((r21*sj6*x762))+(((-1.0)*cj6*r20*x762))+((r22*x763)));
evalcond[2]=(((x756*x762))+((r02*x763))+x757+(((-1.0)*x759*x762)));
evalcond[3]=((((-1.0)*x761))+((x758*x762))+((r12*x763))+(((-1.0)*x760*x762)));
evalcond[4]=((((-1.0)*x762))+((x758*x761))+(((-1.0)*x756*x757))+(((-1.0)*x760*x761))+((x757*x759)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x765 = IKatan2WithCheck(IkReal(((0.5)*r22)),IkReal(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x765.valid){
continue;
}
IkReal x764=x765.value;
j5array[0]=((-1.0)*x764);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x764)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x766=(r21*sj6);
IkReal x767=(cj6*r20);
IkReal x768=((1.0)*cj5*sj6);
IkReal x769=((1.0)*cj5*cj6);
j1eval[0]=((((-1.0)*x767))+x766);
j1eval[1]=((IKabs(((((-1.0)*r10*x768))+(((-1.0)*r11*x769)))))+(IKabs(((((-1.0)*r00*x768))+(((-1.0)*r01*x769))))));
j1eval[2]=IKsign(((((-4.05)*x767))+(((4.05)*x766))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x770=((9.0)*cj5);
IkReal x771=(r20*sj6);
IkReal x772=((9.0)*sj5);
IkReal x773=(cj6*r21);
j1eval[0]=((((-1.0)*x773))+(((-1.0)*x771)));
j1eval[1]=((IKabs((((cj6*r00*x770))+(((-1.0)*r01*sj6*x770))+((r02*x772)))))+(IKabs(((((-1.0)*r11*sj6*x770))+((r12*x772))+((cj6*r10*x770))))));
j1eval[2]=IKsign(((((-8.1)*x771))+(((-8.1)*x773))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j1eval[0]=r12;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x774=(cj6*r00);
IkReal x775=((10.0)*cj5);
IkReal x776=(r01*sj6);
IkReal x777=((1.11111111111111)*sj5);
IkReal x778=((10.0)*r02*sj5);
CheckValue<IkReal> x779=IKPowWithIntegerCheck(r12,-1);
if(!x779.valid){
continue;
}
if( IKabs((((x774*x777))+(((-1.11111111111111)*cj5*r02))+(((-1.0)*x776*x777)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.111111111111111)*(x779.value)*((((x774*x778))+(((-1.0)*x775*(r02*r02)))+(((-1.0)*x776*x778))+x775)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x774*x777))+(((-1.11111111111111)*cj5*r02))+(((-1.0)*x776*x777))))+IKsqr(((0.111111111111111)*(x779.value)*((((x774*x778))+(((-1.0)*x775*(r02*r02)))+(((-1.0)*x776*x778))+x775))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((x774*x777))+(((-1.11111111111111)*cj5*r02))+(((-1.0)*x776*x777))), ((0.111111111111111)*(x779.value)*((((x774*x778))+(((-1.0)*x775*(r02*r02)))+(((-1.0)*x776*x778))+x775))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x780=IKsin(j1);
IkReal x781=IKcos(j1);
IkReal x782=(r01*sj6);
IkReal x783=(cj6*r00);
IkReal x784=((0.5)*sj5);
IkReal x785=(cj6*r10);
IkReal x786=(r11*sj6);
IkReal x787=((0.5)*cj5);
IkReal x788=((0.45)*x781);
IkReal x789=((0.45)*x780);
evalcond[0]=(((r02*x789))+(((-1.0)*r12*x788))+x787);
evalcond[1]=(((x782*x784))+((r02*x787))+x789+(((-1.0)*x783*x784)));
evalcond[2]=((((-1.0)*x788))+((x784*x786))+(((-1.0)*x784*x785))+((r12*x787)));
evalcond[3]=(((cj6*r01*x789))+((r00*sj6*x789))+(((-1.0)*cj6*r11*x788))+(((-1.0)*r10*sj6*x788)));
evalcond[4]=(((x786*x788))+(((-1.0)*x784))+((x783*x789))+(((-1.0)*x782*x789))+(((-1.0)*x785*x788)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x790=((9.0)*sj5);
IkReal x791=((9.0)*cj5*cj6);
IkReal x792=((9.0)*cj5*sj6);
CheckValue<IkReal> x793 = IKatan2WithCheck(IkReal((((r10*x791))+(((-1.0)*r11*x792))+((r12*x790)))),IkReal((((r00*x791))+(((-1.0)*r01*x792))+((r02*x790)))),IKFAST_ATAN2_MAGTHRESH);
if(!x793.valid){
continue;
}
CheckValue<IkReal> x794=IKPowWithIntegerCheck(IKsign(((((-8.1)*cj6*r21))+(((-8.1)*r20*sj6)))),-1);
if(!x794.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x793.value)+(((1.5707963267949)*(x794.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x795=IKsin(j1);
IkReal x796=IKcos(j1);
IkReal x797=(r01*sj6);
IkReal x798=(cj6*r00);
IkReal x799=((0.5)*sj5);
IkReal x800=(cj6*r10);
IkReal x801=(r11*sj6);
IkReal x802=((0.5)*cj5);
IkReal x803=((0.45)*x796);
IkReal x804=((0.45)*x795);
evalcond[0]=((((-1.0)*r12*x803))+((r02*x804))+x802);
evalcond[1]=((((-1.0)*x798*x799))+((r02*x802))+x804+((x797*x799)));
evalcond[2]=((((-1.0)*x799*x800))+((r12*x802))+((x799*x801))+(((-1.0)*x803)));
evalcond[3]=(((r00*sj6*x804))+(((-1.0)*cj6*r11*x803))+(((-1.0)*r10*sj6*x803))+((cj6*r01*x804)));
evalcond[4]=((((-1.0)*x799))+(((-1.0)*x797*x804))+((x798*x804))+(((-1.0)*x800*x803))+((x801*x803)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x805=((4.5)*cj5*sj6);
IkReal x806=((4.5)*cj5*cj6);
CheckValue<IkReal> x807 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x806))+(((-1.0)*r10*x805)))),IkReal(((((-1.0)*r01*x806))+(((-1.0)*r00*x805)))),IKFAST_ATAN2_MAGTHRESH);
if(!x807.valid){
continue;
}
CheckValue<IkReal> x808=IKPowWithIntegerCheck(IKsign(((((-4.05)*cj6*r20))+(((4.05)*r21*sj6)))),-1);
if(!x808.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x807.value)+(((1.5707963267949)*(x808.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x809=IKsin(j1);
IkReal x810=IKcos(j1);
IkReal x811=(r01*sj6);
IkReal x812=(cj6*r00);
IkReal x813=((0.5)*sj5);
IkReal x814=(cj6*r10);
IkReal x815=(r11*sj6);
IkReal x816=((0.5)*cj5);
IkReal x817=((0.45)*x810);
IkReal x818=((0.45)*x809);
evalcond[0]=((((-1.0)*r12*x817))+x816+((r02*x818)));
evalcond[1]=((((-1.0)*x812*x813))+((x811*x813))+x818+((r02*x816)));
evalcond[2]=((((-1.0)*x817))+((x813*x815))+(((-1.0)*x813*x814))+((r12*x816)));
evalcond[3]=(((cj6*r01*x818))+(((-1.0)*cj6*r11*x817))+((r00*sj6*x818))+(((-1.0)*r10*sj6*x817)));
evalcond[4]=(((x815*x817))+((x812*x818))+(((-1.0)*x811*x818))+(((-1.0)*x813))+(((-1.0)*x814*x817)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x819=((0.45)*cj6);
IkReal x820=((1.0)*pz);
IkReal x821=((0.45)*sj6);
IkReal x822=((((-1.0)*r11*x819))+(((-1.0)*r10*x821)));
IkReal x823=(((r01*x819))+((r00*x821)));
CheckValue<IkReal> x826 = IKatan2WithCheck(IkReal(x822),IkReal(x823),IKFAST_ATAN2_MAGTHRESH);
if(!x826.valid){
continue;
}
IkReal x824=((1.0)*(x826.value));
if((((x823*x823)+(x822*x822))) < -0.00001)
continue;
CheckValue<IkReal> x827=IKPowWithIntegerCheck(IKabs(IKsqrt(((x823*x823)+(x822*x822)))),-1);
if(!x827.valid){
continue;
}
if( (((-1.0)*(x827.value)*(((((-1.0)*cj6*r21*x820))+(((-1.0)*r20*sj6*x820)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x827.value)*(((((-1.0)*cj6*r21*x820))+(((-1.0)*r20*sj6*x820)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x825=((-1.0)*(IKasin(((-1.0)*(x827.value)*(((((-1.0)*cj6*r21*x820))+(((-1.0)*r20*sj6*x820))))))));
j1array[0]=((((-1.0)*x824))+(((-1.0)*x825)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((1.0)*x825))+(((-1.0)*x824)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
IkReal x828=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x828);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x828);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x828);
rxp2_2=0;
j5eval[0]=((((-1.0)*cj6*r20))+((r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x829=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x829);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x829);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x829);
rxp2_2=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x830=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x830);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x830);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x830);
rxp2_2=0;
j5eval[0]=((((-1.0)*cj6*r10))+((r11*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x831=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x831);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x831);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=((((-1.0)*cj6*r20))+((r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x832=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x832);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x832);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x833=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x833);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x833);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=((((-1.0)*cj6*pz*r20))+((pz*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x834=((200.0)*pz);
CheckValue<IkReal> x835=IKPowWithIntegerCheck(((((-1.0)*cj6*r20*x834))+((r21*sj6*x834))),-1);
if(!x835.valid){
continue;
}
if( IKabs(((19.0)*(x835.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.9)*cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((19.0)*(x835.value)))+IKsqr(((0.9)*cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((19.0)*(x835.value)), ((0.9)*cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x836=IKcos(j5);
IkReal x837=IKsin(j5);
IkReal x838=(cj6*r20);
IkReal x839=((1.0)*pz);
IkReal x840=(r01*sj6);
IkReal x841=(cj6*r00);
IkReal x842=((0.45)*sj1);
IkReal x843=((0.45)*cj1);
IkReal x844=((0.5)*x837);
IkReal x845=(pz*r21*sj6);
IkReal x846=((0.5)*x836);
evalcond[0]=((((-1.0)*r12*x843))+x846);
evalcond[1]=((((-1.0)*x843))+((r12*x846)));
evalcond[2]=((-0.095)+((x837*x845))+(((-1.0)*x837*x838*x839)));
evalcond[3]=((((-1.0)*x839))+((r21*sj6*x844))+(((-1.0)*x838*x844)));
evalcond[4]=((((-1.0)*x841*x844))+((x840*x844))+x842);
evalcond[5]=((((-1.0)*x840*x842))+(((-1.0)*x844))+(((-1.0)*x838*x839))+x845+((x841*x842)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x847=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x847.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x847.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.9)*cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x847.value)))+IKsqr(((0.9)*cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x847.value)), ((0.9)*cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x848=IKcos(j5);
IkReal x849=IKsin(j5);
IkReal x850=(cj6*r20);
IkReal x851=((1.0)*pz);
IkReal x852=(r01*sj6);
IkReal x853=(cj6*r00);
IkReal x854=((0.45)*sj1);
IkReal x855=((0.45)*cj1);
IkReal x856=((0.5)*x849);
IkReal x857=(pz*r21*sj6);
IkReal x858=((0.5)*x848);
evalcond[0]=((((-1.0)*r12*x855))+x858);
evalcond[1]=((((-1.0)*x855))+((r12*x858)));
evalcond[2]=((-0.095)+(((-1.0)*x849*x850*x851))+((x849*x857)));
evalcond[3]=(((r21*sj6*x856))+(((-1.0)*x851))+(((-1.0)*x850*x856)));
evalcond[4]=((((-1.0)*x853*x856))+((x852*x856))+x854);
evalcond[5]=((((-1.0)*x856))+(((-1.0)*x852*x854))+(((-1.0)*x850*x851))+x857+((x853*x854)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x859=IKPowWithIntegerCheck(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))),-1);
if(!x859.valid){
continue;
}
if( IKabs((pz*(x859.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.9)*cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x859.value)))+IKsqr(((0.9)*cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((pz*(x859.value)), ((0.9)*cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x860=IKcos(j5);
IkReal x861=IKsin(j5);
IkReal x862=(cj6*r20);
IkReal x863=((1.0)*pz);
IkReal x864=(r01*sj6);
IkReal x865=(cj6*r00);
IkReal x866=((0.45)*sj1);
IkReal x867=((0.45)*cj1);
IkReal x868=((0.5)*x861);
IkReal x869=(pz*r21*sj6);
IkReal x870=((0.5)*x860);
evalcond[0]=(x870+(((-1.0)*r12*x867)));
evalcond[1]=((((-1.0)*x867))+((r12*x870)));
evalcond[2]=((-0.095)+(((-1.0)*x861*x862*x863))+((x861*x869)));
evalcond[3]=((((-1.0)*x863))+((r21*sj6*x868))+(((-1.0)*x862*x868)));
evalcond[4]=((((-1.0)*x865*x868))+x866+((x864*x868)));
evalcond[5]=((((-1.0)*x868))+(((-1.0)*x862*x863))+(((-1.0)*x864*x866))+x869+((x865*x866)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x871=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x871);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x871);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x872=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x872);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x872);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*cj6*r10))+((r11*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x873=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x873);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x873);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
j5eval[1]=pz;
j5eval[2]=r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x874=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x874.valid){
continue;
}
CheckValue<IkReal> x875=IKPowWithIntegerCheck(pz,-1);
if(!x875.valid){
continue;
}
CheckValue<IkReal> x876=IKPowWithIntegerCheck(r22,-1);
if(!x876.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x874.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.095)*(x875.value)*(x876.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x874.value)))+IKsqr(((0.095)*(x875.value)*(x876.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x874.value)), ((0.095)*(x875.value)*(x876.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x877=IKcos(j5);
IkReal x878=IKsin(j5);
IkReal x879=((0.45)*cj1);
IkReal x880=(cj6*r10);
IkReal x881=(r01*sj6);
IkReal x882=((1.0)*pz);
IkReal x883=(r11*sj6);
IkReal x884=(cj6*r00);
IkReal x885=((0.45)*sj1);
IkReal x886=((0.5)*x878);
IkReal x887=((0.5)*x877);
evalcond[0]=((-0.095)+((pz*r22*x877)));
evalcond[1]=(x887+(((-1.0)*r22*x882)));
evalcond[2]=((((-1.0)*x882))+((r22*x887)));
evalcond[3]=(((x881*x886))+x885+(((-1.0)*x884*x886)));
evalcond[4]=(((x883*x886))+(((-1.0)*x880*x886))+(((-1.0)*x879)));
evalcond[5]=((((-1.0)*x879*x880))+((x879*x883))+(((-1.0)*x886))+(((-1.0)*x881*x885))+((x884*x885)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x888=IKPowWithIntegerCheck(((((10.0)*r11*sj6))+(((-10.0)*cj6*r10))),-1);
if(!x888.valid){
continue;
}
if( IKabs(((9.0)*cj1*(x888.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.0)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((9.0)*cj1*(x888.value)))+IKsqr(((2.0)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((9.0)*cj1*(x888.value)), ((2.0)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x889=IKcos(j5);
IkReal x890=IKsin(j5);
IkReal x891=((0.45)*cj1);
IkReal x892=(cj6*r10);
IkReal x893=(r01*sj6);
IkReal x894=((1.0)*pz);
IkReal x895=(r11*sj6);
IkReal x896=(cj6*r00);
IkReal x897=((0.45)*sj1);
IkReal x898=((0.5)*x890);
IkReal x899=((0.5)*x889);
evalcond[0]=((-0.095)+((pz*r22*x889)));
evalcond[1]=((((-1.0)*r22*x894))+x899);
evalcond[2]=((((-1.0)*x894))+((r22*x899)));
evalcond[3]=((((-1.0)*x896*x898))+((x893*x898))+x897);
evalcond[4]=((((-1.0)*x892*x898))+((x895*x898))+(((-1.0)*x891)));
evalcond[5]=(((x896*x897))+(((-1.0)*x898))+(((-1.0)*x893*x897))+((x891*x895))+(((-1.0)*x891*x892)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x900=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x900.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x900.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.0)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x900.value)))+IKsqr(((2.0)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x900.value)), ((2.0)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x901=IKcos(j5);
IkReal x902=IKsin(j5);
IkReal x903=((0.45)*cj1);
IkReal x904=(cj6*r10);
IkReal x905=(r01*sj6);
IkReal x906=((1.0)*pz);
IkReal x907=(r11*sj6);
IkReal x908=(cj6*r00);
IkReal x909=((0.45)*sj1);
IkReal x910=((0.5)*x902);
IkReal x911=((0.5)*x901);
evalcond[0]=((-0.095)+((pz*r22*x901)));
evalcond[1]=((((-1.0)*r22*x906))+x911);
evalcond[2]=((((-1.0)*x906))+((r22*x911)));
evalcond[3]=((((-1.0)*x908*x910))+((x905*x910))+x909);
evalcond[4]=((((-1.0)*x903))+((x907*x910))+(((-1.0)*x904*x910)));
evalcond[5]=((((-1.0)*x903*x904))+((x903*x907))+(((-1.0)*x910))+((x908*x909))+(((-1.0)*x905*x909)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x912=(pz*r22);
IkReal x913=(r02*sj1);
IkReal x914=((9.0)*cj1);
CheckValue<IkReal> x915=IKPowWithIntegerCheck(((((10.0)*r11*sj6))+(((-10.0)*cj6*r10))),-1);
if(!x915.valid){
continue;
}
if( IKabs(((x915.value)*(((((-1.0)*x914*(r12*r12)))+(((9.0)*r12*x913))+x914+(((-20.0)*r12*x912)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x913))+(((0.9)*cj1*r12))+(((2.0)*x912)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x915.value)*(((((-1.0)*x914*(r12*r12)))+(((9.0)*r12*x913))+x914+(((-20.0)*r12*x912))))))+IKsqr(((((-0.9)*x913))+(((0.9)*cj1*r12))+(((2.0)*x912))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x915.value)*(((((-1.0)*x914*(r12*r12)))+(((9.0)*r12*x913))+x914+(((-20.0)*r12*x912))))), ((((-0.9)*x913))+(((0.9)*cj1*r12))+(((2.0)*x912))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x916=IKcos(j5);
IkReal x917=IKsin(j5);
IkReal x918=((0.45)*sj6);
IkReal x919=(pz*r22);
IkReal x920=((0.45)*cj1);
IkReal x921=((0.45)*sj1);
IkReal x922=((0.5)*x916);
IkReal x923=(cj6*x917);
IkReal x924=((1.0)*pz*r20);
IkReal x925=(pz*r21*sj6);
IkReal x926=((0.5)*sj6*x917);
evalcond[0]=((((-1.0)*r12*x920))+(((-1.0)*x919))+x922+((r02*x921)));
evalcond[1]=((-0.095)+((x917*x925))+((x916*x919))+(((-1.0)*x923*x924)));
evalcond[2]=(((r22*x922))+((r21*x926))+(((-0.5)*r20*x923))+(((-1.0)*pz)));
evalcond[3]=((((-0.5)*r00*x923))+((r01*x926))+x921+((r02*x922)));
evalcond[4]=((((-1.0)*x920))+(((-0.5)*r10*x923))+((r11*x926))+((r12*x922)));
evalcond[5]=((((-1.0)*cj6*r10*x920))+(((-1.0)*cj6*x924))+(((-1.0)*r01*sj1*x918))+(((-0.5)*x917))+((cj1*r11*x918))+x925+((cj6*r00*x921)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x927=((9.0)*sj1);
IkReal x928=(pz*r22);
IkReal x929=(cj1*r12);
CheckValue<IkReal> x930=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x930.valid){
continue;
}
if( IKabs(((x930.value)*(((((-1.0)*x927))+((x927*(r02*r02)))+(((-20.0)*r02*x928))+(((-9.0)*r02*x929)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*r02*sj1))+(((2.0)*x928))+(((0.9)*x929)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x930.value)*(((((-1.0)*x927))+((x927*(r02*r02)))+(((-20.0)*r02*x928))+(((-9.0)*r02*x929))))))+IKsqr(((((-0.9)*r02*sj1))+(((2.0)*x928))+(((0.9)*x929))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x930.value)*(((((-1.0)*x927))+((x927*(r02*r02)))+(((-20.0)*r02*x928))+(((-9.0)*r02*x929))))), ((((-0.9)*r02*sj1))+(((2.0)*x928))+(((0.9)*x929))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x931=IKcos(j5);
IkReal x932=IKsin(j5);
IkReal x933=((0.45)*sj6);
IkReal x934=(pz*r22);
IkReal x935=((0.45)*cj1);
IkReal x936=((0.45)*sj1);
IkReal x937=((0.5)*x931);
IkReal x938=(cj6*x932);
IkReal x939=((1.0)*pz*r20);
IkReal x940=(pz*r21*sj6);
IkReal x941=((0.5)*sj6*x932);
evalcond[0]=((((-1.0)*r12*x935))+(((-1.0)*x934))+x937+((r02*x936)));
evalcond[1]=((-0.095)+((x932*x940))+((x931*x934))+(((-1.0)*x938*x939)));
evalcond[2]=(((r21*x941))+((r22*x937))+(((-0.5)*r20*x938))+(((-1.0)*pz)));
evalcond[3]=((((-0.5)*r00*x938))+((r01*x941))+x936+((r02*x937)));
evalcond[4]=((((-0.5)*r10*x938))+((r11*x941))+((r12*x937))+(((-1.0)*x935)));
evalcond[5]=((((-1.0)*cj6*r10*x935))+(((-1.0)*cj6*x939))+((cj1*r11*x933))+x940+(((-1.0)*r01*sj1*x933))+((cj6*r00*x936))+(((-0.5)*x932)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x942=(cj1*r12);
IkReal x943=(r02*sj1);
IkReal x944=((0.45)*r22);
CheckValue<IkReal> x945=IKPowWithIntegerCheck(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))),-1);
if(!x945.valid){
continue;
}
if( IKabs(((x945.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x942*x944))+((x943*x944))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x943))+(((2.0)*pz*r22))+(((0.9)*x942)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x945.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x942*x944))+((x943*x944))+pz))))+IKsqr(((((-0.9)*x943))+(((2.0)*pz*r22))+(((0.9)*x942))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x945.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x942*x944))+((x943*x944))+pz))), ((((-0.9)*x943))+(((2.0)*pz*r22))+(((0.9)*x942))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x946=IKcos(j5);
IkReal x947=IKsin(j5);
IkReal x948=((0.45)*sj6);
IkReal x949=(pz*r22);
IkReal x950=((0.45)*cj1);
IkReal x951=((0.45)*sj1);
IkReal x952=((0.5)*x946);
IkReal x953=(cj6*x947);
IkReal x954=((1.0)*pz*r20);
IkReal x955=(pz*r21*sj6);
IkReal x956=((0.5)*sj6*x947);
evalcond[0]=((((-1.0)*x949))+((r02*x951))+(((-1.0)*r12*x950))+x952);
evalcond[1]=((-0.095)+((x946*x949))+((x947*x955))+(((-1.0)*x953*x954)));
evalcond[2]=((((-0.5)*r20*x953))+((r22*x952))+(((-1.0)*pz))+((r21*x956)));
evalcond[3]=(((r01*x956))+((r02*x952))+x951+(((-0.5)*r00*x953)));
evalcond[4]=((((-0.5)*r10*x953))+((r11*x956))+((r12*x952))+(((-1.0)*x950)));
evalcond[5]=((((-0.5)*x947))+(((-1.0)*r01*sj1*x948))+(((-1.0)*cj6*x954))+((cj6*r00*x951))+x955+((cj1*r11*x948))+(((-1.0)*cj6*r10*x950)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x957=((((-1.0)*cj6*pz*r20))+((pz*r21*sj6)));
CheckValue<IkReal> x960 = IKatan2WithCheck(IkReal((pz*r22)),IkReal(x957),IKFAST_ATAN2_MAGTHRESH);
if(!x960.valid){
continue;
}
IkReal x958=((1.0)*(x960.value));
if((((x957*x957)+(((pz*pz)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x961=IKPowWithIntegerCheck(IKabs(IKsqrt(((x957*x957)+(((pz*pz)*(r22*r22)))))),-1);
if(!x961.valid){
continue;
}
if( (((0.095)*(x961.value))) < -1-IKFAST_SINCOS_THRESH || (((0.095)*(x961.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x959=IKasin(((0.095)*(x961.value)));
j5array[0]=((((-1.0)*x958))+x959);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x959))+(((-1.0)*x958)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x962=IKsin(j5);
IkReal x963=((0.5)*x962);
evalcond[0]=((((-1.0)*cj6*r20*x963))+(((0.5)*r22*(IKcos(j5))))+(((-1.0)*pz))+((r21*sj6*x963)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x964=((1.11111111111111)*cj5);
IkReal x965=((1.11111111111111)*sj5*sj6);
IkReal x966=((1.11111111111111)*cj6*sj5);
if( IKabs(((((-1.0)*r01*x965))+((r00*x966))+(((-1.0)*r02*x964)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r10*x966))+((r11*x965))+((r12*x964)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*x965))+((r00*x966))+(((-1.0)*r02*x964))))+IKsqr(((((-1.0)*r10*x966))+((r11*x965))+((r12*x964))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r01*x965))+((r00*x966))+(((-1.0)*r02*x964))), ((((-1.0)*r10*x966))+((r11*x965))+((r12*x964))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x967=IKsin(j1);
IkReal x968=IKcos(j1);
IkReal x969=(r01*sj6);
IkReal x970=(cj6*r00);
IkReal x971=((0.5)*sj5);
IkReal x972=((0.5)*cj5);
IkReal x973=(pz*sj6);
IkReal x974=(cj6*r10);
IkReal x975=((1.0)*r20);
IkReal x976=(cj6*pz);
IkReal x977=(r11*sj6);
IkReal x978=((0.45)*x967);
IkReal x979=((0.45)*x968);
evalcond[0]=((((-1.0)*pz*r22))+((r02*x978))+(((-1.0)*r12*x979))+x972);
evalcond[1]=(((x969*x971))+(((-1.0)*x970*x971))+((r02*x972))+x978);
evalcond[2]=((((-1.0)*x971*x974))+((r12*x972))+((x971*x977))+(((-1.0)*x979)));
evalcond[3]=((((-1.0)*r10*sj6*x979))+((r00*sj6*x978))+(((-1.0)*cj6*r11*x979))+((cj6*r01*x978))+(((-1.0)*r21*x976))+(((-1.0)*x973*x975)));
evalcond[4]=((((-1.0)*x969*x978))+((x977*x979))+((r21*x973))+(((-1.0)*x974*x979))+((x970*x978))+(((-1.0)*x975*x976))+(((-1.0)*x971)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x980=((((0.5)*r21*sj6))+(((-0.5)*cj6*r20)));
CheckValue<IkReal> x983 = IKatan2WithCheck(IkReal(((0.5)*r22)),IkReal(x980),IKFAST_ATAN2_MAGTHRESH);
if(!x983.valid){
continue;
}
IkReal x981=((1.0)*(x983.value));
if((((x980*x980)+(((0.25)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x984=IKPowWithIntegerCheck(IKabs(IKsqrt(((x980*x980)+(((0.25)*(r22*r22)))))),-1);
if(!x984.valid){
continue;
}
if( ((pz*(x984.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x984.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x982=IKasin((pz*(x984.value)));
j5array[0]=((((-1.0)*x981))+x982);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x981))+(((-1.0)*x982)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x985=IKsin(j5);
IkReal x986=(pz*x985);
evalcond[0]=((-0.095)+(((-1.0)*cj6*r20*x986))+((pz*r22*(IKcos(j5))))+((r21*sj6*x986)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x987=((1.11111111111111)*cj5);
IkReal x988=((1.11111111111111)*sj5*sj6);
IkReal x989=((1.11111111111111)*cj6*sj5);
if( IKabs(((((-1.0)*r01*x988))+((r00*x989))+(((-1.0)*r02*x987)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r10*x989))+((r12*x987))+((r11*x988)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*x988))+((r00*x989))+(((-1.0)*r02*x987))))+IKsqr(((((-1.0)*r10*x989))+((r12*x987))+((r11*x988))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r01*x988))+((r00*x989))+(((-1.0)*r02*x987))), ((((-1.0)*r10*x989))+((r12*x987))+((r11*x988))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x990=IKsin(j1);
IkReal x991=IKcos(j1);
IkReal x992=(r01*sj6);
IkReal x993=(cj6*r00);
IkReal x994=((0.5)*sj5);
IkReal x995=((0.5)*cj5);
IkReal x996=(pz*sj6);
IkReal x997=(cj6*r10);
IkReal x998=((1.0)*r20);
IkReal x999=(cj6*pz);
IkReal x1000=(r11*sj6);
IkReal x1001=((0.45)*x990);
IkReal x1002=((0.45)*x991);
evalcond[0]=((((-1.0)*pz*r22))+((r02*x1001))+(((-1.0)*r12*x1002))+x995);
evalcond[1]=(x1001+((x992*x994))+((r02*x995))+(((-1.0)*x993*x994)));
evalcond[2]=(((x1000*x994))+((r12*x995))+(((-1.0)*x994*x997))+(((-1.0)*x1002)));
evalcond[3]=((((-1.0)*cj6*r11*x1002))+(((-1.0)*x996*x998))+((r00*sj6*x1001))+(((-1.0)*r21*x999))+(((-1.0)*r10*sj6*x1002))+((cj6*r01*x1001)));
evalcond[4]=((((-1.0)*x1002*x997))+((x1000*x1002))+(((-1.0)*x994))+(((-1.0)*x1001*x992))+((x1001*x993))+((r21*x996))+(((-1.0)*x998*x999)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x1003=((0.5)*r22);
IkReal x1004=((1.0)*pz);
IkReal x1005=((-0.095)+(((-1.0)*r22*x1004)));
IkReal x1006=(x1003+(((-1.0)*x1004)));
IkReal x1007=((-1.0)*pz);
IkReal x1008=((((-1.0)*x1003))+(((-1.0)*x1004)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1007);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1007);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1007);
rxp2_2=0;
IkReal gconst28=x1005;
IkReal gconst29=x1006;
IkReal gconst30=x1008;
IkReal gconst31=x1005;
IkReal gconst32=x1006;
IkReal gconst33=x1008;
IkReal gconst34=x1005;
IkReal gconst35=x1006;
IkReal gconst36=x1008;
IkReal gconst37=x1005;
IkReal gconst38=x1006;
IkReal gconst39=x1008;
IkReal x1009=pz*pz;
IkReal x1010=r20*r20;
IkReal x1011=pz*pz*pz*pz;
IkReal x1012=r22*r22;
IkReal x1013=r21*r21;
IkReal x1014=(r20*r21);
IkReal x1015=((16.0)*x1011);
IkReal x1016=((1.52)*x1009);
IkReal x1017=((4.0)*x1011);
IkReal x1018=((0.38)*x1009);
IkReal x1019=(x1014*x1016);
IkReal x1020=(((x1014*x1015))+(((0.0361)*x1014)));
j6eval[0]=((IKabs((x1020+(((-1.0)*x1019)))))+(IKabs(((((-1.0)*x1012*x1015))+((x1013*x1016))+((x1012*x1016))+(((-0.0361)*x1013))+(((-0.0361)*x1012))+(((-1.0)*x1013*x1015)))))+(((0.5)*(IKabs(((((-24.0)*x1011*x1012))+(((3.04)*x1009*x1013))+(((-0.76)*x1009*x1010))+(((2.28)*x1009*x1012))+(((0.01805)*x1010))+(((-32.0)*x1011*x1013))+(((8.0)*x1010*x1011))+(((-0.0722)*x1013))+(((-0.05415)*x1012)))))))+(((0.5)*(IKabs(((((-1.0)*x1012*x1017))+(((-1.0)*x1010*x1017))+(((-0.009025)*x1012))+(((-0.009025)*x1010))+((x1012*x1018))+((x1010*x1018)))))))+(IKabs((x1019+(((-1.0)*x1020))))));
if( IKabs(j6eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x1021=r20*r20;
IkReal x1022=pz*pz;
IkReal x1023=r21*r21;
IkReal x1024=r22*r22;
IkReal x1025=((0.19)*gconst39);
IkReal x1026=(gconst32*pz);
IkReal x1027=(gconst32*gconst37);
IkReal x1028=(gconst33*gconst35);
IkReal x1029=(gconst29*gconst39);
IkReal x1030=((0.009025)*gconst30);
IkReal x1031=((0.095)*gconst34);
IkReal x1032=(gconst36*gconst39);
IkReal x1033=(gconst38*pz);
IkReal x1034=(r20*r21);
IkReal x1035=(gconst31*gconst35);
IkReal x1036=((1.0)*gconst32);
IkReal x1037=(gconst29*gconst33);
IkReal x1038=((0.095)*gconst28);
IkReal x1039=(gconst33*gconst36);
IkReal x1040=(gconst30*gconst31);
IkReal x1041=((1.0)*gconst34);
IkReal x1042=((0.095)*gconst30);
IkReal x1043=(gconst37*gconst38);
IkReal x1044=((0.19)*gconst33);
IkReal x1045=(gconst35*gconst39);
IkReal x1046=(gconst32*gconst36);
IkReal x1047=(gconst29*gconst31);
IkReal x1048=((0.095)*gconst38);
IkReal x1049=((0.095)*gconst36);
IkReal x1050=((1.0)*gconst28);
IkReal x1051=(gconst30*gconst33);
IkReal x1052=(gconst39*x1030);
IkReal x1053=((0.009025)*x1039);
IkReal x1054=(gconst36*pz*r22);
IkReal x1055=((16.0)*x1023);
IkReal x1056=(gconst28*pz*r22);
IkReal x1057=(gconst38*x1041);
IkReal x1058=((8.0)*x1021);
IkReal x1059=(gconst28*x1023);
IkReal x1060=(gconst30*pz*r22);
IkReal x1061=((2.0)*x1021);
IkReal x1062=((4.0)*x1023);
IkReal x1063=((4.0)*x1021);
IkReal x1064=(gconst34*x1023);
IkReal x1065=((8.0)*x1023);
IkReal x1066=(pz*x1021);
IkReal x1067=(gconst30*x1022);
IkReal x1068=(gconst34*pz*r22);
IkReal x1069=((2.0)*x1024);
IkReal x1070=(gconst30*gconst37*r22);
IkReal x1071=(x1031*x1045);
IkReal x1072=(x1043*x1049);
IkReal x1073=(x1021*x1031);
IkReal x1074=(x1021*x1038);
IkReal x1075=(x1037*x1038);
IkReal x1076=((0.095)*gconst32*x1040);
IkReal x1077=(gconst36*gconst38*x1022);
IkReal x1078=(gconst34*x1061);
IkReal x1079=(gconst36*r22*x1022);
IkReal x1080=((0.76)*pz*x1023);
IkReal x1081=(gconst36*gconst37*r22*x1033);
IkReal x1082=(x1045*x1068);
IkReal x1083=((0.19)*gconst36*x1066);
IkReal x1084=((1.52)*x1022*x1034);
IkReal x1085=((0.19)*pz*r22*x1039);
IkReal x1086=(x1025*x1060);
IkReal x1087=((0.19)*gconst30*x1066);
IkReal x1088=(r22*x1026*x1040);
IkReal x1089=(x1037*x1056);
IkReal x1090=((1.0)*x1022*x1024);
IkReal x1091=(gconst28*x1033*x1061);
IkReal x1092=(x1026*x1078);
IkReal x1093=(r22*x1041*x1066);
IkReal x1094=(r22*x1050*x1066);
IkReal x1095=(x1061*x1079);
IkReal x1096=(r22*x1061*x1067);
IkReal x1097=((1.0)*gconst39*x1024*x1067);
IkReal x1098=(x1039*x1090);
IkReal x1099=(x1022*x1046*x1063);
IkReal x1100=(gconst38*x1063*x1067);
IkReal x1101=((((16.0)*x1034*(x1022*x1022)))+(((0.0361)*x1034)));
IkReal x1102=(x1072+x1071);
IkReal x1103=(x1076+x1075);
IkReal x1104=(x1089+x1088);
IkReal x1105=(x1082+x1081);
IkReal x1106=(x1094+x1087);
IkReal x1107=(x1073+x1095);
IkReal x1108=(x1093+x1083);
IkReal x1109=(x1074+x1096);
IkReal x1110=(x1084+(((-1.0)*x1101)));
IkReal x1111=(x1101+(((-1.0)*x1084)));
IkReal x1112=(x1091+x1092+x1086+x1085);
IkReal x1113=(x1100+x1052+x1053+x1097+x1098+x1099);
op[0]=((((-1.0)*x1063*x1077))+((x1033*x1078))+x1107+x1105+((x1025*x1054))+(((-0.009025)*x1032))+(((-1.0)*x1032*x1090))+(((-1.0)*x1102))+(((-1.0)*x1108))+(((-1.0)*gconst35*x1041*x1043)));
op[1]=x1110;
op[2]=(((x1033*x1070))+x1105+x1109+x1112+((x1058*x1077))+(((-1.0)*x1028*x1031))+x1083+(((-1.0)*x1038*x1045))+(((-1.0)*gconst35*x1027*x1041))+(((-1.0)*x1029*x1031))+(((-0.01805)*x1032))+((gconst36*gconst37*r22*x1026))+(((-1.0)*gconst31*gconst36*x1048))+(((-1.0)*gconst29*x1041*x1043))+(((8.0)*x1033*x1064))+(((-1.0)*x1027*x1049))+(((-1.0)*x1022*x1032*x1069))+(((-1.0)*x1062*x1068))+((gconst34*r22*x1066))+(((-1.0)*x1042*x1043))+(((0.38)*pz*r22*x1032))+(((-1.0)*gconst36*x1080))+(((0.38)*x1064))+(((-1.0)*x1055*x1077))+(((-1.0)*gconst35*x1043*x1050))+((x1028*x1068))+(((-1.0)*x1035*x1057))+(((-1.0)*x1102))+(((-1.0)*x1107))+(((-1.0)*x1106))+((x1029*x1068))+((gconst31*gconst36*r22*x1033))+(((-1.0)*x1113))+(((-1.0)*gconst34*x1033*x1063))+((x1065*x1079))+((x1045*x1056)));
op[3]=x1110;
op[4]=((((-0.009025)*gconst36*gconst39))+(((-0.095)*gconst29*gconst33*gconst34))+(((0.38)*gconst34*(r21*r21)))+((gconst31*gconst32*gconst36*pz*r22))+(((-0.76)*gconst30*pz*(r21*r21)))+(((8.0)*gconst28*gconst38*pz*(r21*r21)))+(((-0.095)*gconst32*gconst36*gconst37))+(((-1.0)*gconst36*gconst39*(pz*pz)*(r22*r22)))+(((-4.0)*gconst28*pz*r22*(r21*r21)))+(((-2.0)*gconst30*gconst39*(pz*pz)*(r22*r22)))+((gconst33*gconst34*gconst35*pz*r22))+(((-4.0)*gconst32*gconst34*pz*(r20*r20)))+(((0.38)*gconst28*(r21*r21)))+(((-1.0)*gconst28*gconst31*gconst35*gconst38))+(((-16.0)*gconst32*gconst36*(pz*pz)*(r21*r21)))+((gconst29*gconst34*gconst39*pz*r22))+(((-0.009025)*gconst30*gconst33))+(((2.0)*gconst28*gconst32*pz*(r20*r20)))+(((0.19)*gconst30*gconst33*pz*r22))+(((-0.095)*gconst29*gconst34*gconst39))+(((0.38)*gconst33*gconst36*pz*r22))+(((2.0)*gconst34*gconst38*pz*(r20*r20)))+(((0.19)*gconst30*pz*(r20*r20)))+(((-2.0)*gconst33*gconst36*(pz*pz)*(r22*r22)))+(((8.0)*gconst32*gconst36*(pz*pz)*(r20*r20)))+(((8.0)*gconst36*r22*(pz*pz)*(r21*r21)))+((gconst28*gconst35*gconst39*pz*r22))+(((-2.0)*gconst30*r22*(pz*pz)*(r20*r20)))+(((-4.0)*gconst28*gconst38*pz*(r20*r20)))+(((-0.095)*gconst28*gconst35*gconst39))+(((-0.095)*gconst28*(r20*r20)))+(((-2.0)*gconst36*r22*(pz*pz)*(r20*r20)))+((gconst28*pz*r22*(r20*r20)))+(((-0.095)*gconst31*gconst36*gconst38))+(((-1.0)*gconst30*gconst33*(pz*pz)*(r22*r22)))+((gconst28*gconst33*gconst35*pz*r22))+((gconst31*gconst36*gconst38*pz*r22))+((gconst29*gconst33*gconst34*pz*r22))+((gconst30*gconst32*gconst37*pz*r22))+(((-1.0)*gconst29*gconst31*gconst34*gconst38))+(((-16.0)*gconst30*gconst38*(pz*pz)*(r21*r21)))+(((-0.095)*gconst28*gconst33*gconst35))+(((-1.0)*gconst31*gconst32*gconst34*gconst35))+((gconst34*pz*r22*(r20*r20)))+(((0.38)*gconst30*gconst39*pz*r22))+(((0.19)*gconst36*gconst39*pz*r22))+(((-0.095)*gconst31*gconst32*gconst36))+(((-0.01805)*gconst30*gconst39))+(((-0.01805)*gconst33*gconst36))+(((-0.095)*gconst30*gconst32*gconst37))+(((-4.0)*gconst36*gconst38*(pz*pz)*(r20*r20)))+(((8.0)*gconst30*r22*(pz*pz)*(r21*r21)))+(((-0.095)*gconst30*gconst31*gconst38))+(((-1.0)*gconst28*gconst32*gconst35*gconst37))+((gconst30*gconst31*gconst38*pz*r22))+((gconst30*gconst37*gconst38*pz*r22))+(((-0.095)*gconst33*gconst34*gconst35))+((gconst28*gconst29*gconst39*pz*r22))+((gconst32*gconst36*gconst37*pz*r22))+(((-0.095)*gconst28*gconst29*gconst39))+(((-0.76)*gconst36*pz*(r21*r21)))+(((-0.095)*gconst30*gconst37*gconst38))+(((8.0)*gconst30*gconst38*(pz*pz)*(r20*r20)))+(((-1.0)*gconst29*gconst32*gconst34*gconst37))+(((-4.0)*gconst34*pz*r22*(r21*r21)))+(((-4.0)*gconst30*gconst32*(pz*pz)*(r20*r20)))+(((-0.095)*gconst34*(r20*r20)))+(((8.0)*gconst32*gconst34*pz*(r21*r21)))+(((-1.0)*gconst28*gconst29*gconst37*gconst38))+(((0.19)*gconst36*pz*(r20*r20))));
op[5]=x1111;
op[6]=(((gconst32*x1058*x1067))+(((-1.0)*gconst34*x1036*x1047))+((x1037*x1068))+((x1021*x1056))+x1107+x1104+x1112+(((-1.0)*x1028*x1038))+x1087+((r22*x1065*x1067))+((gconst31*gconst36*r22*x1026))+(((-1.0)*x1029*x1038))+(((-1.0)*gconst32*x1055*x1067))+(((-1.0)*gconst28*x1026*x1063))+(((-1.0)*x1027*x1042))+(((-1.0)*gconst30*x1080))+(((-1.0)*x1056*x1062))+(((-1.0)*gconst29*x1027*x1050))+(((-1.0)*gconst38*x1047*x1050))+(((-0.095)*gconst31*x1046))+(((-1.0)*x1031*x1037))+(((8.0)*x1026*x1059))+((x1029*x1056))+(((-1.0)*x1022*x1051*x1069))+((r22*x1033*x1040))+(((-1.0)*x1040*x1048))+((x1028*x1056))+(((-0.01805)*x1051))+((x1026*x1070))+(((-1.0)*x1103))+(((-1.0)*x1109))+(((-1.0)*x1108))+(((0.38)*x1059))+(((-1.0)*x1113))+(((-1.0)*gconst28*x1035*x1036))+(((0.38)*pz*r22*x1051)));
op[7]=x1111;
op[8]=(x1104+x1109+((x1044*x1060))+(((-1.0)*gconst33*x1030))+(((-1.0)*gconst32*x1063*x1067))+(((-1.0)*x1051*x1090))+((gconst28*x1026*x1061))+(((-1.0)*gconst28*x1036*x1047))+(((-1.0)*x1103))+(((-1.0)*x1106)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[2];
IkReal x1114=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1114);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1114);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1114);
rxp2_2=0;
IkReal x1115=(r21*sj6);
IkReal x1116=(cj6*r20);
j5eval[0]=((((-2.0)*x1115*x1116))+(x1115*x1115)+(r22*r22)+(x1116*x1116));
j5eval[1]=((IKabs(((((-0.5)*x1116))+(((0.5)*x1115)))))+(((0.5)*(IKabs(r22)))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1117=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1117);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1117);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1117);
rxp2_2=0;
IkReal x1118=pz*pz;
IkReal x1119=(cj6*r20);
IkReal x1120=(r21*sj6);
j5eval[0]=((((-2.0)*x1118*x1119*x1120))+((x1118*(x1119*x1119)))+((x1118*(x1120*x1120)))+((x1118*(r22*r22))));
j5eval[1]=((IKabs(((((-1.0)*pz*x1119))+((pz*x1120)))))+(IKabs((pz*r22))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1121=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1121);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1121);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1121);
rxp2_2=0;
IkReal x1122=cj6*cj6;
IkReal x1123=sj6*sj6;
IkReal x1124=(cj6*r11);
IkReal x1125=(r00*sj6);
IkReal x1126=(cj6*r01);
IkReal x1127=(r10*sj6);
j1eval[0]=(((x1122*(r11*r11)))+((x1123*(r00*r00)))+(((2.0)*x1125*x1126))+((x1122*(r01*r01)))+((x1123*(r10*r10)))+(((2.0)*x1124*x1127)));
j1eval[1]=((IKabs(((((0.45)*x1125))+(((0.45)*x1126)))))+(IKabs(((((-0.45)*x1127))+(((-0.45)*x1124))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((0.5)*(IKabs(r22))))+(IKabs(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1128=((0.45)*cj6);
IkReal x1129=((0.45)*sj6);
j1eval[0]=((IKabs((((r00*x1129))+((r01*x1128)))))+(IKabs(((((-1.0)*r11*x1128))+(((-1.0)*r10*x1129))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1, j5]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1130=((0.45)*cj6);
IkReal x1131=((0.45)*sj6);
CheckValue<IkReal> x1133 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1130))+(((-1.0)*r10*x1131)))),IkReal((((r01*x1130))+((r00*x1131)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1133.valid){
continue;
}
IkReal x1132=x1133.value;
j1array[0]=((-1.0)*x1132);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1132)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*cj6*r20))+((r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*cj6*r10))+((r11*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=((0.9)*cj1*r12);
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1134=IKsin(j5);
IkReal x1135=((0.5)*x1134);
evalcond[0]=((-0.5)*x1134);
evalcond[1]=((((0.5)*r12*(IKcos(j5))))+(((-0.45)*cj1)));
evalcond[2]=(((r21*sj6*x1135))+(((-1.0)*cj6*r20*x1135)));
evalcond[3]=(((r01*sj6*x1135))+(((-1.0)*cj6*r00*x1135)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1136=((0.9)*cj6);
IkReal x1137=((0.9)*sj6);
sj5array[0]=((((-1.0)*r01*sj1*x1137))+((r00*sj1*x1136))+(((-1.0)*cj1*r10*x1136))+((cj1*r11*x1137)));
if( sj5array[0] >= -1-IKFAST_SINCOS_THRESH && sj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKasin(sj5array[0]);
    cj5array[0] = IKcos(j5array[0]);
    sj5array[1] = sj5array[0];
    j5array[1] = j5array[0] > 0 ? (IKPI-j5array[0]) : (-IKPI-j5array[0]);
    cj5array[1] = -cj5array[0];
}
else if( isnan(sj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1138=IKcos(j5);
IkReal x1139=IKsin(j5);
IkReal x1140=((0.5)*x1139);
IkReal x1141=((0.5)*x1138);
evalcond[0]=x1141;
evalcond[1]=(r22*x1141);
evalcond[2]=(((r01*sj6*x1140))+(((0.45)*sj1))+(((-1.0)*cj6*r00*x1140)));
evalcond[3]=(((r11*sj6*x1140))+(((-0.45)*cj1))+(((-1.0)*cj6*r10*x1140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1142=(r02*sj1);
IkReal x1143=((9.0)*cj1);
CheckValue<IkReal> x1144=IKPowWithIntegerCheck(((((10.0)*r11*sj6))+(((-10.0)*cj6*r10))),-1);
if(!x1144.valid){
continue;
}
if( IKabs(((x1144.value)*((x1143+(((-1.0)*x1143*(r12*r12)))+(((9.0)*r12*x1142)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x1142))+(((0.9)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1144.value)*((x1143+(((-1.0)*x1143*(r12*r12)))+(((9.0)*r12*x1142))))))+IKsqr(((((-0.9)*x1142))+(((0.9)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1144.value)*((x1143+(((-1.0)*x1143*(r12*r12)))+(((9.0)*r12*x1142))))), ((((-0.9)*x1142))+(((0.9)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1145=IKcos(j5);
IkReal x1146=IKsin(j5);
IkReal x1147=(r01*sj6);
IkReal x1148=((0.45)*sj1);
IkReal x1149=(r11*sj6);
IkReal x1150=(cj6*r00);
IkReal x1151=(cj6*r10);
IkReal x1152=((0.45)*cj1);
IkReal x1153=((0.5)*x1146);
IkReal x1154=((0.5)*x1145);
evalcond[0]=(x1154+((r02*x1148))+(((-1.0)*r12*x1152)));
evalcond[1]=(((r22*x1154))+(((-1.0)*cj6*r20*x1153))+((r21*sj6*x1153)));
evalcond[2]=(x1148+((r02*x1154))+((x1147*x1153))+(((-1.0)*x1150*x1153)));
evalcond[3]=(((x1149*x1153))+((r12*x1154))+(((-1.0)*x1152))+(((-1.0)*x1151*x1153)));
evalcond[4]=(((x1149*x1152))+(((-1.0)*x1153))+(((-1.0)*x1147*x1148))+((x1148*x1150))+(((-1.0)*x1151*x1152)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1155=((9.0)*sj1);
IkReal x1156=(cj1*r12);
CheckValue<IkReal> x1157=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x1157.valid){
continue;
}
if( IKabs(((x1157.value)*((((x1155*(r02*r02)))+(((-1.0)*x1155))+(((-9.0)*r02*x1156)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1156))+(((-0.9)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1157.value)*((((x1155*(r02*r02)))+(((-1.0)*x1155))+(((-9.0)*r02*x1156))))))+IKsqr(((((0.9)*x1156))+(((-0.9)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1157.value)*((((x1155*(r02*r02)))+(((-1.0)*x1155))+(((-9.0)*r02*x1156))))), ((((0.9)*x1156))+(((-0.9)*r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1158=IKcos(j5);
IkReal x1159=IKsin(j5);
IkReal x1160=(r01*sj6);
IkReal x1161=((0.45)*sj1);
IkReal x1162=(r11*sj6);
IkReal x1163=(cj6*r00);
IkReal x1164=(cj6*r10);
IkReal x1165=((0.45)*cj1);
IkReal x1166=((0.5)*x1159);
IkReal x1167=((0.5)*x1158);
evalcond[0]=(x1167+((r02*x1161))+(((-1.0)*r12*x1165)));
evalcond[1]=(((r21*sj6*x1166))+(((-1.0)*cj6*r20*x1166))+((r22*x1167)));
evalcond[2]=(x1161+((r02*x1167))+(((-1.0)*x1163*x1166))+((x1160*x1166)));
evalcond[3]=(((x1162*x1166))+((r12*x1167))+(((-1.0)*x1164*x1166))+(((-1.0)*x1165)));
evalcond[4]=(((x1162*x1165))+(((-1.0)*x1164*x1165))+(((-1.0)*x1160*x1161))+(((-1.0)*x1166))+((x1161*x1163)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1168=(cj1*r12);
IkReal x1169=(r02*sj1);
IkReal x1170=((0.45)*r22);
CheckValue<IkReal> x1171=IKPowWithIntegerCheck(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))),-1);
if(!x1171.valid){
continue;
}
if( IKabs(((x1171.value)*(((((-1.0)*x1168*x1170))+((x1169*x1170)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x1169))+(((0.9)*x1168)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1171.value)*(((((-1.0)*x1168*x1170))+((x1169*x1170))))))+IKsqr(((((-0.9)*x1169))+(((0.9)*x1168))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1171.value)*(((((-1.0)*x1168*x1170))+((x1169*x1170))))), ((((-0.9)*x1169))+(((0.9)*x1168))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1172=IKcos(j5);
IkReal x1173=IKsin(j5);
IkReal x1174=(r01*sj6);
IkReal x1175=((0.45)*sj1);
IkReal x1176=(r11*sj6);
IkReal x1177=(cj6*r00);
IkReal x1178=(cj6*r10);
IkReal x1179=((0.45)*cj1);
IkReal x1180=((0.5)*x1173);
IkReal x1181=((0.5)*x1172);
evalcond[0]=(((r02*x1175))+x1181+(((-1.0)*r12*x1179)));
evalcond[1]=(((r22*x1181))+((r21*sj6*x1180))+(((-1.0)*cj6*r20*x1180)));
evalcond[2]=(x1175+((x1174*x1180))+((r02*x1181))+(((-1.0)*x1177*x1180)));
evalcond[3]=(((x1176*x1180))+(((-1.0)*x1178*x1180))+(((-1.0)*x1179))+((r12*x1181)));
evalcond[4]=((((-1.0)*x1178*x1179))+((x1176*x1179))+((x1175*x1177))+(((-1.0)*x1180))+(((-1.0)*x1174*x1175)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1183 = IKatan2WithCheck(IkReal(((0.5)*r22)),IkReal(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1183.valid){
continue;
}
IkReal x1182=x1183.value;
j5array[0]=((-1.0)*x1182);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1182)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1184=(r21*sj6);
IkReal x1185=(cj6*r20);
IkReal x1186=((1.0)*cj5*sj6);
IkReal x1187=((1.0)*cj5*cj6);
j1eval[0]=(x1184+(((-1.0)*x1185)));
j1eval[1]=((IKabs(((((-1.0)*r11*x1187))+(((-1.0)*r10*x1186)))))+(IKabs(((((-1.0)*r01*x1187))+(((-1.0)*r00*x1186))))));
j1eval[2]=IKsign(((((4.05)*x1184))+(((-4.05)*x1185))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1188=((9.0)*cj5);
IkReal x1189=(r20*sj6);
IkReal x1190=((9.0)*sj5);
IkReal x1191=(cj6*r21);
j1eval[0]=((((-1.0)*x1189))+(((-1.0)*x1191)));
j1eval[1]=((IKabs((((cj6*r10*x1188))+((r12*x1190))+(((-1.0)*r11*sj6*x1188)))))+(IKabs(((((-1.0)*r01*sj6*x1188))+((r02*x1190))+((cj6*r00*x1188))))));
j1eval[2]=IKsign(((((-8.1)*x1191))+(((-8.1)*x1189))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j1eval[0]=r12;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1192=((1.11111111111111)*cj6);
IkReal x1193=((1.11111111111111)*sj6);
if( IKabs((((r00*x1192))+(((-1.0)*r01*x1193)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r10*x1192))+((r11*x1193)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*x1192))+(((-1.0)*r01*x1193))))+IKsqr(((((-1.0)*r10*x1192))+((r11*x1193))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r00*x1192))+(((-1.0)*r01*x1193))), ((((-1.0)*r10*x1192))+((r11*x1193))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1194=IKsin(j1);
IkReal x1195=IKcos(j1);
IkReal x1196=((0.5)*sj6);
IkReal x1197=(cj6*r00);
IkReal x1198=(cj6*r10);
IkReal x1199=((0.45)*x1195);
IkReal x1200=((0.45)*x1194);
evalcond[0]=(((r02*x1200))+(((-1.0)*r12*x1199)));
evalcond[1]=(x1200+((r01*x1196))+(((-0.5)*x1197)));
evalcond[2]=((((-0.5)*x1198))+(((-1.0)*x1199))+((r11*x1196)));
evalcond[3]=((((-1.0)*cj6*r11*x1199))+(((-1.0)*r10*sj6*x1199))+((r00*sj6*x1200))+((cj6*r01*x1200)));
evalcond[4]=((-0.5)+(((-1.0)*x1198*x1199))+((x1197*x1200))+((r11*sj6*x1199))+(((-1.0)*r01*sj6*x1200)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1201=((1.11111111111111)*cj6);
IkReal x1202=((1.11111111111111)*sj6);
if( IKabs(((((-1.0)*r00*x1201))+((r01*x1202)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r10*x1201))+(((-1.0)*r11*x1202)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*x1201))+((r01*x1202))))+IKsqr((((r10*x1201))+(((-1.0)*r11*x1202))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r00*x1201))+((r01*x1202))), (((r10*x1201))+(((-1.0)*r11*x1202))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1203=IKsin(j1);
IkReal x1204=IKcos(j1);
IkReal x1205=((0.5)*sj6);
IkReal x1206=(cj6*r00);
IkReal x1207=(cj6*r10);
IkReal x1208=((0.45)*x1204);
IkReal x1209=((0.45)*x1203);
evalcond[0]=((((-1.0)*r12*x1208))+((r02*x1209)));
evalcond[1]=(x1209+(((-1.0)*r01*x1205))+(((0.5)*x1206)));
evalcond[2]=((((-1.0)*r11*x1205))+(((-1.0)*x1208))+(((0.5)*x1207)));
evalcond[3]=((((-1.0)*cj6*r11*x1208))+(((-1.0)*r10*sj6*x1208))+((r00*sj6*x1209))+((cj6*r01*x1209)));
evalcond[4]=((0.5)+((r11*sj6*x1208))+((x1206*x1209))+(((-1.0)*x1207*x1208))+(((-1.0)*r01*sj6*x1209)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1210=((1.11111111111111)*sj5*sj6);
IkReal x1211=((1.11111111111111)*cj6*sj5);
if( IKabs((((r00*x1211))+(((-1.0)*r01*x1210)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r11*x1210))+(((-1.0)*r10*x1211)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*x1211))+(((-1.0)*r01*x1210))))+IKsqr((((r11*x1210))+(((-1.0)*r10*x1211))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r00*x1211))+(((-1.0)*r01*x1210))), (((r11*x1210))+(((-1.0)*r10*x1211))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1212=IKsin(j1);
IkReal x1213=IKcos(j1);
IkReal x1214=(r01*sj6);
IkReal x1215=(cj6*r00);
IkReal x1216=((0.5)*sj5);
IkReal x1217=(cj6*r10);
IkReal x1218=(r11*sj6);
IkReal x1219=((0.45)*x1213);
IkReal x1220=((0.45)*x1212);
evalcond[0]=(((x1214*x1216))+x1220+(((-1.0)*x1215*x1216)));
evalcond[1]=((((-1.0)*x1216*x1217))+((x1216*x1218))+(((-1.0)*x1219)));
evalcond[2]=(((r00*sj6*x1220))+(((-1.0)*cj6*r11*x1219))+((cj6*r01*x1220))+(((-1.0)*r10*sj6*x1219)));
evalcond[3]=(((x1218*x1219))+(((-1.0)*x1214*x1220))+(((-1.0)*x1217*x1219))+(((-1.0)*x1216))+((x1215*x1220)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1221=(cj6*r00);
IkReal x1222=((10.0)*cj5);
IkReal x1223=(r01*sj6);
IkReal x1224=((1.11111111111111)*sj5);
IkReal x1225=((10.0)*r02*sj5);
CheckValue<IkReal> x1226=IKPowWithIntegerCheck(r12,-1);
if(!x1226.valid){
continue;
}
if( IKabs(((((-1.11111111111111)*cj5*r02))+((x1221*x1224))+(((-1.0)*x1223*x1224)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.111111111111111)*(x1226.value)*((x1222+(((-1.0)*x1222*(r02*r02)))+((x1221*x1225))+(((-1.0)*x1223*x1225)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.11111111111111)*cj5*r02))+((x1221*x1224))+(((-1.0)*x1223*x1224))))+IKsqr(((0.111111111111111)*(x1226.value)*((x1222+(((-1.0)*x1222*(r02*r02)))+((x1221*x1225))+(((-1.0)*x1223*x1225))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.11111111111111)*cj5*r02))+((x1221*x1224))+(((-1.0)*x1223*x1224))), ((0.111111111111111)*(x1226.value)*((x1222+(((-1.0)*x1222*(r02*r02)))+((x1221*x1225))+(((-1.0)*x1223*x1225))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1227=IKsin(j1);
IkReal x1228=IKcos(j1);
IkReal x1229=(r01*sj6);
IkReal x1230=(cj6*r00);
IkReal x1231=((0.5)*sj5);
IkReal x1232=(cj6*r10);
IkReal x1233=(r11*sj6);
IkReal x1234=((0.5)*cj5);
IkReal x1235=((0.45)*x1228);
IkReal x1236=((0.45)*x1227);
evalcond[0]=(x1234+(((-1.0)*r12*x1235))+((r02*x1236)));
evalcond[1]=(x1236+(((-1.0)*x1230*x1231))+((r02*x1234))+((x1229*x1231)));
evalcond[2]=((((-1.0)*x1235))+((x1231*x1233))+(((-1.0)*x1231*x1232))+((r12*x1234)));
evalcond[3]=((((-1.0)*r10*sj6*x1235))+(((-1.0)*cj6*r11*x1235))+((r00*sj6*x1236))+((cj6*r01*x1236)));
evalcond[4]=((((-1.0)*x1231))+((x1233*x1235))+(((-1.0)*x1229*x1236))+((x1230*x1236))+(((-1.0)*x1232*x1235)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1237=((9.0)*sj5);
IkReal x1238=((9.0)*cj5*cj6);
IkReal x1239=((9.0)*cj5*sj6);
CheckValue<IkReal> x1240 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1239))+((r10*x1238))+((r12*x1237)))),IkReal((((r00*x1238))+(((-1.0)*r01*x1239))+((r02*x1237)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1240.valid){
continue;
}
CheckValue<IkReal> x1241=IKPowWithIntegerCheck(IKsign(((((-8.1)*cj6*r21))+(((-8.1)*r20*sj6)))),-1);
if(!x1241.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1240.value)+(((1.5707963267949)*(x1241.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1242=IKsin(j1);
IkReal x1243=IKcos(j1);
IkReal x1244=(r01*sj6);
IkReal x1245=(cj6*r00);
IkReal x1246=((0.5)*sj5);
IkReal x1247=(cj6*r10);
IkReal x1248=(r11*sj6);
IkReal x1249=((0.5)*cj5);
IkReal x1250=((0.45)*x1243);
IkReal x1251=((0.45)*x1242);
evalcond[0]=((((-1.0)*r12*x1250))+x1249+((r02*x1251)));
evalcond[1]=(x1251+(((-1.0)*x1245*x1246))+((r02*x1249))+((x1244*x1246)));
evalcond[2]=((((-1.0)*x1250))+((x1246*x1248))+((r12*x1249))+(((-1.0)*x1246*x1247)));
evalcond[3]=(((r00*sj6*x1251))+(((-1.0)*cj6*r11*x1250))+(((-1.0)*r10*sj6*x1250))+((cj6*r01*x1251)));
evalcond[4]=(((x1245*x1251))+(((-1.0)*x1247*x1250))+(((-1.0)*x1246))+(((-1.0)*x1244*x1251))+((x1248*x1250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1252=((4.5)*cj5*sj6);
IkReal x1253=((4.5)*cj5*cj6);
CheckValue<IkReal> x1254 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1253))+(((-1.0)*r10*x1252)))),IkReal(((((-1.0)*r00*x1252))+(((-1.0)*r01*x1253)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1254.valid){
continue;
}
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(IKsign(((((-4.05)*cj6*r20))+(((4.05)*r21*sj6)))),-1);
if(!x1255.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1254.value)+(((1.5707963267949)*(x1255.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1256=IKsin(j1);
IkReal x1257=IKcos(j1);
IkReal x1258=(r01*sj6);
IkReal x1259=(cj6*r00);
IkReal x1260=((0.5)*sj5);
IkReal x1261=(cj6*r10);
IkReal x1262=(r11*sj6);
IkReal x1263=((0.5)*cj5);
IkReal x1264=((0.45)*x1257);
IkReal x1265=((0.45)*x1256);
evalcond[0]=((((-1.0)*r12*x1264))+x1263+((r02*x1265)));
evalcond[1]=(x1265+((x1258*x1260))+((r02*x1263))+(((-1.0)*x1259*x1260)));
evalcond[2]=((((-1.0)*x1260*x1261))+((r12*x1263))+((x1260*x1262))+(((-1.0)*x1264)));
evalcond[3]=(((r00*sj6*x1265))+(((-1.0)*r10*sj6*x1264))+(((-1.0)*cj6*r11*x1264))+((cj6*r01*x1265)));
evalcond[4]=((((-1.0)*x1258*x1265))+(((-1.0)*x1261*x1264))+((x1259*x1265))+((x1262*x1264))+(((-1.0)*x1260)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1266=((0.45)*cj6);
IkReal x1267=((1.0)*pz);
IkReal x1268=((0.45)*sj6);
IkReal x1269=((((-1.0)*r10*x1268))+(((-1.0)*r11*x1266)));
IkReal x1270=(((r00*x1268))+((r01*x1266)));
CheckValue<IkReal> x1273 = IKatan2WithCheck(IkReal(x1269),IkReal(x1270),IKFAST_ATAN2_MAGTHRESH);
if(!x1273.valid){
continue;
}
IkReal x1271=((1.0)*(x1273.value));
if((((x1270*x1270)+(x1269*x1269))) < -0.00001)
continue;
CheckValue<IkReal> x1274=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1270*x1270)+(x1269*x1269)))),-1);
if(!x1274.valid){
continue;
}
if( (((-1.0)*(x1274.value)*(((((-1.0)*r20*sj6*x1267))+(((-1.0)*cj6*r21*x1267)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1274.value)*(((((-1.0)*r20*sj6*x1267))+(((-1.0)*cj6*r21*x1267)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1272=((-1.0)*(IKasin(((-1.0)*(x1274.value)*(((((-1.0)*r20*sj6*x1267))+(((-1.0)*cj6*r21*x1267))))))));
j1array[0]=((((-1.0)*x1271))+(((-1.0)*x1272)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1271))+(((1.0)*x1272)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
IkReal x1275=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1275);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1275);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1275);
rxp2_2=0;
j5eval[0]=((((-1.0)*cj6*r20))+((r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1276=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1276);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1276);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1276);
rxp2_2=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1277=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1277);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1277);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1277);
rxp2_2=0;
j5eval[0]=((((-1.0)*cj6*r10))+((r11*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x1279 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1279)==0){
continue;
}
IkReal x1278=pow(x1279,-0.5);
CheckValue<IkReal> x1280 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1280.valid){
continue;
}
IkReal gconst56=((-1.0)*(x1280.value));
IkReal gconst57=(r10*x1278);
IkReal gconst58=(r11*x1278);
CheckValue<IkReal> x1281 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1281.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1281.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1282=(cj1*r12);
IkReal x1283=(r02*sj1);
IkReal x1284=((0.45)*r22);
CheckValue<IkReal> x1285=IKPowWithIntegerCheck(((((0.5)*gconst57*r21))+(((-0.5)*gconst58*r20))),-1);
if(!x1285.valid){
continue;
}
if( IKabs(((x1285.value)*(((((-1.0)*pz*(r22*r22)))+((x1283*x1284))+pz+(((-1.0)*x1282*x1284)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1282))+(((2.0)*pz*r22))+(((-0.9)*x1283)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1285.value)*(((((-1.0)*pz*(r22*r22)))+((x1283*x1284))+pz+(((-1.0)*x1282*x1284))))))+IKsqr(((((0.9)*x1282))+(((2.0)*pz*r22))+(((-0.9)*x1283))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1285.value)*(((((-1.0)*pz*(r22*r22)))+((x1283*x1284))+pz+(((-1.0)*x1282*x1284))))), ((((0.9)*x1282))+(((2.0)*pz*r22))+(((-0.9)*x1283))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1286=IKcos(j5);
IkReal x1287=IKsin(j5);
IkReal x1288=(gconst58*r10);
IkReal x1289=(pz*r22);
IkReal x1290=((0.45)*cj1);
IkReal x1291=(gconst57*r01);
IkReal x1292=((1.0)*pz);
IkReal x1293=(gconst57*r11);
IkReal x1294=((0.45)*sj1);
IkReal x1295=(gconst58*r20);
IkReal x1296=(gconst58*r00);
IkReal x1297=((0.5)*x1286);
IkReal x1298=((0.5)*x1287);
IkReal x1299=(gconst57*pz*r21);
evalcond[0]=((((-1.0)*x1289))+x1297+(((-1.0)*r12*x1290))+((r02*x1294)));
evalcond[1]=((-0.095)+((x1287*x1299))+(((-1.0)*x1287*x1292*x1295))+((x1286*x1289)));
evalcond[2]=((((-1.0)*x1292))+(((-1.0)*x1295*x1298))+((r22*x1297))+((gconst57*r21*x1298)));
evalcond[3]=(x1294+((x1291*x1298))+((r02*x1297))+(((-1.0)*x1296*x1298)));
evalcond[4]=((((-1.0)*x1290))+(((-1.0)*x1288*x1298))+((r12*x1297))+((x1293*x1298)));
evalcond[5]=(x1299+(((-1.0)*x1298))+(((-1.0)*x1288*x1290))+((x1294*x1296))+((x1290*x1293))+(((-1.0)*x1292*x1295))+(((-1.0)*x1291*x1294)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1302 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1302)==0){
continue;
}
IkReal x1300=pow(x1302,-0.5);
IkReal x1301=((-1.0)*x1300);
CheckValue<IkReal> x1303 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1303.valid){
continue;
}
IkReal gconst59=((3.14159265358979)+(((-1.0)*(x1303.value))));
IkReal gconst60=(r10*x1301);
IkReal gconst61=(r11*x1301);
CheckValue<IkReal> x1304 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1304.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1304.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1305=(cj1*r12);
IkReal x1306=(r02*sj1);
IkReal x1307=((0.45)*r22);
CheckValue<IkReal> x1308=IKPowWithIntegerCheck(((((0.5)*gconst60*r21))+(((-0.5)*gconst61*r20))),-1);
if(!x1308.valid){
continue;
}
if( IKabs(((x1308.value)*((((x1306*x1307))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1305*x1307)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1305))+(((-0.9)*x1306))+(((2.0)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1308.value)*((((x1306*x1307))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1305*x1307))))))+IKsqr(((((0.9)*x1305))+(((-0.9)*x1306))+(((2.0)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1308.value)*((((x1306*x1307))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1305*x1307))))), ((((0.9)*x1305))+(((-0.9)*x1306))+(((2.0)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1309=IKcos(j5);
IkReal x1310=IKsin(j5);
IkReal x1311=((0.45)*cj1);
IkReal x1312=(gconst60*r11);
IkReal x1313=(gconst61*r20);
IkReal x1314=(gconst60*r21);
IkReal x1315=(gconst61*r10);
IkReal x1316=(pz*r22);
IkReal x1317=((0.45)*sj1);
IkReal x1318=(gconst61*r00);
IkReal x1319=((1.0)*pz);
IkReal x1320=(gconst60*r01);
IkReal x1321=((0.5)*x1310);
IkReal x1322=((0.5)*x1309);
evalcond[0]=(x1322+(((-1.0)*x1316))+(((-1.0)*r12*x1311))+((r02*x1317)));
evalcond[1]=((-0.095)+((pz*x1310*x1314))+((x1309*x1316))+(((-1.0)*x1310*x1313*x1319)));
evalcond[2]=(((x1314*x1321))+(((-1.0)*x1313*x1321))+(((-1.0)*x1319))+((r22*x1322)));
evalcond[3]=(x1317+((x1320*x1321))+((r02*x1322))+(((-1.0)*x1318*x1321)));
evalcond[4]=(((x1312*x1321))+(((-1.0)*x1315*x1321))+(((-1.0)*x1311))+((r12*x1322)));
evalcond[5]=((((-1.0)*x1311*x1315))+((x1317*x1318))+((pz*x1314))+((x1311*x1312))+(((-1.0)*x1313*x1319))+(((-1.0)*x1321))+(((-1.0)*x1317*x1320)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1324 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1324)==0){
continue;
}
IkReal x1323=pow(x1324,-0.5);
CheckValue<IkReal> x1325 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1325.valid){
continue;
}
IkReal gconst62=((-1.0)*(x1325.value));
IkReal gconst63=(r00*x1323);
IkReal gconst64=(r01*x1323);
CheckValue<IkReal> x1326 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1326.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1326.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1327=(cj1*r12);
IkReal x1328=(r02*sj1);
IkReal x1329=((0.45)*r22);
CheckValue<IkReal> x1330=IKPowWithIntegerCheck(((((0.5)*gconst63*r21))+(((-0.5)*gconst64*r20))),-1);
if(!x1330.valid){
continue;
}
if( IKabs(((x1330.value)*(((((-1.0)*x1327*x1329))+(((-1.0)*pz*(r22*r22)))+((x1328*x1329))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x1328))+(((0.9)*x1327))+(((2.0)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1330.value)*(((((-1.0)*x1327*x1329))+(((-1.0)*pz*(r22*r22)))+((x1328*x1329))+pz))))+IKsqr(((((-0.9)*x1328))+(((0.9)*x1327))+(((2.0)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1330.value)*(((((-1.0)*x1327*x1329))+(((-1.0)*pz*(r22*r22)))+((x1328*x1329))+pz))), ((((-0.9)*x1328))+(((0.9)*x1327))+(((2.0)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1331=IKcos(j5);
IkReal x1332=IKsin(j5);
IkReal x1333=(gconst64*r00);
IkReal x1334=(pz*r22);
IkReal x1335=(gconst63*r21);
IkReal x1336=(gconst63*r11);
IkReal x1337=((0.45)*sj1);
IkReal x1338=(gconst63*r01);
IkReal x1339=(gconst64*r10);
IkReal x1340=((0.45)*cj1);
IkReal x1341=((0.5)*x1332);
IkReal x1342=((0.5)*x1331);
IkReal x1343=(pz*x1332);
IkReal x1344=((1.0)*gconst64*r20);
evalcond[0]=(x1342+(((-1.0)*x1334))+(((-1.0)*r12*x1340))+((r02*x1337)));
evalcond[1]=((-0.095)+((x1331*x1334))+((x1335*x1343))+(((-1.0)*x1343*x1344)));
evalcond[2]=(((r22*x1342))+(((-1.0)*gconst64*r20*x1341))+(((-1.0)*pz))+((x1335*x1341)));
evalcond[3]=(x1337+((r02*x1342))+((x1338*x1341))+(((-1.0)*x1333*x1341)));
evalcond[4]=((((-1.0)*x1340))+(((-1.0)*x1339*x1341))+((r12*x1342))+((x1336*x1341)));
evalcond[5]=((((-1.0)*pz*x1344))+(((-1.0)*x1341))+((pz*x1335))+(((-1.0)*x1337*x1338))+(((-1.0)*x1339*x1340))+((x1336*x1340))+((x1333*x1337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1345=((-1.0)*r00);
IkReal x1347 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1347)==0){
continue;
}
IkReal x1346=pow(x1347,-0.5);
CheckValue<IkReal> x1348 = IKatan2WithCheck(IkReal(x1345),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1348.valid){
continue;
}
IkReal gconst65=((3.14159265358979)+(((-1.0)*(x1348.value))));
IkReal gconst66=(x1345*x1346);
IkReal gconst67=((-1.0)*r01*x1346);
CheckValue<IkReal> x1349 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1349.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1349.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1350=(cj1*r12);
IkReal x1351=(r02*sj1);
IkReal x1352=((0.45)*r22);
CheckValue<IkReal> x1353=IKPowWithIntegerCheck(((((-0.5)*gconst67*r20))+(((0.5)*gconst66*r21))),-1);
if(!x1353.valid){
continue;
}
if( IKabs(((x1353.value)*(((((-1.0)*x1350*x1352))+(((-1.0)*pz*(r22*r22)))+pz+((x1351*x1352)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1350))+(((-0.9)*x1351))+(((2.0)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1353.value)*(((((-1.0)*x1350*x1352))+(((-1.0)*pz*(r22*r22)))+pz+((x1351*x1352))))))+IKsqr(((((0.9)*x1350))+(((-0.9)*x1351))+(((2.0)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1353.value)*(((((-1.0)*x1350*x1352))+(((-1.0)*pz*(r22*r22)))+pz+((x1351*x1352))))), ((((0.9)*x1350))+(((-0.9)*x1351))+(((2.0)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1354=IKcos(j5);
IkReal x1355=IKsin(j5);
IkReal x1356=(gconst67*r20);
IkReal x1357=((1.0)*pz);
IkReal x1358=(gconst67*r00);
IkReal x1359=((0.45)*sj1);
IkReal x1360=(gconst66*r11);
IkReal x1361=((0.45)*cj1);
IkReal x1362=(gconst67*r10);
IkReal x1363=(gconst66*r01);
IkReal x1364=((0.5)*x1355);
IkReal x1365=((0.5)*x1354);
IkReal x1366=(gconst66*pz*r21);
evalcond[0]=(x1365+(((-1.0)*r12*x1361))+((r02*x1359))+(((-1.0)*r22*x1357)));
evalcond[1]=((-0.095)+((x1355*x1366))+(((-1.0)*x1355*x1356*x1357))+((pz*r22*x1354)));
evalcond[2]=((((-1.0)*x1357))+((gconst66*r21*x1364))+((r22*x1365))+(((-1.0)*x1356*x1364)));
evalcond[3]=(x1359+((x1363*x1364))+((r02*x1365))+(((-1.0)*x1358*x1364)));
evalcond[4]=(((x1360*x1364))+(((-1.0)*x1362*x1364))+((r12*x1365))+(((-1.0)*x1361)));
evalcond[5]=(x1366+((x1360*x1361))+((x1358*x1359))+(((-1.0)*x1359*x1363))+(((-1.0)*x1356*x1357))+(((-1.0)*x1361*x1362))+(((-1.0)*x1364)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1368 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1368)==0){
continue;
}
IkReal x1367=pow(x1368,-0.5);
CheckValue<IkReal> x1369 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1369.valid){
continue;
}
IkReal gconst68=((-1.0)*(x1369.value));
IkReal gconst69=(r20*x1367);
IkReal gconst70=(r21*x1367);
CheckValue<IkReal> x1370 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1370.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1370.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1371=((9.0)*sj1);
IkReal x1372=(pz*r22);
IkReal x1373=(cj1*r12);
CheckValue<IkReal> x1374=IKPowWithIntegerCheck(((((10.0)*gconst69*r01))+(((-10.0)*gconst70*r00))),-1);
if(!x1374.valid){
continue;
}
if( IKabs(((x1374.value)*(((((-1.0)*x1371))+(((-20.0)*r02*x1372))+(((-9.0)*r02*x1373))+((x1371*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1373))+(((2.0)*x1372))+(((-0.9)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1374.value)*(((((-1.0)*x1371))+(((-20.0)*r02*x1372))+(((-9.0)*r02*x1373))+((x1371*(r02*r02)))))))+IKsqr(((((0.9)*x1373))+(((2.0)*x1372))+(((-0.9)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1374.value)*(((((-1.0)*x1371))+(((-20.0)*r02*x1372))+(((-9.0)*r02*x1373))+((x1371*(r02*r02)))))), ((((0.9)*x1373))+(((2.0)*x1372))+(((-0.9)*r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1375=IKcos(j5);
IkReal x1376=IKsin(j5);
IkReal x1377=((1.0)*pz);
IkReal x1378=(gconst70*r20);
IkReal x1379=((0.45)*sj1);
IkReal x1380=(gconst69*r01);
IkReal x1381=((0.45)*cj1);
IkReal x1382=(gconst70*r00);
IkReal x1383=(gconst70*r10);
IkReal x1384=(gconst69*r21);
IkReal x1385=(gconst69*r11);
IkReal x1386=((0.5)*x1375);
IkReal x1387=((0.5)*x1376);
evalcond[0]=((((-1.0)*r12*x1381))+x1386+(((-1.0)*r22*x1377))+((r02*x1379)));
evalcond[1]=((-0.095)+((pz*x1376*x1384))+(((-1.0)*x1376*x1377*x1378))+((pz*r22*x1375)));
evalcond[2]=((((-1.0)*x1377))+((r22*x1386))+((x1384*x1387))+(((-1.0)*x1378*x1387)));
evalcond[3]=(x1379+((x1380*x1387))+(((-1.0)*x1382*x1387))+((r02*x1386)));
evalcond[4]=((((-1.0)*x1381))+(((-1.0)*x1383*x1387))+((x1385*x1387))+((r12*x1386)));
evalcond[5]=((((-1.0)*x1387))+((x1381*x1385))+((pz*x1384))+(((-1.0)*x1377*x1378))+(((-1.0)*x1381*x1383))+((x1379*x1382))+(((-1.0)*x1379*x1380)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1390 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1390)==0){
continue;
}
IkReal x1388=pow(x1390,-0.5);
IkReal x1389=((-1.0)*x1388);
CheckValue<IkReal> x1391 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1391.valid){
continue;
}
IkReal gconst71=((3.14159265358979)+(((-1.0)*(x1391.value))));
IkReal gconst72=(r20*x1389);
IkReal gconst73=(r21*x1389);
CheckValue<IkReal> x1392 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1392.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1392.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1393=((9.0)*sj1);
IkReal x1394=(pz*r22);
IkReal x1395=(cj1*r12);
CheckValue<IkReal> x1396=IKPowWithIntegerCheck(((((10.0)*gconst72*r01))+(((-10.0)*gconst73*r00))),-1);
if(!x1396.valid){
continue;
}
if( IKabs(((x1396.value)*((((x1393*(r02*r02)))+(((-20.0)*r02*x1394))+(((-1.0)*x1393))+(((-9.0)*r02*x1395)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1395))+(((2.0)*x1394))+(((-0.9)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1396.value)*((((x1393*(r02*r02)))+(((-20.0)*r02*x1394))+(((-1.0)*x1393))+(((-9.0)*r02*x1395))))))+IKsqr(((((0.9)*x1395))+(((2.0)*x1394))+(((-0.9)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1396.value)*((((x1393*(r02*r02)))+(((-20.0)*r02*x1394))+(((-1.0)*x1393))+(((-9.0)*r02*x1395))))), ((((0.9)*x1395))+(((2.0)*x1394))+(((-0.9)*r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1397=IKcos(j5);
IkReal x1398=IKsin(j5);
IkReal x1399=((0.45)*cj1);
IkReal x1400=(gconst72*r11);
IkReal x1401=(pz*r22);
IkReal x1402=((1.0)*pz);
IkReal x1403=((0.45)*sj1);
IkReal x1404=(gconst72*r01);
IkReal x1405=((0.5)*x1397);
IkReal x1406=(gconst73*x1398);
IkReal x1407=(gconst72*pz*r21);
IkReal x1408=((0.5)*x1398);
evalcond[0]=((((-1.0)*x1401))+(((-1.0)*r12*x1399))+((r02*x1403))+x1405);
evalcond[1]=((-0.095)+((x1397*x1401))+(((-1.0)*r20*x1402*x1406))+((x1398*x1407)));
evalcond[2]=((((-1.0)*x1402))+(((-0.5)*r20*x1406))+((r22*x1405))+((gconst72*r21*x1408)));
evalcond[3]=(((r02*x1405))+((x1404*x1408))+x1403+(((-0.5)*r00*x1406)));
evalcond[4]=(((r12*x1405))+((x1400*x1408))+(((-0.5)*r10*x1406))+(((-1.0)*x1399)));
evalcond[5]=((((-1.0)*gconst73*r20*x1402))+((gconst73*r00*x1403))+(((-1.0)*x1408))+((x1399*x1400))+x1407+(((-1.0)*x1403*x1404))+(((-1.0)*gconst73*r10*x1399)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1409=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1409);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1409);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1410=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1410);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1410);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*cj6*r10))+((r11*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x1411=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1411);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1411);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=(((r01*sj6))+(((-1.0)*cj6*r00)));
j5eval[1]=pz;
j5eval[2]=r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1412=((0.9)*cj6);
IkReal x1413=((0.9)*sj6);
sj5array[0]=((((-1.0)*r01*sj1*x1413))+(((-1.0)*cj1*r10*x1412))+((cj1*r11*x1413))+((r00*sj1*x1412)));
if( sj5array[0] >= -1-IKFAST_SINCOS_THRESH && sj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKasin(sj5array[0]);
    cj5array[0] = IKcos(j5array[0]);
    sj5array[1] = sj5array[0];
    j5array[1] = j5array[0] > 0 ? (IKPI-j5array[0]) : (-IKPI-j5array[0]);
    cj5array[1] = -cj5array[0];
}
else if( isnan(sj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1414=IKcos(j5);
IkReal x1415=IKsin(j5);
IkReal x1416=((0.5)*x1415);
IkReal x1417=((0.5)*x1414);
evalcond[0]=x1417;
evalcond[1]=(r22*x1417);
evalcond[2]=(((r01*sj6*x1416))+(((0.45)*sj1))+(((-1.0)*cj6*r00*x1416)));
evalcond[3]=(((r11*sj6*x1416))+(((-1.0)*cj6*r10*x1416))+(((-0.45)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1418=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x1418.valid){
continue;
}
CheckValue<IkReal> x1419=IKPowWithIntegerCheck(pz,-1);
if(!x1419.valid){
continue;
}
CheckValue<IkReal> x1420=IKPowWithIntegerCheck(r22,-1);
if(!x1420.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1418.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.095)*(x1419.value)*(x1420.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1418.value)))+IKsqr(((0.095)*(x1419.value)*(x1420.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1418.value)), ((0.095)*(x1419.value)*(x1420.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1421=IKcos(j5);
IkReal x1422=IKsin(j5);
IkReal x1423=((0.45)*cj1);
IkReal x1424=(cj6*r10);
IkReal x1425=(r01*sj6);
IkReal x1426=((1.0)*pz);
IkReal x1427=(r11*sj6);
IkReal x1428=(cj6*r00);
IkReal x1429=((0.45)*sj1);
IkReal x1430=((0.5)*x1422);
IkReal x1431=((0.5)*x1421);
evalcond[0]=((-0.095)+((pz*r22*x1421)));
evalcond[1]=(x1431+(((-1.0)*r22*x1426)));
evalcond[2]=(((r22*x1431))+(((-1.0)*x1426)));
evalcond[3]=((((-1.0)*x1428*x1430))+((x1425*x1430))+x1429);
evalcond[4]=(((x1427*x1430))+(((-1.0)*x1424*x1430))+(((-1.0)*x1423)));
evalcond[5]=(((x1423*x1427))+(((-1.0)*x1425*x1429))+(((-1.0)*x1423*x1424))+(((-1.0)*x1430))+((x1428*x1429)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1432=IKPowWithIntegerCheck(((((10.0)*r11*sj6))+(((-10.0)*cj6*r10))),-1);
if(!x1432.valid){
continue;
}
if( IKabs(((9.0)*cj1*(x1432.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.0)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((9.0)*cj1*(x1432.value)))+IKsqr(((2.0)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((9.0)*cj1*(x1432.value)), ((2.0)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1433=IKcos(j5);
IkReal x1434=IKsin(j5);
IkReal x1435=((0.45)*cj1);
IkReal x1436=(cj6*r10);
IkReal x1437=(r01*sj6);
IkReal x1438=((1.0)*pz);
IkReal x1439=(r11*sj6);
IkReal x1440=(cj6*r00);
IkReal x1441=((0.45)*sj1);
IkReal x1442=((0.5)*x1434);
IkReal x1443=((0.5)*x1433);
evalcond[0]=((-0.095)+((pz*r22*x1433)));
evalcond[1]=((((-1.0)*r22*x1438))+x1443);
evalcond[2]=(((r22*x1443))+(((-1.0)*x1438)));
evalcond[3]=(((x1437*x1442))+x1441+(((-1.0)*x1440*x1442)));
evalcond[4]=(((x1439*x1442))+(((-1.0)*x1435))+(((-1.0)*x1436*x1442)));
evalcond[5]=((((-1.0)*x1435*x1436))+((x1440*x1441))+((x1435*x1439))+(((-1.0)*x1437*x1441))+(((-1.0)*x1442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1444=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x1444.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1444.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.0)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1444.value)))+IKsqr(((2.0)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1444.value)), ((2.0)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1445=IKcos(j5);
IkReal x1446=IKsin(j5);
IkReal x1447=((0.45)*cj1);
IkReal x1448=(cj6*r10);
IkReal x1449=(r01*sj6);
IkReal x1450=((1.0)*pz);
IkReal x1451=(r11*sj6);
IkReal x1452=(cj6*r00);
IkReal x1453=((0.45)*sj1);
IkReal x1454=((0.5)*x1446);
IkReal x1455=((0.5)*x1445);
evalcond[0]=((-0.095)+((pz*r22*x1445)));
evalcond[1]=((((-1.0)*r22*x1450))+x1455);
evalcond[2]=((((-1.0)*x1450))+((r22*x1455)));
evalcond[3]=(x1453+(((-1.0)*x1452*x1454))+((x1449*x1454)));
evalcond[4]=((((-1.0)*x1448*x1454))+(((-1.0)*x1447))+((x1451*x1454)));
evalcond[5]=(((x1447*x1451))+(((-1.0)*x1454))+(((-1.0)*x1447*x1448))+(((-1.0)*x1449*x1453))+((x1452*x1453)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1456=(pz*r22);
IkReal x1457=(r02*sj1);
IkReal x1458=((9.0)*cj1);
CheckValue<IkReal> x1459=IKPowWithIntegerCheck(((((10.0)*r11*sj6))+(((-10.0)*cj6*r10))),-1);
if(!x1459.valid){
continue;
}
if( IKabs(((x1459.value)*(((((-1.0)*x1458*(r12*r12)))+x1458+(((-20.0)*r12*x1456))+(((9.0)*r12*x1457)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.9)*x1457))+(((2.0)*x1456))+(((0.9)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1459.value)*(((((-1.0)*x1458*(r12*r12)))+x1458+(((-20.0)*r12*x1456))+(((9.0)*r12*x1457))))))+IKsqr(((((-0.9)*x1457))+(((2.0)*x1456))+(((0.9)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1459.value)*(((((-1.0)*x1458*(r12*r12)))+x1458+(((-20.0)*r12*x1456))+(((9.0)*r12*x1457))))), ((((-0.9)*x1457))+(((2.0)*x1456))+(((0.9)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1460=IKcos(j5);
IkReal x1461=IKsin(j5);
IkReal x1462=((0.45)*sj6);
IkReal x1463=(pz*r22);
IkReal x1464=((0.45)*cj1);
IkReal x1465=((0.45)*sj1);
IkReal x1466=((0.5)*x1460);
IkReal x1467=(cj6*x1461);
IkReal x1468=((1.0)*pz*r20);
IkReal x1469=(pz*r21*sj6);
IkReal x1470=((0.5)*sj6*x1461);
evalcond[0]=(x1466+((r02*x1465))+(((-1.0)*r12*x1464))+(((-1.0)*x1463)));
evalcond[1]=((-0.095)+(((-1.0)*x1467*x1468))+((x1461*x1469))+((x1460*x1463)));
evalcond[2]=((((-0.5)*r20*x1467))+((r21*x1470))+(((-1.0)*pz))+((r22*x1466)));
evalcond[3]=((((-0.5)*r00*x1467))+x1465+((r01*x1470))+((r02*x1466)));
evalcond[4]=((((-0.5)*r10*x1467))+((r11*x1470))+(((-1.0)*x1464))+((r12*x1466)));
evalcond[5]=(((cj1*r11*x1462))+(((-0.5)*x1461))+(((-1.0)*cj6*x1468))+(((-1.0)*r01*sj1*x1462))+((cj6*r00*x1465))+x1469+(((-1.0)*cj6*r10*x1464)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1471=((9.0)*sj1);
IkReal x1472=(pz*r22);
IkReal x1473=(cj1*r12);
CheckValue<IkReal> x1474=IKPowWithIntegerCheck(((((10.0)*r01*sj6))+(((-10.0)*cj6*r00))),-1);
if(!x1474.valid){
continue;
}
if( IKabs(((x1474.value)*(((((-9.0)*r02*x1473))+(((-20.0)*r02*x1472))+(((-1.0)*x1471))+((x1471*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.9)*x1473))+(((2.0)*x1472))+(((-0.9)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1474.value)*(((((-9.0)*r02*x1473))+(((-20.0)*r02*x1472))+(((-1.0)*x1471))+((x1471*(r02*r02)))))))+IKsqr(((((0.9)*x1473))+(((2.0)*x1472))+(((-0.9)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1474.value)*(((((-9.0)*r02*x1473))+(((-20.0)*r02*x1472))+(((-1.0)*x1471))+((x1471*(r02*r02)))))), ((((0.9)*x1473))+(((2.0)*x1472))+(((-0.9)*r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1475=IKcos(j5);
IkReal x1476=IKsin(j5);
IkReal x1477=((0.45)*sj6);
IkReal x1478=(pz*r22);
IkReal x1479=((0.45)*cj1);
IkReal x1480=((0.45)*sj1);
IkReal x1481=((0.5)*x1475);
IkReal x1482=(cj6*x1476);
IkReal x1483=((1.0)*pz*r20);
IkReal x1484=(pz*r21*sj6);
IkReal x1485=((0.5)*sj6*x1476);
evalcond[0]=((((-1.0)*r12*x1479))+(((-1.0)*x1478))+x1481+((r02*x1480)));
evalcond[1]=((-0.095)+(((-1.0)*x1482*x1483))+((x1476*x1484))+((x1475*x1478)));
evalcond[2]=(((r21*x1485))+(((-1.0)*pz))+(((-0.5)*r20*x1482))+((r22*x1481)));
evalcond[3]=((((-0.5)*r00*x1482))+((r01*x1485))+x1480+((r02*x1481)));
evalcond[4]=(((r12*x1481))+((r11*x1485))+(((-0.5)*r10*x1482))+(((-1.0)*x1479)));
evalcond[5]=((((-1.0)*cj6*r10*x1479))+(((-1.0)*cj6*x1483))+((cj1*r11*x1477))+((cj6*r00*x1480))+x1484+(((-1.0)*r01*sj1*x1477))+(((-0.5)*x1476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1486=(cj1*r12);
IkReal x1487=(r02*sj1);
IkReal x1488=((0.45)*r22);
CheckValue<IkReal> x1489=IKPowWithIntegerCheck(((((0.5)*r21*sj6))+(((-0.5)*cj6*r20))),-1);
if(!x1489.valid){
continue;
}
if( IKabs(((x1489.value)*((((x1487*x1488))+(((-1.0)*x1486*x1488))+(((-1.0)*pz*(r22*r22)))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((2.0)*pz*r22))+(((0.9)*x1486))+(((-0.9)*x1487)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1489.value)*((((x1487*x1488))+(((-1.0)*x1486*x1488))+(((-1.0)*pz*(r22*r22)))+pz))))+IKsqr(((((2.0)*pz*r22))+(((0.9)*x1486))+(((-0.9)*x1487))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1489.value)*((((x1487*x1488))+(((-1.0)*x1486*x1488))+(((-1.0)*pz*(r22*r22)))+pz))), ((((2.0)*pz*r22))+(((0.9)*x1486))+(((-0.9)*x1487))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1490=IKcos(j5);
IkReal x1491=IKsin(j5);
IkReal x1492=((0.45)*sj6);
IkReal x1493=(pz*r22);
IkReal x1494=((0.45)*cj1);
IkReal x1495=((0.45)*sj1);
IkReal x1496=((0.5)*x1490);
IkReal x1497=(cj6*x1491);
IkReal x1498=((1.0)*pz*r20);
IkReal x1499=(pz*r21*sj6);
IkReal x1500=((0.5)*sj6*x1491);
evalcond[0]=((((-1.0)*r12*x1494))+(((-1.0)*x1493))+x1496+((r02*x1495)));
evalcond[1]=((-0.095)+(((-1.0)*x1497*x1498))+((x1491*x1499))+((x1490*x1493)));
evalcond[2]=((((-1.0)*pz))+(((-0.5)*r20*x1497))+((r21*x1500))+((r22*x1496)));
evalcond[3]=(((r01*x1500))+x1495+((r02*x1496))+(((-0.5)*r00*x1497)));
evalcond[4]=(((r11*x1500))+(((-1.0)*x1494))+((r12*x1496))+(((-0.5)*r10*x1497)));
evalcond[5]=((((-1.0)*cj6*r10*x1494))+(((-1.0)*r01*sj1*x1492))+(((-0.5)*x1491))+((cj6*r00*x1495))+x1499+((cj1*r11*x1492))+(((-1.0)*cj6*x1498)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1501=((((-1.0)*cj6*pz*r20))+((pz*r21*sj6)));
CheckValue<IkReal> x1504 = IKatan2WithCheck(IkReal((pz*r22)),IkReal(x1501),IKFAST_ATAN2_MAGTHRESH);
if(!x1504.valid){
continue;
}
IkReal x1502=((1.0)*(x1504.value));
if((((((pz*pz)*(r22*r22)))+(x1501*x1501))) < -0.00001)
continue;
CheckValue<IkReal> x1505=IKPowWithIntegerCheck(IKabs(IKsqrt(((((pz*pz)*(r22*r22)))+(x1501*x1501)))),-1);
if(!x1505.valid){
continue;
}
if( (((0.095)*(x1505.value))) < -1-IKFAST_SINCOS_THRESH || (((0.095)*(x1505.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1503=IKasin(((0.095)*(x1505.value)));
j5array[0]=((((-1.0)*x1502))+x1503);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1502))+(((-1.0)*x1503)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1506=IKsin(j5);
IkReal x1507=((0.5)*x1506);
evalcond[0]=((((0.5)*r22*(IKcos(j5))))+(((-1.0)*pz))+(((-1.0)*cj6*r20*x1507))+((r21*sj6*x1507)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1508=((1.11111111111111)*cj5);
IkReal x1509=((1.11111111111111)*sj5*sj6);
IkReal x1510=((1.11111111111111)*cj6*sj5);
if( IKabs(((((-1.0)*r01*x1509))+((r00*x1510))+(((-1.0)*r02*x1508)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r11*x1509))+((r12*x1508))+(((-1.0)*r10*x1510)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*x1509))+((r00*x1510))+(((-1.0)*r02*x1508))))+IKsqr((((r11*x1509))+((r12*x1508))+(((-1.0)*r10*x1510))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r01*x1509))+((r00*x1510))+(((-1.0)*r02*x1508))), (((r11*x1509))+((r12*x1508))+(((-1.0)*r10*x1510))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1511=IKsin(j1);
IkReal x1512=IKcos(j1);
IkReal x1513=(r01*sj6);
IkReal x1514=(cj6*r00);
IkReal x1515=((0.5)*sj5);
IkReal x1516=((0.5)*cj5);
IkReal x1517=(pz*sj6);
IkReal x1518=(cj6*r10);
IkReal x1519=((1.0)*r20);
IkReal x1520=(cj6*pz);
IkReal x1521=(r11*sj6);
IkReal x1522=((0.45)*x1511);
IkReal x1523=((0.45)*x1512);
evalcond[0]=((((-1.0)*r12*x1523))+(((-1.0)*pz*r22))+x1516+((r02*x1522)));
evalcond[1]=(((x1513*x1515))+x1522+(((-1.0)*x1514*x1515))+((r02*x1516)));
evalcond[2]=((((-1.0)*x1515*x1518))+((r12*x1516))+(((-1.0)*x1523))+((x1515*x1521)));
evalcond[3]=((((-1.0)*cj6*r11*x1523))+((cj6*r01*x1522))+(((-1.0)*r10*sj6*x1523))+(((-1.0)*r21*x1520))+(((-1.0)*x1517*x1519))+((r00*sj6*x1522)));
evalcond[4]=((((-1.0)*x1515))+(((-1.0)*x1519*x1520))+(((-1.0)*x1518*x1523))+(((-1.0)*x1513*x1522))+((x1521*x1523))+((r21*x1517))+((x1514*x1522)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1524=((((0.5)*r21*sj6))+(((-0.5)*cj6*r20)));
CheckValue<IkReal> x1527 = IKatan2WithCheck(IkReal(((0.5)*r22)),IkReal(x1524),IKFAST_ATAN2_MAGTHRESH);
if(!x1527.valid){
continue;
}
IkReal x1525=((1.0)*(x1527.value));
if((((((0.25)*(r22*r22)))+(x1524*x1524))) < -0.00001)
continue;
CheckValue<IkReal> x1528=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.25)*(r22*r22)))+(x1524*x1524)))),-1);
if(!x1528.valid){
continue;
}
if( ((pz*(x1528.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1528.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1526=IKasin((pz*(x1528.value)));
j5array[0]=((((-1.0)*x1525))+x1526);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1525))+(((-1.0)*x1526)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1529=IKsin(j5);
IkReal x1530=(pz*x1529);
evalcond[0]=((-0.095)+(((-1.0)*cj6*r20*x1530))+((r21*sj6*x1530))+((pz*r22*(IKcos(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1531=((1.11111111111111)*cj5);
IkReal x1532=((1.11111111111111)*sj5*sj6);
IkReal x1533=((1.11111111111111)*cj6*sj5);
if( IKabs(((((-1.0)*r01*x1532))+((r00*x1533))+(((-1.0)*r02*x1531)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r12*x1531))+((r11*x1532))+(((-1.0)*r10*x1533)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*x1532))+((r00*x1533))+(((-1.0)*r02*x1531))))+IKsqr((((r12*x1531))+((r11*x1532))+(((-1.0)*r10*x1533))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r01*x1532))+((r00*x1533))+(((-1.0)*r02*x1531))), (((r12*x1531))+((r11*x1532))+(((-1.0)*r10*x1533))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1534=IKsin(j1);
IkReal x1535=IKcos(j1);
IkReal x1536=(r01*sj6);
IkReal x1537=(cj6*r00);
IkReal x1538=((0.5)*sj5);
IkReal x1539=((0.5)*cj5);
IkReal x1540=(pz*sj6);
IkReal x1541=(cj6*r10);
IkReal x1542=((1.0)*r20);
IkReal x1543=(cj6*pz);
IkReal x1544=(r11*sj6);
IkReal x1545=((0.45)*x1534);
IkReal x1546=((0.45)*x1535);
evalcond[0]=((((-1.0)*pz*r22))+x1539+((r02*x1545))+(((-1.0)*r12*x1546)));
evalcond[1]=((((-1.0)*x1537*x1538))+((x1536*x1538))+x1545+((r02*x1539)));
evalcond[2]=(((r12*x1539))+((x1538*x1544))+(((-1.0)*x1546))+(((-1.0)*x1538*x1541)));
evalcond[3]=((((-1.0)*r10*sj6*x1546))+(((-1.0)*x1540*x1542))+(((-1.0)*r21*x1543))+(((-1.0)*cj6*r11*x1546))+((r00*sj6*x1545))+((cj6*r01*x1545)));
evalcond[4]=(((x1544*x1546))+((x1537*x1545))+(((-1.0)*x1538))+(((-1.0)*x1536*x1545))+((r21*x1540))+(((-1.0)*x1542*x1543))+(((-1.0)*x1541*x1546)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1549 = IKatan2WithCheck(IkReal(((0.9)*py)),IkReal(((-0.9)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1549.valid){
continue;
}
IkReal x1547=((1.0)*(x1549.value));
if((((((0.81)*(py*py)))+(((0.81)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x1550=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.81)*(py*py)))+(((0.81)*(px*px)))))),-1);
if(!x1550.valid){
continue;
}
if( (((x1550.value)*(((-0.0475)+pp)))) < -1-IKFAST_SINCOS_THRESH || (((x1550.value)*(((-0.0475)+pp)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1548=IKasin(((x1550.value)*(((-0.0475)+pp))));
j1array[0]=((((-1.0)*x1548))+(((-1.0)*x1547)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x1548+(((-1.0)*x1547)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=((((2.0)*npz))+(((-0.9)*r02*sj1))+(((0.9)*cj1*r12)));
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x1551=(r12*sj5);
IkReal x1552=((0.9)*sj1);
j6eval[0]=x1551;
j6eval[1]=((IKabs((((cj5*r10))+(((-2.0)*rxp1_1))+((r21*x1552)))))+(IKabs(((((-1.0)*cj5*r11))+(((-2.0)*rxp0_1))+((r20*x1552))))));
j6eval[2]=IKsign(x1551);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1553=((2.0)*pz);
IkReal x1554=(cj5*r22);
IkReal x1555=((1.0)*cj5*npz);
IkReal x1556=((((-1.0)*npx*r21*sj5))+((npy*r20*sj5)));
j6eval[0]=x1556;
j6eval[1]=IKsign(x1556);
j6eval[2]=((IKabs((((pp*r20))+(((-1.0)*r20*x1555))+((npx*x1554))+(((0.0475)*r20))+(((-1.0)*npx*x1553)))))+(IKabs((((pp*r21))+((npy*x1554))+(((-1.0)*r21*x1555))+(((0.0475)*r21))+(((-1.0)*npy*x1553))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1557=(cj5*r02);
IkReal x1558=((2.0)*px);
IkReal x1559=((0.9)*sj1);
IkReal x1560=((1.0)*r01);
IkReal x1561=(cj5*npz);
IkReal x1562=((((-1.0)*npx*sj5*x1560))+((npy*r00*sj5)));
j6eval[0]=x1562;
j6eval[1]=((IKabs((((pp*r00))+(((0.0475)*r00))+((npx*x1557))+((npx*x1559))+(((-1.0)*npx*x1558))+(((-1.0)*r00*x1561)))))+(IKabs((((pp*r01))+(((0.0475)*r01))+(((-1.0)*x1560*x1561))+((npy*x1559))+((npy*x1557))+(((-1.0)*npy*x1558))))));
j6eval[2]=IKsign(x1562);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1563=((0.45)*cj1);
IkReal x1564=((0.45)*sj1);
j6eval[0]=((IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1563))+((r00*x1564)))))+(IKabs((npy+((r11*x1563))+(((-1.0)*r01*x1564))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1565=((0.45)*sj1);
IkReal x1566=((0.45)*cj1);
j6eval[0]=((IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1566))+((r00*x1565)))))+(IKabs(((((-1.0)*npy))+(((-1.0)*r11*x1566))+((r01*x1565))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1567=((0.45)*cj1);
IkReal x1568=((0.45)*sj1);
CheckValue<IkReal> x1570 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+(((-1.0)*r11*x1567))+((r01*x1568)))),IkReal(((((-1.0)*npx))+(((-1.0)*r10*x1567))+((r00*x1568)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1570.valid){
continue;
}
IkReal x1569=x1570.value;
j6array[0]=((-1.0)*x1569);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1569)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1571=IKsin(j6);
IkReal x1572=IKcos(j6);
IkReal x1573=((0.45)*cj1);
IkReal x1574=((0.45)*sj1);
evalcond[0]=((((-1.0)*npx*x1572))+((npy*x1571))+((r11*x1571*x1573))+((r00*x1572*x1574))+(((-1.0)*r10*x1572*x1573))+(((-1.0)*r01*x1571*x1574)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1575=((0.45)*sj1);
IkReal x1576=((0.45)*cj1);
CheckValue<IkReal> x1578 = IKatan2WithCheck(IkReal(((((-1.0)*npx))+(((-1.0)*r10*x1576))+((r00*x1575)))),IkReal((npy+((r11*x1576))+(((-1.0)*r01*x1575)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1578.valid){
continue;
}
IkReal x1577=x1578.value;
j6array[0]=((-1.0)*x1577);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1577)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1579=IKsin(j6);
IkReal x1580=IKcos(j6);
IkReal x1581=((0.45)*sj1);
IkReal x1582=((0.45)*cj1);
evalcond[0]=((((-1.0)*npy*x1580))+(((-1.0)*r10*x1579*x1582))+(((-1.0)*npx*x1579))+((r01*x1580*x1581))+((r00*x1579*x1581))+(((-1.0)*r11*x1580*x1582)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1583=((0.45)*cj1);
IkReal x1584=((0.45)*sj1);
j6eval[0]=((IKabs(((((-1.0)*npx))+((r00*x1584))+(((-1.0)*r10*x1583)))))+(IKabs((npy+((r11*x1583))+(((-1.0)*r01*x1584))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1585=((0.45)*sj1);
IkReal x1586=((0.45)*cj1);
j6eval[0]=((IKabs(((((-1.0)*r11*x1586))+((r01*x1585))+(((-1.0)*npy)))))+(IKabs(((((-1.0)*npx))+((r00*x1585))+(((-1.0)*r10*x1586))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1587=((0.45)*cj1);
IkReal x1588=((0.45)*sj1);
CheckValue<IkReal> x1590 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1587))+((r01*x1588))+(((-1.0)*npy)))),IkReal(((((-1.0)*npx))+((r00*x1588))+(((-1.0)*r10*x1587)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1590.valid){
continue;
}
IkReal x1589=x1590.value;
j6array[0]=((-1.0)*x1589);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1589)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1591=IKsin(j6);
IkReal x1592=IKcos(j6);
IkReal x1593=((0.45)*cj1);
IkReal x1594=((0.45)*sj1);
evalcond[0]=((((-1.0)*r10*x1592*x1593))+((npy*x1591))+(((-1.0)*npx*x1592))+((r00*x1592*x1594))+(((-1.0)*r01*x1591*x1594))+((r11*x1591*x1593)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1595=((0.45)*sj1);
IkReal x1596=((0.45)*cj1);
CheckValue<IkReal> x1598 = IKatan2WithCheck(IkReal((((r00*x1595))+(((-1.0)*npx))+(((-1.0)*r10*x1596)))),IkReal((((r11*x1596))+npy+(((-1.0)*r01*x1595)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1598.valid){
continue;
}
IkReal x1597=x1598.value;
j6array[0]=((-1.0)*x1597);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1597)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1599=IKsin(j6);
IkReal x1600=IKcos(j6);
IkReal x1601=((0.45)*sj1);
IkReal x1602=((0.45)*cj1);
evalcond[0]=(((r01*x1600*x1601))+(((-1.0)*npy*x1600))+(((-1.0)*r11*x1600*x1602))+(((-1.0)*npx*x1599))+((r00*x1599*x1601))+(((-1.0)*r10*x1599*x1602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r12);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
IkReal x1603=(r02*sj5);
IkReal x1604=((0.9)*cj1);
IkReal x1605=((1.0)*cj5*r22);
j6eval[0]=x1603;
j6eval[1]=IKsign(x1603);
j6eval[2]=((IKabs(((((-1.0)*r20*x1604))+(((2.0)*rxp0_0))+(((-1.0)*r10*x1605)))))+(IKabs(((((2.0)*rxp1_0))+(((-1.0)*r21*x1604))+(((-1.0)*r11*x1605))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
IkReal x1606=(r22*sj5);
IkReal x1607=((0.9)*sj1);
IkReal x1608=((0.9)*cj1);
IkReal x1609=(cj5*r02);
j6eval[0]=x1606;
j6eval[1]=IKsign(x1606);
j6eval[2]=((IKabs((((r00*x1608))+(((2.0)*rxp0_2))+((r10*x1607))+((r10*x1609)))))+(IKabs(((((2.0)*rxp1_2))+((r01*x1608))+((r11*x1607))+((r11*x1609))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
IkReal x1610=((1.0)*r11);
IkReal x1611=((2.0)*py);
IkReal x1612=((1.0)*r10);
IkReal x1613=((0.9)*cj1);
IkReal x1614=(cj5*pz*r22);
IkReal x1615=(cj5*px*r02);
IkReal x1616=(((npy*r10*sj5))+(((-1.0)*npx*sj5*x1610)));
j6eval[0]=x1616;
j6eval[1]=((IKabs((((pp*r11))+(((-1.0)*x1610*x1615))+(((-1.0)*x1610*x1614))+(((0.0475)*r11))+(((-1.0)*npy*x1611))+(((-1.0)*npy*x1613)))))+(IKabs((((pp*r10))+(((0.0475)*r10))+(((-1.0)*npx*x1611))+(((-1.0)*npx*x1613))+(((-1.0)*x1612*x1615))+(((-1.0)*x1612*x1614))))));
j6eval[2]=IKsign(x1616);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1617=((0.45)*cj1);
IkReal x1618=((0.45)*sj1);
j6eval[0]=((IKabs(((((-1.0)*r01*x1618))+npy+((r11*x1617)))))+(IKabs((((r00*x1618))+(((-1.0)*npx))+(((-1.0)*r10*x1617))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1619=((0.45)*sj1);
IkReal x1620=((0.45)*cj1);
j6eval[0]=((IKabs((((r00*x1619))+(((-1.0)*npx))+(((-1.0)*r10*x1620)))))+(IKabs(((((-1.0)*r11*x1620))+((r01*x1619))+(((-1.0)*npy))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1621=((0.45)*cj1);
IkReal x1622=((0.45)*sj1);
CheckValue<IkReal> x1624 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1621))+((r01*x1622))+(((-1.0)*npy)))),IkReal((((r00*x1622))+(((-1.0)*npx))+(((-1.0)*r10*x1621)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1624.valid){
continue;
}
IkReal x1623=x1624.value;
j6array[0]=((-1.0)*x1623);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1623)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1625=IKsin(j6);
IkReal x1626=IKcos(j6);
IkReal x1627=((0.45)*cj1);
IkReal x1628=((0.45)*sj1);
evalcond[0]=(((r00*x1626*x1628))+((r11*x1625*x1627))+((npy*x1625))+(((-1.0)*npx*x1626))+(((-1.0)*r10*x1626*x1627))+(((-1.0)*r01*x1625*x1628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1629=((0.45)*sj1);
IkReal x1630=((0.45)*cj1);
CheckValue<IkReal> x1632 = IKatan2WithCheck(IkReal((((r00*x1629))+(((-1.0)*npx))+(((-1.0)*r10*x1630)))),IkReal((((r11*x1630))+npy+(((-1.0)*r01*x1629)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1632.valid){
continue;
}
IkReal x1631=x1632.value;
j6array[0]=((-1.0)*x1631);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1631)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1633=IKsin(j6);
IkReal x1634=IKcos(j6);
IkReal x1635=((0.45)*sj1);
IkReal x1636=((0.45)*cj1);
evalcond[0]=((((-1.0)*npy*x1634))+(((-1.0)*npx*x1633))+(((-1.0)*r10*x1633*x1636))+(((-1.0)*r11*x1634*x1636))+((r00*x1633*x1635))+((r01*x1634*x1635)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1637=((0.45)*cj1);
IkReal x1638=((0.45)*sj1);
j6eval[0]=((IKabs(((((-1.0)*r01*x1638))+((r11*x1637))+npy)))+(IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1637))+((r00*x1638))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r12=0;
npz=(((px*r02))+((pz*r22)));
rxp2_0=((-1.0)*py*r22);
rxp2_2=(py*r02);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1639=((0.45)*sj1);
IkReal x1640=((0.45)*cj1);
j6eval[0]=((IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1640))+((r00*x1639)))))+(IKabs(((((-1.0)*r11*x1640))+(((-1.0)*npy))+((r01*x1639))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1641=((0.45)*cj1);
IkReal x1642=((0.45)*sj1);
CheckValue<IkReal> x1644 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1641))+(((-1.0)*npy))+((r01*x1642)))),IkReal(((((-1.0)*npx))+((r00*x1642))+(((-1.0)*r10*x1641)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1644.valid){
continue;
}
IkReal x1643=x1644.value;
j6array[0]=((-1.0)*x1643);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1643)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1645=IKsin(j6);
IkReal x1646=IKcos(j6);
IkReal x1647=((0.45)*cj1);
IkReal x1648=((0.45)*sj1);
evalcond[0]=((((-1.0)*npx*x1646))+((r11*x1645*x1647))+(((-1.0)*r01*x1645*x1648))+(((-1.0)*r10*x1646*x1647))+((r00*x1646*x1648))+((npy*x1645)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1649=((0.45)*sj1);
IkReal x1650=((0.45)*cj1);
CheckValue<IkReal> x1652 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1650))+(((-1.0)*npx))+((r00*x1649)))),IkReal(((((-1.0)*r01*x1649))+((r11*x1650))+npy)),IKFAST_ATAN2_MAGTHRESH);
if(!x1652.valid){
continue;
}
IkReal x1651=x1652.value;
j6array[0]=((-1.0)*x1651);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1651)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1653=IKsin(j6);
IkReal x1654=IKcos(j6);
IkReal x1655=((0.45)*sj1);
IkReal x1656=((0.45)*cj1);
evalcond[0]=(((r01*x1654*x1655))+(((-1.0)*npx*x1653))+(((-1.0)*r10*x1653*x1656))+(((-1.0)*r11*x1654*x1656))+(((-1.0)*npy*x1654))+((r00*x1653*x1655)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r02);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
IkReal x1657=(r22*sj5);
IkReal x1658=((0.9)*sj1);
IkReal x1659=((0.9)*cj1);
j6eval[0]=x1657;
j6eval[1]=((IKabs((((r10*x1658))+((r00*x1659))+(((2.0)*rxp0_2)))))+(IKabs(((((2.0)*rxp1_2))+((r11*x1658))+((r01*x1659))))));
j6eval[2]=IKsign(x1657);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
IkReal x1660=((2.0)*px);
IkReal x1661=((0.9)*sj1);
IkReal x1662=((1.0)*r01);
IkReal x1663=(cj5*pz*r22);
IkReal x1664=((((-1.0)*npx*sj5*x1662))+((npy*r00*sj5)));
j6eval[0]=x1664;
j6eval[1]=((IKabs((((pp*r01))+(((-1.0)*x1662*x1663))+(((0.0475)*r01))+(((-1.0)*npy*x1660))+((npy*x1661)))))+(IKabs((((pp*r00))+((npx*x1661))+(((-1.0)*r00*x1663))+(((0.0475)*r00))+(((-1.0)*npx*x1660))))));
j6eval[2]=IKsign(x1664);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
IkReal x1665=((1.0)*r11);
IkReal x1666=((2.0)*py);
IkReal x1667=((0.9)*cj1);
IkReal x1668=(cj5*pz*r22);
IkReal x1669=((((-1.0)*npx*sj5*x1665))+((npy*r10*sj5)));
j6eval[0]=x1669;
j6eval[1]=IKsign(x1669);
j6eval[2]=((IKabs((((pp*r10))+(((0.0475)*r10))+(((-1.0)*r10*x1668))+(((-1.0)*npx*x1666))+(((-1.0)*npx*x1667)))))+(IKabs((((pp*r11))+(((0.0475)*r11))+(((-1.0)*npy*x1667))+(((-1.0)*npy*x1666))+(((-1.0)*x1665*x1668))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
sj5=0;
cj5=1.0;
j5=0;
j6eval[0]=((((4.44444444444444)*cj1*py))+(((-4.93827160493827)*(px*px)))+(((4.93827160493827)*(npy*npy)))+(((4.93827160493827)*(npx*npx)))+(cj1*cj1));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1670=((0.45)*cj1);
CheckValue<IkReal> x1672 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1670)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1670)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1672.valid){
continue;
}
IkReal x1671=x1672.value;
j6array[0]=((-1.0)*x1671);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1671)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1673=IKsin(j6);
IkReal x1674=IKcos(j6);
IkReal x1675=((0.45)*cj1);
evalcond[0]=((((-1.0)*r10*x1673*x1675))+((px*r00*x1673))+(((-1.0)*r11*x1674*x1675))+(((-1.0)*npx*x1673))+((px*r01*x1674))+(((-1.0)*npy*x1674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r12=0;
npz=(pz*r22);
rxp2_0=((-1.0)*py*r22);
rxp2_2=0;
r02=0;
rxp2_1=(px*r22);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j6eval[0]=((((4.44444444444444)*cj1*py))+(((-4.93827160493827)*(px*px)))+(((4.93827160493827)*(npy*npy)))+(((4.93827160493827)*(npx*npx)))+(cj1*cj1));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1676=((0.45)*cj1);
CheckValue<IkReal> x1678 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1676)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1676)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1678.valid){
continue;
}
IkReal x1677=x1678.value;
j6array[0]=((-1.0)*x1677);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1677)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1679=IKsin(j6);
IkReal x1680=IKcos(j6);
IkReal x1681=((0.45)*cj1);
evalcond[0]=(((px*r00*x1679))+(((-1.0)*r11*x1680*x1681))+(((-1.0)*npy*x1680))+(((-1.0)*npx*x1679))+(((-1.0)*r10*x1679*x1681))+((px*r01*x1680)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1682=((1.0)*r11);
IkReal x1683=((2.0)*py);
IkReal x1684=((0.9)*cj1);
IkReal x1685=(cj5*pz*r22);
CheckValue<IkReal> x1686=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*sj5*x1682))+((npy*r10*sj5)))),-1);
if(!x1686.valid){
continue;
}
CheckValue<IkReal> x1687 = IKatan2WithCheck(IkReal((((pp*r10))+(((0.0475)*r10))+(((-1.0)*npx*x1683))+(((-1.0)*npx*x1684))+(((-1.0)*r10*x1685)))),IkReal((((pp*r11))+(((-1.0)*x1682*x1685))+(((0.0475)*r11))+(((-1.0)*npy*x1683))+(((-1.0)*npy*x1684)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1687.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1686.value)))+(x1687.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1688=IKsin(j6);
IkReal x1689=IKcos(j6);
IkReal x1690=((1.0)*npx);
IkReal x1691=((0.45)*sj1);
IkReal x1692=((0.45)*cj1);
IkReal x1693=(npy*x1688);
IkReal x1694=(sj5*x1689);
IkReal x1695=(r01*x1691);
IkReal x1696=((0.5)*sj5*x1688);
evalcond[0]=(((r01*x1696))+x1691+(((-1.0)*px))+(((-0.5)*r00*x1694)));
evalcond[1]=((((-0.5)*r10*x1694))+(((-1.0)*x1692))+((r11*x1696))+(((-1.0)*py)));
evalcond[2]=((-0.0475)+(((-1.0)*x1690*x1694))+(((-1.0)*pp))+((cj5*pz*r22))+((sj5*x1693)));
evalcond[3]=(((r21*x1696))+(((-0.5)*r20*x1694))+(((-1.0)*pz))+((pz*(r22*r22))));
evalcond[4]=((((-1.0)*x1688*x1690))+((r00*x1688*x1691))+(((-1.0)*npy*x1689))+((x1689*x1695))+(((-1.0)*r11*x1689*x1692))+(((-1.0)*r10*x1688*x1692)));
evalcond[5]=((((-1.0)*x1688*x1695))+((r00*x1689*x1691))+x1693+((r11*x1688*x1692))+(((-1.0)*r10*x1689*x1692))+(((-0.5)*sj5))+(((-1.0)*x1689*x1690)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1697=((2.0)*px);
IkReal x1698=((0.9)*sj1);
IkReal x1699=((1.0)*r01);
IkReal x1700=(cj5*pz*r22);
CheckValue<IkReal> x1701=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*sj5*x1699))+((npy*r00*sj5)))),-1);
if(!x1701.valid){
continue;
}
CheckValue<IkReal> x1702 = IKatan2WithCheck(IkReal((((pp*r00))+(((0.0475)*r00))+(((-1.0)*npx*x1697))+((npx*x1698))+(((-1.0)*r00*x1700)))),IkReal((((pp*r01))+(((-1.0)*x1699*x1700))+(((-1.0)*npy*x1697))+(((0.0475)*r01))+((npy*x1698)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1702.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1701.value)))+(x1702.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1703=IKsin(j6);
IkReal x1704=IKcos(j6);
IkReal x1705=((1.0)*npx);
IkReal x1706=((0.45)*sj1);
IkReal x1707=((0.45)*cj1);
IkReal x1708=(npy*x1703);
IkReal x1709=(sj5*x1704);
IkReal x1710=(r01*x1706);
IkReal x1711=((0.5)*sj5*x1703);
evalcond[0]=((((-0.5)*r00*x1709))+x1706+((r01*x1711))+(((-1.0)*px)));
evalcond[1]=(((r11*x1711))+(((-1.0)*x1707))+(((-1.0)*py))+(((-0.5)*r10*x1709)));
evalcond[2]=((-0.0475)+((sj5*x1708))+(((-1.0)*pp))+(((-1.0)*x1705*x1709))+((cj5*pz*r22)));
evalcond[3]=((((-0.5)*r20*x1709))+(((-1.0)*pz))+((pz*(r22*r22)))+((r21*x1711)));
evalcond[4]=((((-1.0)*r10*x1703*x1707))+(((-1.0)*x1703*x1705))+((x1704*x1710))+(((-1.0)*npy*x1704))+((r00*x1703*x1706))+(((-1.0)*r11*x1704*x1707)));
evalcond[5]=((((-1.0)*r10*x1704*x1707))+((r11*x1703*x1707))+x1708+(((-1.0)*x1704*x1705))+(((-1.0)*x1703*x1710))+((r00*x1704*x1706))+(((-0.5)*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1712=((0.9)*sj1);
IkReal x1713=((0.9)*cj1);
CheckValue<IkReal> x1714 = IKatan2WithCheck(IkReal(((((2.0)*rxp0_2))+((r00*x1713))+((r10*x1712)))),IkReal(((((2.0)*rxp1_2))+((r11*x1712))+((r01*x1713)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1714.valid){
continue;
}
CheckValue<IkReal> x1715=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1715.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1714.value)+(((1.5707963267949)*(x1715.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1716=IKsin(j6);
IkReal x1717=IKcos(j6);
IkReal x1718=((1.0)*npx);
IkReal x1719=((0.45)*sj1);
IkReal x1720=((0.45)*cj1);
IkReal x1721=(npy*x1716);
IkReal x1722=(sj5*x1717);
IkReal x1723=(r01*x1719);
IkReal x1724=((0.5)*sj5*x1716);
evalcond[0]=(((r01*x1724))+x1719+(((-0.5)*r00*x1722))+(((-1.0)*px)));
evalcond[1]=((((-1.0)*py))+(((-0.5)*r10*x1722))+((r11*x1724))+(((-1.0)*x1720)));
evalcond[2]=((-0.0475)+((sj5*x1721))+(((-1.0)*pp))+((cj5*pz*r22))+(((-1.0)*x1718*x1722)));
evalcond[3]=(((r21*x1724))+(((-1.0)*pz))+((pz*(r22*r22)))+(((-0.5)*r20*x1722)));
evalcond[4]=((((-1.0)*x1716*x1718))+(((-1.0)*r11*x1717*x1720))+((x1717*x1723))+(((-1.0)*r10*x1716*x1720))+((r00*x1716*x1719))+(((-1.0)*npy*x1717)));
evalcond[5]=(((r11*x1716*x1720))+(((-1.0)*r10*x1717*x1720))+x1721+((r00*x1717*x1719))+(((-0.5)*sj5))+(((-1.0)*x1716*x1723))+(((-1.0)*x1717*x1718)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1725=((1.0)*r11);
IkReal x1726=((2.0)*py);
IkReal x1727=((1.0)*r10);
IkReal x1728=((0.9)*cj1);
IkReal x1729=(cj5*pz*r22);
IkReal x1730=(cj5*px*r02);
CheckValue<IkReal> x1731 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1726))+(((-1.0)*npx*x1728))+((pp*r10))+(((0.0475)*r10))+(((-1.0)*x1727*x1730))+(((-1.0)*x1727*x1729)))),IkReal((((pp*r11))+(((0.0475)*r11))+(((-1.0)*x1725*x1729))+(((-1.0)*x1725*x1730))+(((-1.0)*npy*x1726))+(((-1.0)*npy*x1728)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1731.valid){
continue;
}
CheckValue<IkReal> x1732=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*sj5*x1725))+((npy*r10*sj5)))),-1);
if(!x1732.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1731.value)+(((1.5707963267949)*(x1732.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1733=IKsin(j6);
IkReal x1734=IKcos(j6);
IkReal x1735=((1.0)*npx);
IkReal x1736=(cj5*r22);
IkReal x1737=(cj5*r02);
IkReal x1738=((0.45)*sj1);
IkReal x1739=((0.45)*cj1);
IkReal x1740=(npy*x1733);
IkReal x1741=(sj5*x1734);
IkReal x1742=(r01*x1738);
IkReal x1743=((0.5)*sj5*x1733);
evalcond[0]=((((-1.0)*py))+((r11*x1743))+(((-1.0)*x1739))+(((-0.5)*r10*x1741)));
evalcond[1]=((((0.5)*x1736))+((r21*x1743))+(((-1.0)*pz))+(((-0.5)*r20*x1741)));
evalcond[2]=(x1738+(((0.5)*x1737))+(((-1.0)*px))+(((-0.5)*r00*x1741))+((r01*x1743)));
evalcond[3]=((-0.0475)+((px*x1737))+(((-1.0)*x1735*x1741))+((pz*x1736))+(((-1.0)*pp))+((sj5*x1740)));
evalcond[4]=((((-1.0)*x1733*x1735))+((x1734*x1742))+(((-1.0)*npy*x1734))+(((-1.0)*r11*x1734*x1739))+(((-1.0)*r10*x1733*x1739))+((r00*x1733*x1738)));
evalcond[5]=((((-1.0)*r10*x1734*x1739))+(((-1.0)*x1733*x1742))+x1740+((r00*x1734*x1738))+(((-1.0)*x1734*x1735))+(((-0.5)*sj5))+((r11*x1733*x1739)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1744=((0.9)*sj1);
IkReal x1745=((0.9)*cj1);
IkReal x1746=(cj5*r02);
CheckValue<IkReal> x1747 = IKatan2WithCheck(IkReal(((((2.0)*rxp0_2))+((r00*x1745))+((r10*x1744))+((r10*x1746)))),IkReal(((((2.0)*rxp1_2))+((r11*x1744))+((r11*x1746))+((r01*x1745)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1747.valid){
continue;
}
CheckValue<IkReal> x1748=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1748.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1747.value)+(((1.5707963267949)*(x1748.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1749=IKsin(j6);
IkReal x1750=IKcos(j6);
IkReal x1751=((1.0)*npx);
IkReal x1752=(cj5*r22);
IkReal x1753=(cj5*r02);
IkReal x1754=((0.45)*sj1);
IkReal x1755=((0.45)*cj1);
IkReal x1756=(npy*x1749);
IkReal x1757=(sj5*x1750);
IkReal x1758=(r01*x1754);
IkReal x1759=((0.5)*sj5*x1749);
evalcond[0]=((((-1.0)*py))+(((-1.0)*x1755))+(((-0.5)*r10*x1757))+((r11*x1759)));
evalcond[1]=(((r21*x1759))+(((-1.0)*pz))+(((0.5)*x1752))+(((-0.5)*r20*x1757)));
evalcond[2]=(x1754+(((-1.0)*px))+(((0.5)*x1753))+(((-0.5)*r00*x1757))+((r01*x1759)));
evalcond[3]=((-0.0475)+((pz*x1752))+((px*x1753))+(((-1.0)*pp))+(((-1.0)*x1751*x1757))+((sj5*x1756)));
evalcond[4]=((((-1.0)*r11*x1750*x1755))+((r00*x1749*x1754))+(((-1.0)*x1749*x1751))+((x1750*x1758))+(((-1.0)*r10*x1749*x1755))+(((-1.0)*npy*x1750)));
evalcond[5]=(((r00*x1750*x1754))+x1756+(((-1.0)*x1749*x1758))+((r11*x1749*x1755))+(((-1.0)*x1750*x1751))+(((-0.5)*sj5))+(((-1.0)*r10*x1750*x1755)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1760=((0.9)*cj1);
IkReal x1761=((1.0)*cj5*r22);
CheckValue<IkReal> x1762=IKPowWithIntegerCheck(IKsign((r02*sj5)),-1);
if(!x1762.valid){
continue;
}
CheckValue<IkReal> x1763 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x1760))+(((2.0)*rxp0_0))+(((-1.0)*r10*x1761)))),IkReal(((((2.0)*rxp1_0))+(((-1.0)*r21*x1760))+(((-1.0)*r11*x1761)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1763.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1762.value)))+(x1763.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1764=IKsin(j6);
IkReal x1765=IKcos(j6);
IkReal x1766=((1.0)*npx);
IkReal x1767=(cj5*r22);
IkReal x1768=(cj5*r02);
IkReal x1769=((0.45)*sj1);
IkReal x1770=((0.45)*cj1);
IkReal x1771=(npy*x1764);
IkReal x1772=(sj5*x1765);
IkReal x1773=(r01*x1769);
IkReal x1774=((0.5)*sj5*x1764);
evalcond[0]=((((-0.5)*r10*x1772))+((r11*x1774))+(((-1.0)*py))+(((-1.0)*x1770)));
evalcond[1]=((((0.5)*x1767))+(((-0.5)*r20*x1772))+(((-1.0)*pz))+((r21*x1774)));
evalcond[2]=((((-0.5)*r00*x1772))+(((0.5)*x1768))+x1769+((r01*x1774))+(((-1.0)*px)));
evalcond[3]=((-0.0475)+(((-1.0)*pp))+((pz*x1767))+((sj5*x1771))+(((-1.0)*x1766*x1772))+((px*x1768)));
evalcond[4]=(((x1765*x1773))+(((-1.0)*x1764*x1766))+((r00*x1764*x1769))+(((-1.0)*r11*x1765*x1770))+(((-1.0)*r10*x1764*x1770))+(((-1.0)*npy*x1765)));
evalcond[5]=(x1771+(((-1.0)*x1765*x1766))+(((-1.0)*x1764*x1773))+(((-1.0)*r10*x1765*x1770))+((r00*x1765*x1769))+(((-0.5)*sj5))+((r11*x1764*x1770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1775=(cj5*r02);
IkReal x1776=((2.0)*px);
IkReal x1777=((0.9)*sj1);
IkReal x1778=((1.0)*r01);
IkReal x1779=(cj5*npz);
CheckValue<IkReal> x1780=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*sj5*x1778))+((npy*r00*sj5)))),-1);
if(!x1780.valid){
continue;
}
CheckValue<IkReal> x1781 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x1779))+((pp*r00))+((npx*x1777))+((npx*x1775))+(((0.0475)*r00))+(((-1.0)*npx*x1776)))),IkReal((((pp*r01))+(((-1.0)*x1778*x1779))+((npy*x1777))+((npy*x1775))+(((0.0475)*r01))+(((-1.0)*npy*x1776)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1781.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1780.value)))+(x1781.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1782=IKsin(j6);
IkReal x1783=IKcos(j6);
IkReal x1784=((1.0)*npx);
IkReal x1785=((0.5)*cj5);
IkReal x1786=((0.45)*sj1);
IkReal x1787=((0.45)*cj1);
IkReal x1788=(npy*x1782);
IkReal x1789=(sj5*x1783);
IkReal x1790=(r01*x1786);
IkReal x1791=((0.5)*sj5*x1782);
evalcond[0]=((-0.0475)+(((-1.0)*pp))+((cj5*npz))+(((-1.0)*x1784*x1789))+((sj5*x1788)));
evalcond[1]=(((r21*x1791))+(((-1.0)*pz))+((r22*x1785))+(((-0.5)*r20*x1789)));
evalcond[2]=(x1786+(((-0.5)*r00*x1789))+(((-1.0)*px))+((r02*x1785))+((r01*x1791)));
evalcond[3]=((((-1.0)*x1787))+(((-0.5)*r10*x1789))+(((-1.0)*py))+((r12*x1785))+((r11*x1791)));
evalcond[4]=(((r00*x1782*x1786))+((x1783*x1790))+(((-1.0)*npy*x1783))+(((-1.0)*r11*x1783*x1787))+(((-1.0)*r10*x1782*x1787))+(((-1.0)*x1782*x1784)));
evalcond[5]=((((-1.0)*x1783*x1784))+x1788+((r00*x1783*x1786))+((r11*x1782*x1787))+(((-1.0)*r10*x1783*x1787))+(((-1.0)*x1782*x1790))+(((-0.5)*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1792=((2.0)*pz);
IkReal x1793=(cj5*r22);
IkReal x1794=((1.0)*cj5*npz);
CheckValue<IkReal> x1795=IKPowWithIntegerCheck(IKsign(((((-1.0)*npx*r21*sj5))+((npy*r20*sj5)))),-1);
if(!x1795.valid){
continue;
}
CheckValue<IkReal> x1796 = IKatan2WithCheck(IkReal((((pp*r20))+((npx*x1793))+(((-1.0)*r20*x1794))+(((0.0475)*r20))+(((-1.0)*npx*x1792)))),IkReal((((pp*r21))+((npy*x1793))+(((-1.0)*r21*x1794))+(((0.0475)*r21))+(((-1.0)*npy*x1792)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1796.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1795.value)))+(x1796.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1797=IKsin(j6);
IkReal x1798=IKcos(j6);
IkReal x1799=((1.0)*npx);
IkReal x1800=((0.5)*cj5);
IkReal x1801=((0.45)*sj1);
IkReal x1802=((0.45)*cj1);
IkReal x1803=(npy*x1797);
IkReal x1804=(sj5*x1798);
IkReal x1805=(r01*x1801);
IkReal x1806=((0.5)*sj5*x1797);
evalcond[0]=((-0.0475)+(((-1.0)*x1799*x1804))+((sj5*x1803))+(((-1.0)*pp))+((cj5*npz)));
evalcond[1]=(((r22*x1800))+((r21*x1806))+(((-1.0)*pz))+(((-0.5)*r20*x1804)));
evalcond[2]=((((-0.5)*r00*x1804))+(((-1.0)*px))+((r02*x1800))+x1801+((r01*x1806)));
evalcond[3]=((((-0.5)*r10*x1804))+(((-1.0)*x1802))+(((-1.0)*py))+((r12*x1800))+((r11*x1806)));
evalcond[4]=((((-1.0)*npy*x1798))+((r00*x1797*x1801))+(((-1.0)*r11*x1798*x1802))+((x1798*x1805))+(((-1.0)*r10*x1797*x1802))+(((-1.0)*x1797*x1799)));
evalcond[5]=((((-1.0)*r10*x1798*x1802))+((r00*x1798*x1801))+(((-1.0)*x1797*x1805))+((r11*x1797*x1802))+x1803+(((-0.5)*sj5))+(((-1.0)*x1798*x1799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1807=((0.9)*sj1);
CheckValue<IkReal> x1808 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r11))+(((-2.0)*rxp0_1))+((r20*x1807)))),IkReal((((cj5*r10))+(((-2.0)*rxp1_1))+((r21*x1807)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1808.valid){
continue;
}
CheckValue<IkReal> x1809=IKPowWithIntegerCheck(IKsign((r12*sj5)),-1);
if(!x1809.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1808.value)+(((-1.5707963267949)*(x1809.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1810=IKsin(j6);
IkReal x1811=IKcos(j6);
IkReal x1812=((1.0)*npx);
IkReal x1813=((0.5)*cj5);
IkReal x1814=((0.45)*sj1);
IkReal x1815=((0.45)*cj1);
IkReal x1816=(npy*x1810);
IkReal x1817=(sj5*x1811);
IkReal x1818=(r01*x1814);
IkReal x1819=((0.5)*sj5*x1810);
evalcond[0]=((-0.0475)+((sj5*x1816))+(((-1.0)*x1812*x1817))+(((-1.0)*pp))+((cj5*npz)));
evalcond[1]=(((r22*x1813))+(((-0.5)*r20*x1817))+(((-1.0)*pz))+((r21*x1819)));
evalcond[2]=(((r02*x1813))+(((-0.5)*r00*x1817))+(((-1.0)*px))+((r01*x1819))+x1814);
evalcond[3]=((((-1.0)*x1815))+(((-0.5)*r10*x1817))+(((-1.0)*py))+((r11*x1819))+((r12*x1813)));
evalcond[4]=((((-1.0)*r11*x1811*x1815))+(((-1.0)*r10*x1810*x1815))+(((-1.0)*x1810*x1812))+((r00*x1810*x1814))+(((-1.0)*npy*x1811))+((x1811*x1818)));
evalcond[5]=(((r11*x1810*x1815))+(((-1.0)*x1811*x1812))+(((-1.0)*x1810*x1818))+((r00*x1811*x1814))+x1816+(((-1.0)*r10*x1811*x1815))+(((-0.5)*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x189=((1.0)*sj5);
IkReal x190=((1.0)*r02);
IkReal x191=((1.0)*cj1);
IkReal x192=((1.0)*sj6);
IkReal x193=((1.0)*cj5);
IkReal x194=(((r10*sj1))+((cj1*r00)));
IkReal x195=(((cj1*r01))+((r11*sj1)));
IkReal x196=(((cj6*r20))+(((-1.0)*r21*x192)));
IkReal x197=(((r01*sj1))+(((-1.0)*r11*x191)));
IkReal x198=(((r00*sj1))+(((-1.0)*r10*x191)));
IkReal x199=(((cj1*r12))+(((-1.0)*sj1*x190)));
IkReal x200=((((-1.0)*cj1*x190))+(((-1.0)*r12*sj1)));
IkReal x201=((((-1.0)*x192*x195))+((cj6*x194)));
IkReal x202=((((-1.0)*x192*x197))+((cj6*x198)));
new_r00=((((-1.0)*x189*x200))+((cj5*x201)));
new_r01=(((cj6*x195))+((sj6*x194)));
new_r02=((((-1.0)*x189*x201))+(((-1.0)*x193*x200)));
new_r10=(((cj5*x196))+((r22*sj5)));
new_r11=(((cj6*r21))+((r20*sj6)));
new_r12=(((cj5*r22))+(((-1.0)*x189*x196)));
new_r20=((((-1.0)*x189*x199))+((cj5*x202)));
new_r21=(((cj6*x197))+((sj6*x198)));
new_r22=((((-1.0)*x189*x202))+(((-1.0)*x193*x199)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=new_r22;
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=new_r12;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].fmul = j2mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].fmul = j4mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].fmul = j2mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].fmul = j4mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x203=new_r22*new_r22;
IkReal x204=((16.0)*new_r10);
IkReal x205=((16.0)*new_r01);
IkReal x206=((16.0)*new_r22);
IkReal x207=((8.0)*new_r11);
IkReal x208=((8.0)*new_r00);
IkReal x209=(x203*x204);
IkReal x210=(x203*x205);
j2eval[0]=((IKabs(((((-1.0)*x205))+x210)))+(IKabs(((((-1.0)*x204))+x209)))+(IKabs(((((-1.0)*new_r00*x206))+(((32.0)*new_r11))+(((-16.0)*new_r11*x203)))))+(IKabs((((new_r11*x206))+(((-32.0)*new_r00*x203))+(((16.0)*new_r00)))))+(IKabs(((((-1.0)*x208))+((new_r22*x207)))))+(IKabs(((((-1.0)*new_r22*x208))+((x203*x207)))))+(IKabs(((((-1.0)*x209))+x204)))+(IKabs((x205+(((-1.0)*x210))))));
if( IKabs(j2eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j2, j4]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j2evalpoly[1];
IkReal x211=new_r22*new_r22;
IkReal x212=((16.0)*new_r10);
IkReal x213=(new_r11*new_r22);
IkReal x214=(x211*x212);
IkReal x215=((((8.0)*x213))+(((-8.0)*new_r00)));
op[0]=x215;
op[1]=(x212+(((-1.0)*x214)));
op[2]=((((-32.0)*new_r00*x211))+(((16.0)*x213))+(((16.0)*new_r00)));
op[3]=(x214+(((-1.0)*x212)));
op[4]=x215;
polyroots4(op,zeror,numroots);
IkReal j2array[4], cj2array[4], sj2array[4], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[4]={true,true,true,true};
_nj2 = 4;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

IkReal x216=((16.0)*new_r01);
IkReal x217=new_r22*new_r22;
IkReal x218=(new_r00*new_r22);
IkReal x219=((8.0)*x218);
IkReal x220=(new_r11*x217);
IkReal x221=(x216*x217);
IkReal x222=((8.0)*x220);
j2evalpoly[0]=((((htj2*htj2)*(((((32.0)*new_r11))+(((-16.0)*x218))+(((-16.0)*x220))))))+((htj2*((x216+(((-1.0)*x221))))))+(((htj2*htj2*htj2*htj2)*((x222+(((-1.0)*x219))))))+(((htj2*htj2*htj2)*((x221+(((-1.0)*x216))))))+x222+(((-1.0)*x219)));
if( IKabs(j2evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x223=cj2*cj2;
IkReal x224=(cj2*new_r22);
IkReal x225=((-1.0)+(((-1.0)*x223*(new_r22*new_r22)))+x223);
j4eval[0]=x225;
j4eval[1]=((IKabs((((new_r01*x224))+((new_r00*sj2)))))+(IKabs((((new_r01*sj2))+(((-1.0)*new_r00*x224))))));
j4eval[2]=IKsign(x225);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=new_r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x226=new_r22*new_r22;
j4eval[0]=(((cj2*x226))+(((-1.0)*cj2)));
j4eval[1]=((((-1.0)*sj2))+((sj2*x226)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x227=IKsin(j4);
IkReal x228=IKcos(j4);
evalcond[0]=x227;
evalcond[1]=((-1.0)*x228);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x227)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x228)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x229=IKsin(j4);
IkReal x230=IKcos(j4);
evalcond[0]=x229;
evalcond[1]=((-1.0)*x230);
evalcond[2]=(new_r00+(((-1.0)*x229)));
evalcond[3]=(new_r01+(((-1.0)*x230)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x231=IKsin(j4);
IkReal x232=IKcos(j4);
evalcond[0]=x231;
evalcond[1]=((-1.0)*x232);
evalcond[2]=(new_r10+(((-1.0)*x231)));
evalcond[3]=(new_r11+(((-1.0)*x232)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x233=IKsin(j4);
IkReal x234=IKcos(j4);
evalcond[0]=x233;
evalcond[1]=((-1.0)*x234);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x233)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x234)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x235=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x235.valid){
continue;
}
if((x235.value) < -0.00001)
continue;
IkReal gconst74=((-1.0)*(IKsqrt(x235.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst74)))))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
sj2=IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))));
cj2=gconst74;
if( (gconst74) < -1-IKFAST_SINCOS_THRESH || (gconst74) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=IKacos(gconst74);
CheckValue<IkReal> x236=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x236.valid){
continue;
}
if((x236.value) < -0.00001)
continue;
IkReal gconst74=((-1.0)*(IKsqrt(x236.value)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
CheckValue<IkReal> x237=IKPowWithIntegerCheck(gconst74,-1);
if(!x237.valid){
continue;
}
if( IKabs((((gconst74*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x237.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst74*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74))))))))))+IKsqr((new_r11*(x237.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((gconst74*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74))))))))), (new_r11*(x237.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x238=IKcos(j4);
IkReal x239=IKsin(j4);
IkReal x240=((1.0)*x239);
IkReal x241=((1.0)*x238);
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
IkReal x242=IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))));
IkReal x243=((1.0)*x242);
evalcond[0]=x239;
evalcond[1]=((-1.0)*x238);
evalcond[2]=((((-1.0)*gconst74*x241))+new_r11);
evalcond[3]=((((-1.0)*gconst74*x240))+new_r10);
evalcond[4]=(((x238*x242))+new_r01);
evalcond[5]=(((x239*x242))+new_r00);
evalcond[6]=(((gconst74*new_r10))+(((-1.0)*new_r00*x243))+(((-1.0)*x240)));
evalcond[7]=(((gconst74*new_r11))+(((-1.0)*new_r01*x243))+(((-1.0)*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x244=IKPowWithIntegerCheck(IKsign(gconst74),-1);
if(!x244.valid){
continue;
}
CheckValue<IkReal> x245 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x245.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x244.value)))+(x245.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x246=IKcos(j4);
IkReal x247=IKsin(j4);
IkReal x248=((1.0)*x247);
IkReal x249=((1.0)*x246);
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
IkReal x250=IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))));
IkReal x251=((1.0)*x250);
evalcond[0]=x247;
evalcond[1]=((-1.0)*x246);
evalcond[2]=((((-1.0)*gconst74*x249))+new_r11);
evalcond[3]=((((-1.0)*gconst74*x248))+new_r10);
evalcond[4]=(((x246*x250))+new_r01);
evalcond[5]=(new_r00+((x247*x250)));
evalcond[6]=(((gconst74*new_r10))+(((-1.0)*x248))+(((-1.0)*new_r00*x251)));
evalcond[7]=((((-1.0)*new_r01*x251))+((gconst74*new_r11))+(((-1.0)*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x252=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x252.valid){
continue;
}
if((x252.value) < -0.00001)
continue;
IkReal gconst74=((-1.0)*(IKsqrt(x252.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst74)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
sj2=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))))));
cj2=gconst74;
if( (gconst74) < -1-IKFAST_SINCOS_THRESH || (gconst74) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=((-1.0)*(IKacos(gconst74)));
CheckValue<IkReal> x253=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x253.valid){
continue;
}
if((x253.value) < -0.00001)
continue;
IkReal gconst74=((-1.0)*(IKsqrt(x253.value)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
CheckValue<IkReal> x254=IKPowWithIntegerCheck(gconst74,-1);
if(!x254.valid){
continue;
}
if( IKabs((((gconst74*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x254.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst74*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74))))))))))+IKsqr((new_r11*(x254.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((gconst74*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74))))))))), (new_r11*(x254.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x255=IKcos(j4);
IkReal x256=IKsin(j4);
IkReal x257=((1.0)*x256);
IkReal x258=((1.0)*x255);
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
IkReal x259=IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))));
evalcond[0]=x256;
evalcond[1]=((-1.0)*x255);
evalcond[2]=((((-1.0)*gconst74*x258))+new_r11);
evalcond[3]=((((-1.0)*gconst74*x257))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x258*x259)));
evalcond[5]=((((-1.0)*x257*x259))+new_r00);
evalcond[6]=(((gconst74*new_r10))+((new_r00*x259))+(((-1.0)*x257)));
evalcond[7]=(((new_r01*x259))+((gconst74*new_r11))+(((-1.0)*x258)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x260=IKPowWithIntegerCheck(IKsign(gconst74),-1);
if(!x260.valid){
continue;
}
CheckValue<IkReal> x261 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x261.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x260.value)))+(x261.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x262=IKcos(j4);
IkReal x263=IKsin(j4);
IkReal x264=((1.0)*x263);
IkReal x265=((1.0)*x262);
if((((1.0)+(((-1.0)*(gconst74*gconst74))))) < -0.00001)
continue;
IkReal x266=IKsqrt(((1.0)+(((-1.0)*(gconst74*gconst74)))));
evalcond[0]=x263;
evalcond[1]=((-1.0)*x262);
evalcond[2]=((((-1.0)*gconst74*x265))+new_r11);
evalcond[3]=((((-1.0)*gconst74*x264))+new_r10);
evalcond[4]=((((-1.0)*x265*x266))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x264*x266)));
evalcond[6]=(((gconst74*new_r10))+((new_r00*x266))+(((-1.0)*x264)));
evalcond[7]=(((gconst74*new_r11))+((new_r01*x266))+(((-1.0)*x265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x267=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x267.valid){
continue;
}
if((x267.value) < -0.00001)
continue;
IkReal gconst75=IKsqrt(x267.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst75)))))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
sj2=IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75)))));
cj2=gconst75;
if( (gconst75) < -1-IKFAST_SINCOS_THRESH || (gconst75) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=IKacos(gconst75);
CheckValue<IkReal> x268=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x268.valid){
continue;
}
if((x268.value) < -0.00001)
continue;
IkReal gconst75=IKsqrt(x268.value);
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
CheckValue<IkReal> x269=IKPowWithIntegerCheck(gconst75,-1);
if(!x269.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75))))))))+((gconst75*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x269.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75))))))))+((gconst75*new_r10))))+IKsqr((new_r11*(x269.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75))))))))+((gconst75*new_r10))), (new_r11*(x269.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x270=IKcos(j4);
IkReal x271=IKsin(j4);
IkReal x272=((1.0)*x270);
IkReal x273=((1.0)*x271);
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
IkReal x274=IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75)))));
IkReal x275=((1.0)*x274);
evalcond[0]=x271;
evalcond[1]=((-1.0)*x270);
evalcond[2]=((((-1.0)*gconst75*x272))+new_r11);
evalcond[3]=((((-1.0)*gconst75*x273))+new_r10);
evalcond[4]=(((x270*x274))+new_r01);
evalcond[5]=(((x271*x274))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x275))+(((-1.0)*x273))+((gconst75*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x275))+(((-1.0)*x272))+((gconst75*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
CheckValue<IkReal> x277=IKPowWithIntegerCheck(IKsign(gconst75),-1);
if(!x277.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x276.value)+(((1.5707963267949)*(x277.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x278=IKcos(j4);
IkReal x279=IKsin(j4);
IkReal x280=((1.0)*x278);
IkReal x281=((1.0)*x279);
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
IkReal x282=IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75)))));
IkReal x283=((1.0)*x282);
evalcond[0]=x279;
evalcond[1]=((-1.0)*x278);
evalcond[2]=((((-1.0)*gconst75*x280))+new_r11);
evalcond[3]=((((-1.0)*gconst75*x281))+new_r10);
evalcond[4]=(((x278*x282))+new_r01);
evalcond[5]=(((x279*x282))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x283))+(((-1.0)*x281))+((gconst75*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x283))+(((-1.0)*x280))+((gconst75*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x284=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x284.valid){
continue;
}
if((x284.value) < -0.00001)
continue;
IkReal gconst75=IKsqrt(x284.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst75)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
sj2=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75)))))));
cj2=gconst75;
if( (gconst75) < -1-IKFAST_SINCOS_THRESH || (gconst75) > 1+IKFAST_SINCOS_THRESH )
    continue;
j2=((-1.0)*(IKacos(gconst75)));
CheckValue<IkReal> x285=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x285.valid){
continue;
}
if((x285.value) < -0.00001)
continue;
IkReal gconst75=IKsqrt(x285.value);
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
CheckValue<IkReal> x286=IKPowWithIntegerCheck(gconst75,-1);
if(!x286.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75))))))))+((gconst75*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x286.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75))))))))+((gconst75*new_r10))))+IKsqr((new_r11*(x286.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75))))))))+((gconst75*new_r10))), (new_r11*(x286.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x287=IKcos(j4);
IkReal x288=IKsin(j4);
IkReal x289=((1.0)*x287);
IkReal x290=((1.0)*x288);
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
IkReal x291=IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75)))));
evalcond[0]=x288;
evalcond[1]=((-1.0)*x287);
evalcond[2]=((((-1.0)*gconst75*x289))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*gconst75*x290)));
evalcond[4]=((((-1.0)*x289*x291))+new_r01);
evalcond[5]=((((-1.0)*x290*x291))+new_r00);
evalcond[6]=((((-1.0)*x290))+((new_r00*x291))+((gconst75*new_r10)));
evalcond[7]=(((new_r01*x291))+(((-1.0)*x289))+((gconst75*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x292 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x292.valid){
continue;
}
CheckValue<IkReal> x293=IKPowWithIntegerCheck(IKsign(gconst75),-1);
if(!x293.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x292.value)+(((1.5707963267949)*(x293.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x294=IKcos(j4);
IkReal x295=IKsin(j4);
IkReal x296=((1.0)*x294);
IkReal x297=((1.0)*x295);
if((((1.0)+(((-1.0)*(gconst75*gconst75))))) < -0.00001)
continue;
IkReal x298=IKsqrt(((1.0)+(((-1.0)*(gconst75*gconst75)))));
evalcond[0]=x295;
evalcond[1]=((-1.0)*x294);
evalcond[2]=(new_r11+(((-1.0)*gconst75*x296)));
evalcond[3]=(new_r10+(((-1.0)*gconst75*x297)));
evalcond[4]=((((-1.0)*x296*x298))+new_r01);
evalcond[5]=((((-1.0)*x297*x298))+new_r00);
evalcond[6]=((((-1.0)*x297))+((new_r00*x298))+((gconst75*new_r10)));
evalcond[7]=((((-1.0)*x296))+((new_r01*x298))+((gconst75*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x299=new_r22*new_r22;
CheckValue<IkReal> x300=IKPowWithIntegerCheck((((cj2*x299))+(((-1.0)*cj2))),-1);
if(!x300.valid){
continue;
}
CheckValue<IkReal> x301=IKPowWithIntegerCheck(((((-1.0)*sj2))+((sj2*x299))),-1);
if(!x301.valid){
continue;
}
if( IKabs(((x300.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x301.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x300.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x301.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x300.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x301.value)*((((new_r10*new_r22))+new_r01))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x302=IKsin(j4);
IkReal x303=IKcos(j4);
IkReal x304=(cj2*new_r01);
IkReal x305=(new_r10*sj2);
IkReal x306=((1.0)*sj2);
IkReal x307=(cj2*new_r00);
IkReal x308=(new_r22*sj2);
IkReal x309=((1.0)*x303);
IkReal x310=(new_r22*x302);
IkReal x311=((1.0)*x302);
evalcond[0]=(((new_r11*sj2))+x304+x310);
evalcond[1]=(((new_r11*x308))+((new_r22*x304))+x302);
evalcond[2]=((((-1.0)*x311))+((cj2*new_r10))+(((-1.0)*new_r00*x306)));
evalcond[3]=((((-1.0)*new_r01*x306))+((cj2*new_r11))+(((-1.0)*x309)));
evalcond[4]=(((sj2*x303))+((cj2*x310))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x309))+x307+x305);
evalcond[6]=((((-1.0)*cj2*new_r22*x309))+((sj2*x302))+new_r00);
evalcond[7]=((((-1.0)*cj2*x309))+((x302*x308))+new_r11);
evalcond[8]=(((new_r22*x305))+((new_r22*x307))+(((-1.0)*x309)));
evalcond[9]=((((-1.0)*new_r22*x303*x306))+new_r10+(((-1.0)*cj2*x311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x312=((1.0)*new_r01);
CheckValue<IkReal> x313=IKPowWithIntegerCheck(new_r22,-1);
if(!x313.valid){
continue;
}
if( IKabs(((x313.value)*(((((-1.0)*new_r11*sj2))+(((-1.0)*cj2*x312)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj2*x312))+((cj2*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x313.value)*(((((-1.0)*new_r11*sj2))+(((-1.0)*cj2*x312))))))+IKsqr(((((-1.0)*sj2*x312))+((cj2*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x313.value)*(((((-1.0)*new_r11*sj2))+(((-1.0)*cj2*x312))))), ((((-1.0)*sj2*x312))+((cj2*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x314=IKsin(j4);
IkReal x315=IKcos(j4);
IkReal x316=(cj2*new_r01);
IkReal x317=(new_r10*sj2);
IkReal x318=((1.0)*sj2);
IkReal x319=(cj2*new_r00);
IkReal x320=(new_r22*sj2);
IkReal x321=((1.0)*x315);
IkReal x322=(new_r22*x314);
IkReal x323=((1.0)*x314);
evalcond[0]=(((new_r11*sj2))+x322+x316);
evalcond[1]=(x314+((new_r22*x316))+((new_r11*x320)));
evalcond[2]=((((-1.0)*new_r00*x318))+(((-1.0)*x323))+((cj2*new_r10)));
evalcond[3]=((((-1.0)*x321))+((cj2*new_r11))+(((-1.0)*new_r01*x318)));
evalcond[4]=(((cj2*x322))+((sj2*x315))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x321))+x319+x317);
evalcond[6]=((((-1.0)*cj2*new_r22*x321))+((sj2*x314))+new_r00);
evalcond[7]=((((-1.0)*cj2*x321))+((x314*x320))+new_r11);
evalcond[8]=((((-1.0)*x321))+((new_r22*x317))+((new_r22*x319)));
evalcond[9]=((((-1.0)*cj2*x323))+new_r10+(((-1.0)*new_r22*x315*x318)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x324=cj2*cj2;
IkReal x325=(cj2*new_r22);
CheckValue<IkReal> x326 = IKatan2WithCheck(IkReal((((new_r01*x325))+((new_r00*sj2)))),IkReal((((new_r01*sj2))+(((-1.0)*new_r00*x325)))),IKFAST_ATAN2_MAGTHRESH);
if(!x326.valid){
continue;
}
CheckValue<IkReal> x327=IKPowWithIntegerCheck(IKsign(((-1.0)+x324+(((-1.0)*x324*(new_r22*new_r22))))),-1);
if(!x327.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x326.value)+(((1.5707963267949)*(x327.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x328=IKsin(j4);
IkReal x329=IKcos(j4);
IkReal x330=(cj2*new_r01);
IkReal x331=(new_r10*sj2);
IkReal x332=((1.0)*sj2);
IkReal x333=(cj2*new_r00);
IkReal x334=(new_r22*sj2);
IkReal x335=((1.0)*x329);
IkReal x336=(new_r22*x328);
IkReal x337=((1.0)*x328);
evalcond[0]=(((new_r11*sj2))+x330+x336);
evalcond[1]=(((new_r22*x330))+((new_r11*x334))+x328);
evalcond[2]=((((-1.0)*new_r00*x332))+((cj2*new_r10))+(((-1.0)*x337)));
evalcond[3]=(((cj2*new_r11))+(((-1.0)*x335))+(((-1.0)*new_r01*x332)));
evalcond[4]=(((cj2*x336))+((sj2*x329))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x335))+x333+x331);
evalcond[6]=((((-1.0)*cj2*new_r22*x335))+((sj2*x328))+new_r00);
evalcond[7]=(((x328*x334))+new_r11+(((-1.0)*cj2*x335)));
evalcond[8]=(((new_r22*x331))+((new_r22*x333))+(((-1.0)*x335)));
evalcond[9]=((((-1.0)*new_r22*x329*x332))+new_r10+(((-1.0)*cj2*x337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x339=IKPowWithIntegerCheck(sj3,-1);
if(!x339.valid){
continue;
}
IkReal x338=x339.value;
CheckValue<IkReal> x340=IKPowWithIntegerCheck(new_r12,-1);
if(!x340.valid){
continue;
}
if( IKabs((x338*(x340.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x338)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x338*(x340.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))))+IKsqr((new_r02*x338))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x338*(x340.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))), (new_r02*x338));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x341=IKcos(j2);
IkReal x342=IKsin(j2);
IkReal x343=((1.0)*sj3);
IkReal x344=((1.0)*cj3);
IkReal x345=(new_r02*x341);
IkReal x346=(new_r12*x342);
IkReal x347=(x342*x343);
evalcond[0]=((((-1.0)*x341*x343))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x347)));
evalcond[2]=(((new_r12*x341))+(((-1.0)*new_r02*x342)));
evalcond[3]=(x346+x345+(((-1.0)*x343)));
evalcond[4]=((((-1.0)*new_r22*x343))+((cj3*x346))+((cj3*x345)));
evalcond[5]=((((-1.0)*new_r10*x347))+(((-1.0)*new_r00*x341*x343))+(((-1.0)*new_r20*x344)));
evalcond[6]=((((-1.0)*new_r11*x347))+(((-1.0)*new_r21*x344))+(((-1.0)*new_r01*x341*x343)));
evalcond[7]=((1.0)+(((-1.0)*x343*x345))+(((-1.0)*x343*x346))+(((-1.0)*new_r22*x344)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj2;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=cj2;
j4eval[1]=cj3;
j4eval[2]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
j4eval[1]=IKsign(cj3);
j4eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x348=IKsin(j4);
IkReal x349=((1.0)*(IKcos(j4)));
evalcond[0]=(x348+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x349)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x348)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x350=IKcos(j4);
IkReal x351=((1.0)*(IKsin(j4)));
evalcond[0]=(x350+new_r10);
evalcond[1]=((((-1.0)*x351))+new_r11);
evalcond[2]=((((-1.0)*x351))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x350))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x352=IKcos(j4);
IkReal x353=((1.0)*(IKsin(j4)));
evalcond[0]=(x352+new_r20);
evalcond[1]=((((-1.0)*x353))+new_r21);
evalcond[2]=((((-1.0)*x353))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x352))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x354=IKsin(j4);
IkReal x355=((1.0)*(IKcos(j4)));
evalcond[0]=(x354+new_r21);
evalcond[1]=((((-1.0)*x355))+new_r20);
evalcond[2]=((((-1.0)*x354))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x355))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x356=IKsin(j4);
IkReal x357=IKcos(j4);
IkReal x358=((-1.0)*x357);
evalcond[0]=x356;
evalcond[1]=(new_r22*x356);
evalcond[2]=x358;
evalcond[3]=(new_r22*x358);
evalcond[4]=((((-1.0)*x356))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x357))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x359=IKPowWithIntegerCheck(sj3,-1);
if(!x359.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x359.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x359.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x359.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x360=IKsin(j4);
IkReal x361=IKcos(j4);
IkReal x362=((1.0)*sj3);
IkReal x363=((1.0)*x361);
evalcond[0]=(((sj3*x361))+new_r20);
evalcond[1]=(new_r11+((cj3*x360)));
evalcond[2]=((((-1.0)*x360*x362))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj3*x363)));
evalcond[4]=((((-1.0)*x360))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x363))+(((-1.0)*new_r01)));
evalcond[6]=(x360+((cj3*new_r11))+(((-1.0)*new_r21*x362)));
evalcond[7]=((((-1.0)*new_r20*x362))+(((-1.0)*x363))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x364=IKPowWithIntegerCheck(IKsign(cj3),-1);
if(!x364.valid){
continue;
}
CheckValue<IkReal> x365 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x365.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x364.value)))+(x365.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x366=IKsin(j4);
IkReal x367=IKcos(j4);
IkReal x368=((1.0)*sj3);
IkReal x369=((1.0)*x367);
evalcond[0]=(((sj3*x367))+new_r20);
evalcond[1]=(new_r11+((cj3*x366)));
evalcond[2]=((((-1.0)*x366*x368))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj3*x369)));
evalcond[4]=((((-1.0)*x366))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x369))+(((-1.0)*new_r01)));
evalcond[6]=(x366+((cj3*new_r11))+(((-1.0)*new_r21*x368)));
evalcond[7]=((((-1.0)*new_r20*x368))+(((-1.0)*x369))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x370.valid){
continue;
}
CheckValue<IkReal> x371 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x371.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x370.value)))+(x371.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x372=IKsin(j4);
IkReal x373=IKcos(j4);
IkReal x374=((1.0)*sj3);
IkReal x375=((1.0)*x373);
evalcond[0]=(((sj3*x373))+new_r20);
evalcond[1]=(new_r11+((cj3*x372)));
evalcond[2]=((((-1.0)*x372*x374))+new_r21);
evalcond[3]=((((-1.0)*cj3*x375))+new_r10);
evalcond[4]=((((-1.0)*x372))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x375))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x374))+x372+((cj3*new_r11)));
evalcond[7]=((((-1.0)*new_r20*x374))+(((-1.0)*x375))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x376=IKcos(j4);
IkReal x377=IKsin(j4);
IkReal x378=((1.0)*sj3);
IkReal x379=((1.0)*new_r11);
IkReal x380=((1.0)*new_r10);
IkReal x381=((1.0)*x376);
evalcond[0]=(((sj3*x376))+new_r20);
evalcond[1]=((((-1.0)*x377))+new_r00);
evalcond[2]=((((-1.0)*x381))+new_r01);
evalcond[3]=((((-1.0)*x377*x378))+new_r21);
evalcond[4]=((((-1.0)*x379))+((cj3*x377)));
evalcond[5]=((((-1.0)*x380))+(((-1.0)*cj3*x381)));
evalcond[6]=((((-1.0)*new_r21*x378))+x377+(((-1.0)*cj3*x379)));
evalcond[7]=((((-1.0)*new_r20*x378))+(((-1.0)*x381))+(((-1.0)*cj3*x380)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x382=IKcos(j4);
IkReal x383=IKsin(j4);
IkReal x384=((1.0)*sj2);
IkReal x385=((1.0)*cj2);
IkReal x386=((1.0)*x383);
evalcond[0]=(x382+new_r20);
evalcond[1]=((((-1.0)*x386))+new_r21);
evalcond[2]=(new_r01+((sj2*x382)));
evalcond[3]=(new_r00+((sj2*x383)));
evalcond[4]=(new_r11+(((-1.0)*x382*x385)));
evalcond[5]=(new_r10+(((-1.0)*x383*x385)));
evalcond[6]=((((-1.0)*new_r00*x384))+((cj2*new_r10))+(((-1.0)*x386)));
evalcond[7]=((((-1.0)*new_r01*x384))+(((-1.0)*x382))+((cj2*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x387=IKcos(j4);
IkReal x388=IKsin(j4);
IkReal x389=((1.0)*sj2);
IkReal x390=((1.0)*x387);
IkReal x391=((1.0)*x388);
evalcond[0]=(x388+new_r21);
evalcond[1]=((((-1.0)*x390))+new_r20);
evalcond[2]=(new_r01+((sj2*x387)));
evalcond[3]=(new_r00+((sj2*x388)));
evalcond[4]=((((-1.0)*cj2*x390))+new_r11);
evalcond[5]=((((-1.0)*cj2*x391))+new_r10);
evalcond[6]=((((-1.0)*x391))+(((-1.0)*new_r00*x389))+((cj2*new_r10)));
evalcond[7]=((((-1.0)*x390))+(((-1.0)*new_r01*x389))+((cj2*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x392=((1.0)*sj2);
if( IKabs(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x392)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x392))+((cj2*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x392))))+IKsqr(((((-1.0)*new_r01*x392))+((cj2*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj2*new_r01))+(((-1.0)*new_r00*x392))), ((((-1.0)*new_r01*x392))+((cj2*new_r00))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x393=IKsin(j4);
IkReal x394=IKcos(j4);
IkReal x395=((1.0)*sj2);
IkReal x396=((1.0)*x394);
IkReal x397=(sj2*x393);
IkReal x398=(cj2*x393);
IkReal x399=(cj2*x396);
evalcond[0]=(((new_r11*sj2))+x393+((cj2*new_r01)));
evalcond[1]=(x398+((sj2*x394))+new_r01);
evalcond[2]=((((-1.0)*x396))+((new_r10*sj2))+((cj2*new_r00)));
evalcond[3]=((((-1.0)*x393))+((cj2*new_r10))+(((-1.0)*new_r00*x395)));
evalcond[4]=((((-1.0)*new_r01*x395))+(((-1.0)*x396))+((cj2*new_r11)));
evalcond[5]=((((-1.0)*x399))+x397+new_r00);
evalcond[6]=((((-1.0)*x399))+x397+new_r11);
evalcond[7]=((((-1.0)*x398))+(((-1.0)*x394*x395))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x400=((1.0)*new_r00);
if( IKabs((((cj2*new_r01))+(((-1.0)*sj2*x400)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x400)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*new_r01))+(((-1.0)*sj2*x400))))+IKsqr(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x400))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj2*new_r01))+(((-1.0)*sj2*x400))), ((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x400))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x401=IKcos(j4);
IkReal x402=IKsin(j4);
IkReal x403=((1.0)*sj2);
IkReal x404=((1.0)*cj2);
IkReal x405=((1.0)*x402);
IkReal x406=(sj2*x401);
IkReal x407=(x402*x404);
evalcond[0]=(((new_r10*sj2))+x401+((cj2*new_r00)));
evalcond[1]=(((new_r11*sj2))+((cj2*new_r01))+(((-1.0)*x405)));
evalcond[2]=(((sj2*x402))+new_r00+((cj2*x401)));
evalcond[3]=(((cj2*new_r10))+(((-1.0)*new_r00*x403))+(((-1.0)*x405)));
evalcond[4]=(((cj2*new_r11))+(((-1.0)*new_r01*x403))+(((-1.0)*x401)));
evalcond[5]=(x406+new_r01+(((-1.0)*x407)));
evalcond[6]=(x406+new_r10+(((-1.0)*x407)));
evalcond[7]=((((-1.0)*x402*x403))+(((-1.0)*x401*x404))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x408=IKcos(j4);
IkReal x409=IKsin(j4);
IkReal x410=((1.0)*sj3);
IkReal x411=((1.0)*x408);
evalcond[0]=(((sj3*x408))+new_r20);
evalcond[1]=(new_r10+(((-1.0)*x409)));
evalcond[2]=(new_r11+(((-1.0)*x411)));
evalcond[3]=(new_r01+((cj3*x409)));
evalcond[4]=(new_r21+(((-1.0)*x409*x410)));
evalcond[5]=((((-1.0)*cj3*x411))+new_r00);
evalcond[6]=(x409+(((-1.0)*new_r21*x410))+((cj3*new_r01)));
evalcond[7]=((((-1.0)*new_r20*x410))+((cj3*new_r00))+(((-1.0)*x411)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x412=IKcos(j4);
IkReal x413=((1.0)*(IKsin(j4)));
evalcond[0]=(x412+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x413)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x413)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x412)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x414=IKsin(j4);
IkReal x415=((1.0)*(IKcos(j4)));
evalcond[0]=(x414+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x415)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x414)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x415)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x416=IKsin(j4);
IkReal x417=((1.0)*(IKcos(j4)));
evalcond[0]=(x416+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x416)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x417)));
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x417)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x418=IKcos(j4);
IkReal x419=((1.0)*(IKsin(j4)));
evalcond[0]=(x418+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x419)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x418)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x419)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x420=IKsin(j4);
IkReal x421=IKcos(j4);
IkReal x422=((-1.0)*x421);
evalcond[0]=x420;
evalcond[1]=(new_r22*x420);
evalcond[2]=x422;
evalcond[3]=(new_r22*x422);
evalcond[4]=((((-1.0)*x420))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x421))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x423=IKPowWithIntegerCheck(cj3,-1);
if(!x423.valid){
continue;
}
CheckValue<IkReal> x424=IKPowWithIntegerCheck(sj3,-1);
if(!x424.valid){
continue;
}
if( IKabs((new_r01*(x423.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x424.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x423.value)))+IKsqr(((-1.0)*new_r20*(x424.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r01*(x423.value)), ((-1.0)*new_r20*(x424.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x425=IKsin(j4);
IkReal x426=IKcos(j4);
IkReal x427=((1.0)*new_r00);
IkReal x428=((1.0)*sj3);
IkReal x429=((1.0)*new_r01);
IkReal x430=((1.0)*x426);
evalcond[0]=(((sj3*x426))+new_r20);
evalcond[1]=((((-1.0)*x425*x428))+new_r21);
evalcond[2]=((((-1.0)*x425))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x430))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x429))+((cj3*x425)));
evalcond[5]=((((-1.0)*cj3*x430))+(((-1.0)*x427)));
evalcond[6]=((((-1.0)*cj3*x429))+x425+(((-1.0)*new_r21*x428)));
evalcond[7]=((((-1.0)*x430))+(((-1.0)*cj3*x427))+(((-1.0)*new_r20*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x431=IKPowWithIntegerCheck(sj3,-1);
if(!x431.valid){
continue;
}
if( IKabs((new_r21*(x431.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x431.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r21*(x431.value)), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x432=IKsin(j4);
IkReal x433=IKcos(j4);
IkReal x434=((1.0)*new_r00);
IkReal x435=((1.0)*sj3);
IkReal x436=((1.0)*new_r01);
IkReal x437=((1.0)*x433);
evalcond[0]=(((sj3*x433))+new_r20);
evalcond[1]=((((-1.0)*x432*x435))+new_r21);
evalcond[2]=((((-1.0)*x432))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x437))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x436))+((cj3*x432)));
evalcond[5]=((((-1.0)*cj3*x437))+(((-1.0)*x434)));
evalcond[6]=((((-1.0)*cj3*x436))+x432+(((-1.0)*new_r21*x435)));
evalcond[7]=((((-1.0)*cj3*x434))+(((-1.0)*x437))+(((-1.0)*new_r20*x435)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x438.valid){
continue;
}
CheckValue<IkReal> x439 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x439.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x438.value)))+(x439.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x440=IKsin(j4);
IkReal x441=IKcos(j4);
IkReal x442=((1.0)*new_r00);
IkReal x443=((1.0)*sj3);
IkReal x444=((1.0)*new_r01);
IkReal x445=((1.0)*x441);
evalcond[0]=(((sj3*x441))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x440*x443)));
evalcond[2]=((((-1.0)*x440))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x445))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x444))+((cj3*x440)));
evalcond[5]=((((-1.0)*x442))+(((-1.0)*cj3*x445)));
evalcond[6]=((((-1.0)*cj3*x444))+x440+(((-1.0)*new_r21*x443)));
evalcond[7]=((((-1.0)*x445))+(((-1.0)*cj3*x442))+(((-1.0)*new_r20*x443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x447=IKPowWithIntegerCheck(sj3,-1);
if(!x447.valid){
continue;
}
IkReal x446=x447.value;
CheckValue<IkReal> x448=IKPowWithIntegerCheck(cj2,-1);
if(!x448.valid){
continue;
}
CheckValue<IkReal> x449=IKPowWithIntegerCheck(cj3,-1);
if(!x449.valid){
continue;
}
if( IKabs((x446*(x448.value)*(x449.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x446)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x446*(x448.value)*(x449.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))))+IKsqr(((-1.0)*new_r20*x446))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x446*(x448.value)*(x449.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))), ((-1.0)*new_r20*x446));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x450=IKsin(j4);
IkReal x451=IKcos(j4);
IkReal x452=(cj2*new_r01);
IkReal x453=(new_r10*sj2);
IkReal x454=((1.0)*sj3);
IkReal x455=((1.0)*sj2);
IkReal x456=(new_r11*sj2);
IkReal x457=(cj2*new_r00);
IkReal x458=((1.0)*x451);
IkReal x459=(sj2*x450);
IkReal x460=(cj2*x450);
evalcond[0]=(((sj3*x451))+new_r20);
evalcond[1]=((((-1.0)*x450*x454))+new_r21);
evalcond[2]=(((cj3*x450))+x456+x452);
evalcond[3]=((((-1.0)*x450))+(((-1.0)*new_r00*x455))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x455))+(((-1.0)*x458))+((cj2*new_r11)));
evalcond[5]=(((sj2*x451))+((cj3*x460))+new_r01);
evalcond[6]=(x457+x453+(((-1.0)*cj3*x458)));
evalcond[7]=(x459+new_r00+(((-1.0)*cj2*cj3*x458)));
evalcond[8]=(((cj3*x459))+new_r11+(((-1.0)*cj2*x458)));
evalcond[9]=((((-1.0)*cj3*x451*x455))+(((-1.0)*x460))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x454))+((cj3*x456))+((cj3*x452))+x450);
evalcond[11]=((((-1.0)*new_r20*x454))+((cj3*x457))+((cj3*x453))+(((-1.0)*x458)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x462=IKPowWithIntegerCheck(sj3,-1);
if(!x462.valid){
continue;
}
IkReal x461=x462.value;
CheckValue<IkReal> x463=IKPowWithIntegerCheck(sj2,-1);
if(!x463.valid){
continue;
}
if( IKabs((x461*(x463.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x461)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x461*(x463.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))))+IKsqr(((-1.0)*new_r20*x461))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x461*(x463.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))), ((-1.0)*new_r20*x461));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x464=IKsin(j4);
IkReal x465=IKcos(j4);
IkReal x466=(cj2*new_r01);
IkReal x467=(new_r10*sj2);
IkReal x468=((1.0)*sj3);
IkReal x469=((1.0)*sj2);
IkReal x470=(new_r11*sj2);
IkReal x471=(cj2*new_r00);
IkReal x472=((1.0)*x465);
IkReal x473=(sj2*x464);
IkReal x474=(cj2*x464);
evalcond[0]=(((sj3*x465))+new_r20);
evalcond[1]=((((-1.0)*x464*x468))+new_r21);
evalcond[2]=(((cj3*x464))+x466+x470);
evalcond[3]=((((-1.0)*x464))+(((-1.0)*new_r00*x469))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*x472))+(((-1.0)*new_r01*x469))+((cj2*new_r11)));
evalcond[5]=(((cj3*x474))+new_r01+((sj2*x465)));
evalcond[6]=(x467+x471+(((-1.0)*cj3*x472)));
evalcond[7]=(x473+new_r00+(((-1.0)*cj2*cj3*x472)));
evalcond[8]=(((cj3*x473))+new_r11+(((-1.0)*cj2*x472)));
evalcond[9]=((((-1.0)*cj3*x465*x469))+(((-1.0)*x474))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x468))+((cj3*x470))+((cj3*x466))+x464);
evalcond[11]=((((-1.0)*new_r20*x468))+((cj3*x471))+(((-1.0)*x472))+((cj3*x467)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x475=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x475.valid){
continue;
}
CheckValue<IkReal> x476 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x476.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x475.value)))+(x476.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x477=IKsin(j4);
IkReal x478=IKcos(j4);
IkReal x479=(cj2*new_r01);
IkReal x480=(new_r10*sj2);
IkReal x481=((1.0)*sj3);
IkReal x482=((1.0)*sj2);
IkReal x483=(new_r11*sj2);
IkReal x484=(cj2*new_r00);
IkReal x485=((1.0)*x478);
IkReal x486=(sj2*x477);
IkReal x487=(cj2*x477);
evalcond[0]=(new_r20+((sj3*x478)));
evalcond[1]=((((-1.0)*x477*x481))+new_r21);
evalcond[2]=(((cj3*x477))+x483+x479);
evalcond[3]=((((-1.0)*new_r00*x482))+(((-1.0)*x477))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x482))+(((-1.0)*x485))+((cj2*new_r11)));
evalcond[5]=(((cj3*x487))+new_r01+((sj2*x478)));
evalcond[6]=((((-1.0)*cj3*x485))+x480+x484);
evalcond[7]=((((-1.0)*cj2*cj3*x485))+x486+new_r00);
evalcond[8]=(((cj3*x486))+(((-1.0)*cj2*x485))+new_r11);
evalcond[9]=((((-1.0)*cj3*x478*x482))+(((-1.0)*x487))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x481))+((cj3*x483))+((cj3*x479))+x477);
evalcond[11]=(((cj3*x480))+((cj3*x484))+(((-1.0)*x485))+(((-1.0)*new_r20*x481)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x488=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x488.valid){
continue;
}
CheckValue<IkReal> x489 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x489.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x488.value)))+(x489.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((sj3*(IKcos(j4))))+new_r20);
evalcond[1]=((((-1.0)*sj3*(IKsin(j4))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=cj4;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x490=IKsin(j2);
IkReal x491=IKcos(j2);
IkReal x492=((1.0)*sj3);
IkReal x493=(new_r02*x491);
IkReal x494=(new_r22*x490);
IkReal x495=(new_r01*x491);
IkReal x496=(new_r22*x491);
IkReal x497=(new_r11*x490);
IkReal x498=(new_r12*x490);
IkReal x499=((1.0)*x490);
IkReal x500=(new_r10*x490);
IkReal x501=(new_r00*x491);
evalcond[0]=(x490+new_r00);
evalcond[1]=(x496+new_r01);
evalcond[2]=(x494+new_r11);
evalcond[3]=((((-1.0)*x491))+new_r10);
evalcond[4]=((((-1.0)*x491*x492))+new_r02);
evalcond[5]=((((-1.0)*x490*x492))+new_r12);
evalcond[6]=(x500+x501);
evalcond[7]=((((-1.0)*new_r02*x499))+((new_r12*x491)));
evalcond[8]=((((-1.0)*new_r01*x499))+((new_r11*x491)));
evalcond[9]=(x497+x495+new_r22);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x499))+((new_r10*x491)));
evalcond[11]=(((new_r10*x494))+((new_r00*x496)));
evalcond[12]=((((-1.0)*x492))+x498+x493);
evalcond[13]=((((-1.0)*x492*x501))+(((-1.0)*x492*x500)));
evalcond[14]=(((new_r12*x494))+((new_r22*x493))+(((-1.0)*new_r22*x492)));
evalcond[15]=((((-1.0)*cj3*new_r21))+(((-1.0)*x492*x497))+(((-1.0)*x492*x495)));
evalcond[16]=((1.0)+(((-1.0)*sj3*x492))+((new_r11*x494))+((new_r22*x495)));
evalcond[17]=((1.0)+(((-1.0)*(new_r22*new_r22)))+(((-1.0)*x492*x493))+(((-1.0)*x492*x498)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x502=IKcos(j2);
IkReal x503=IKsin(j2);
IkReal x504=((1.0)*sj3);
IkReal x505=((1.0)*new_r22);
IkReal x506=(new_r02*x502);
IkReal x507=(new_r01*x502);
IkReal x508=(new_r00*x502);
IkReal x509=(new_r22*x503);
IkReal x510=(new_r12*x503);
IkReal x511=((1.0)*x503);
IkReal x512=(new_r11*x503);
IkReal x513=(new_r10*x503);
evalcond[0]=(x502+new_r10);
evalcond[1]=(new_r00+(((-1.0)*x511)));
evalcond[2]=((((-1.0)*x502*x504))+new_r02);
evalcond[3]=((((-1.0)*x503*x504))+new_r12);
evalcond[4]=((((-1.0)*x502*x505))+new_r01);
evalcond[5]=((((-1.0)*x503*x505))+new_r11);
evalcond[6]=(x508+x513);
evalcond[7]=(((new_r12*x502))+(((-1.0)*new_r02*x511)));
evalcond[8]=(((new_r11*x502))+(((-1.0)*new_r01*x511)));
evalcond[9]=((1.0)+((new_r10*x502))+(((-1.0)*new_r00*x511)));
evalcond[10]=(((new_r22*x508))+((new_r10*x509)));
evalcond[11]=((((-1.0)*x504))+x506+x510);
evalcond[12]=((((-1.0)*x505))+x507+x512);
evalcond[13]=((((-1.0)*x504*x513))+(((-1.0)*x504*x508)));
evalcond[14]=(((new_r22*x506))+((new_r12*x509))+(((-1.0)*new_r22*x504)));
evalcond[15]=((-1.0)+(sj3*sj3)+((new_r22*x507))+((new_r11*x509)));
evalcond[16]=((((-1.0)*x504*x512))+((new_r22*sj3))+(((-1.0)*x504*x507)));
evalcond[17]=((1.0)+(((-1.0)*x504*x510))+(((-1.0)*x504*x506))+(((-1.0)*new_r22*x505)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x514=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x514))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x514)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x514))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x514))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*cj4*x514))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x514))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x515=IKsin(j2);
IkReal x516=IKcos(j2);
IkReal x517=((1.0)*cj4);
IkReal x518=(sj4*x515);
IkReal x519=(sj4*x516);
IkReal x520=((1.0)*x515);
IkReal x521=(x516*x517);
evalcond[0]=(((new_r01*x516))+((new_r11*x515))+sj4);
evalcond[1]=(((cj4*x515))+x519+new_r01);
evalcond[2]=((((-1.0)*x521))+x518+new_r00);
evalcond[3]=((((-1.0)*x521))+x518+new_r11);
evalcond[4]=(((new_r00*x516))+((new_r10*x515))+(((-1.0)*x517)));
evalcond[5]=((((-1.0)*x519))+(((-1.0)*x515*x517))+new_r10);
evalcond[6]=(((new_r10*x516))+(((-1.0)*sj4))+(((-1.0)*new_r00*x520)));
evalcond[7]=(((new_r11*x516))+(((-1.0)*new_r01*x520))+(((-1.0)*x517)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x522=((1.0)*cj4);
if( IKabs(((((-1.0)*new_r01*x522))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x522)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x522))+(((-1.0)*new_r00*sj4))))+IKsqr((((new_r01*sj4))+(((-1.0)*new_r00*x522))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r01*x522))+(((-1.0)*new_r00*sj4))), (((new_r01*sj4))+(((-1.0)*new_r00*x522))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x523=IKsin(j2);
IkReal x524=IKcos(j2);
IkReal x525=((1.0)*sj4);
IkReal x526=(cj4*x523);
IkReal x527=((1.0)*x524);
IkReal x528=((1.0)*x523);
IkReal x529=(x524*x525);
evalcond[0]=(cj4+((new_r10*x523))+((new_r00*x524)));
evalcond[1]=(((cj4*x524))+new_r00+((sj4*x523)));
evalcond[2]=((((-1.0)*x529))+x526+new_r01);
evalcond[3]=((((-1.0)*x529))+x526+new_r10);
evalcond[4]=(((new_r01*x524))+((new_r11*x523))+(((-1.0)*x525)));
evalcond[5]=((((-1.0)*x523*x525))+new_r11+(((-1.0)*cj4*x527)));
evalcond[6]=((((-1.0)*new_r00*x528))+(((-1.0)*x525))+((new_r10*x524)));
evalcond[7]=(((new_r11*x524))+(((-1.0)*new_r01*x528))+(((-1.0)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x531 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x531.valid){
continue;
}
IkReal x530=x531.value;
j2array[0]=((-1.0)*x530);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x530)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x532=IKcos(j2);
IkReal x533=IKsin(j2);
IkReal x534=(new_r10*x533);
IkReal x535=((1.0)*x533);
IkReal x536=(new_r00*x532);
evalcond[0]=(((new_r01*x532))+((new_r11*x533)));
evalcond[1]=(x534+x536);
evalcond[2]=((((-1.0)*new_r00*x535))+((new_r10*x532)));
evalcond[3]=(((new_r11*x532))+(((-1.0)*new_r01*x535)));
evalcond[4]=(((new_r22*x536))+((new_r22*x534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x538 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x538.valid){
continue;
}
IkReal x537=x538.value;
j2array[0]=((-1.0)*x537);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x537)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x539=IKcos(j2);
IkReal x540=IKsin(j2);
IkReal x541=(new_r11*x540);
IkReal x542=((1.0)*x540);
IkReal x543=(new_r01*x539);
evalcond[0]=(x541+x543);
evalcond[1]=((((-1.0)*new_r00*x542))+((new_r10*x539)));
evalcond[2]=(((new_r11*x539))+(((-1.0)*new_r01*x542)));
evalcond[3]=(((new_r22*x541))+((new_r22*x543)));
evalcond[4]=(((new_r00*new_r22*x539))+((new_r10*new_r22*x540)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x545 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x545.valid){
continue;
}
IkReal x544=x545.value;
j2array[0]=((-1.0)*x544);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x544)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x546=IKcos(j2);
IkReal x547=IKsin(j2);
IkReal x548=(new_r10*x547);
IkReal x549=((1.0)*x547);
IkReal x550=(new_r00*x546);
evalcond[0]=(x550+x548);
evalcond[1]=((((-1.0)*new_r00*x549))+((new_r10*x546)));
evalcond[2]=(((new_r11*x546))+(((-1.0)*new_r01*x549)));
evalcond[3]=(((new_r11*new_r22*x547))+((new_r01*new_r22*x546)));
evalcond[4]=(((new_r22*x548))+((new_r22*x550)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x552=IKPowWithIntegerCheck(sj3,-1);
if(!x552.valid){
continue;
}
IkReal x551=x552.value;
CheckValue<IkReal> x553=IKPowWithIntegerCheck(cj4,-1);
if(!x553.valid){
continue;
}
if( IKabs((x551*(x553.value)*(((((-1.0)*new_r01*sj3))+(((-1.0)*cj3*new_r02*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x551)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x551*(x553.value)*(((((-1.0)*new_r01*sj3))+(((-1.0)*cj3*new_r02*sj4))))))+IKsqr((new_r02*x551))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x551*(x553.value)*(((((-1.0)*new_r01*sj3))+(((-1.0)*cj3*new_r02*sj4))))), (new_r02*x551));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x554=IKcos(j2);
IkReal x555=IKsin(j2);
IkReal x556=((1.0)*cj4);
IkReal x557=((1.0)*sj3);
IkReal x558=((1.0)*sj4);
IkReal x559=(cj3*sj4);
IkReal x560=((1.0)*cj3);
IkReal x561=(new_r01*x554);
IkReal x562=(new_r02*x554);
IkReal x563=(new_r11*x555);
IkReal x564=(cj4*x554);
IkReal x565=((1.0)*x555);
IkReal x566=(cj4*x555);
IkReal x567=(new_r10*x555);
IkReal x568=(new_r00*x554);
IkReal x569=(new_r12*x555);
evalcond[0]=((((-1.0)*x554*x557))+new_r02);
evalcond[1]=((((-1.0)*x555*x557))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x565))+((new_r12*x554)));
evalcond[3]=(((x554*x559))+x566+new_r01);
evalcond[4]=((((-1.0)*x557))+x569+x562);
evalcond[5]=(x559+x563+x561);
evalcond[6]=(((sj4*x555))+(((-1.0)*cj3*x554*x556))+new_r00);
evalcond[7]=((((-1.0)*x554*x556))+((x555*x559))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x565))+((new_r10*x554))+(((-1.0)*x558)));
evalcond[9]=(((new_r11*x554))+(((-1.0)*x556))+(((-1.0)*new_r01*x565)));
evalcond[10]=((((-1.0)*cj3*x556))+x568+x567);
evalcond[11]=((((-1.0)*x554*x558))+(((-1.0)*cj3*x555*x556))+new_r10);
evalcond[12]=((((-1.0)*new_r22*x557))+((cj3*x569))+((cj3*x562)));
evalcond[13]=(sj4+(((-1.0)*new_r21*x557))+((cj3*x563))+((cj3*x561)));
evalcond[14]=((((-1.0)*new_r20*x560))+(((-1.0)*x557*x567))+(((-1.0)*x557*x568)));
evalcond[15]=((((-1.0)*x557*x561))+(((-1.0)*x557*x563))+(((-1.0)*new_r21*x560)));
evalcond[16]=((1.0)+(((-1.0)*x557*x562))+(((-1.0)*x557*x569))+(((-1.0)*new_r22*x560)));
evalcond[17]=(((cj3*x568))+((cj3*x567))+(((-1.0)*x556))+(((-1.0)*new_r20*x557)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x570=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x570.valid){
continue;
}
CheckValue<IkReal> x571 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x571.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x570.value)))+(x571.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x572=IKcos(j2);
IkReal x573=IKsin(j2);
IkReal x574=((1.0)*cj4);
IkReal x575=((1.0)*sj3);
IkReal x576=((1.0)*sj4);
IkReal x577=(cj3*sj4);
IkReal x578=((1.0)*cj3);
IkReal x579=(new_r01*x572);
IkReal x580=(new_r02*x572);
IkReal x581=(new_r11*x573);
IkReal x582=(cj4*x572);
IkReal x583=((1.0)*x573);
IkReal x584=(cj4*x573);
IkReal x585=(new_r10*x573);
IkReal x586=(new_r00*x572);
IkReal x587=(new_r12*x573);
evalcond[0]=(new_r02+(((-1.0)*x572*x575)));
evalcond[1]=((((-1.0)*x573*x575))+new_r12);
evalcond[2]=(((new_r12*x572))+(((-1.0)*new_r02*x583)));
evalcond[3]=(x584+new_r01+((x572*x577)));
evalcond[4]=((((-1.0)*x575))+x580+x587);
evalcond[5]=(x579+x577+x581);
evalcond[6]=((((-1.0)*cj3*x572*x574))+((sj4*x573))+new_r00);
evalcond[7]=(((x573*x577))+new_r11+(((-1.0)*x572*x574)));
evalcond[8]=(((new_r10*x572))+(((-1.0)*x576))+(((-1.0)*new_r00*x583)));
evalcond[9]=((((-1.0)*new_r01*x583))+((new_r11*x572))+(((-1.0)*x574)));
evalcond[10]=((((-1.0)*cj3*x574))+x585+x586);
evalcond[11]=((((-1.0)*cj3*x573*x574))+new_r10+(((-1.0)*x572*x576)));
evalcond[12]=((((-1.0)*new_r22*x575))+((cj3*x580))+((cj3*x587)));
evalcond[13]=(sj4+((cj3*x579))+(((-1.0)*new_r21*x575))+((cj3*x581)));
evalcond[14]=((((-1.0)*new_r20*x578))+(((-1.0)*x575*x585))+(((-1.0)*x575*x586)));
evalcond[15]=((((-1.0)*x575*x579))+(((-1.0)*x575*x581))+(((-1.0)*new_r21*x578)));
evalcond[16]=((1.0)+(((-1.0)*new_r22*x578))+(((-1.0)*x575*x580))+(((-1.0)*x575*x587)));
evalcond[17]=((((-1.0)*x574))+(((-1.0)*new_r20*x575))+((cj3*x586))+((cj3*x585)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x588.valid){
continue;
}
CheckValue<IkReal> x589 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x589.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x588.value)))+(x589.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x590=IKcos(j2);
IkReal x591=IKsin(j2);
IkReal x592=((1.0)*sj3);
IkReal x593=((1.0)*cj3);
IkReal x594=(new_r02*x590);
IkReal x595=(new_r12*x591);
IkReal x596=(x591*x592);
evalcond[0]=((((-1.0)*x590*x592))+new_r02);
evalcond[1]=((((-1.0)*x596))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x591))+((new_r12*x590)));
evalcond[3]=((((-1.0)*x592))+x595+x594);
evalcond[4]=(((cj3*x594))+((cj3*x595))+(((-1.0)*new_r22*x592)));
evalcond[5]=((((-1.0)*new_r00*x590*x592))+(((-1.0)*new_r20*x593))+(((-1.0)*new_r10*x596)));
evalcond[6]=((((-1.0)*new_r21*x593))+(((-1.0)*new_r11*x596))+(((-1.0)*new_r01*x590*x592)));
evalcond[7]=((1.0)+(((-1.0)*x592*x595))+(((-1.0)*x592*x594))+(((-1.0)*new_r22*x593)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj2;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=cj2;
j4eval[1]=cj3;
j4eval[2]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
j4eval[1]=IKsign(cj3);
j4eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x597=IKsin(j4);
IkReal x598=((1.0)*(IKcos(j4)));
evalcond[0]=(x597+new_r11);
evalcond[1]=((((-1.0)*x598))+new_r10);
evalcond[2]=((((-1.0)*x597))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x598))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r12;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x599=IKcos(j4);
IkReal x600=((1.0)*(IKsin(j4)));
evalcond[0]=(x599+new_r10);
evalcond[1]=((((-1.0)*x600))+new_r11);
evalcond[2]=((((-1.0)*x600))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x599))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x601=IKcos(j4);
IkReal x602=((1.0)*(IKsin(j4)));
evalcond[0]=(x601+new_r20);
evalcond[1]=((((-1.0)*x602))+new_r21);
evalcond[2]=((((-1.0)*x602))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x601))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x603=IKsin(j4);
IkReal x604=((1.0)*(IKcos(j4)));
evalcond[0]=(x603+new_r21);
evalcond[1]=((((-1.0)*x604))+new_r20);
evalcond[2]=((((-1.0)*x603))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x604))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x605=IKsin(j4);
IkReal x606=IKcos(j4);
IkReal x607=((-1.0)*x606);
evalcond[0]=x605;
evalcond[1]=(new_r22*x605);
evalcond[2]=x607;
evalcond[3]=(new_r22*x607);
evalcond[4]=((((-1.0)*x605))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x606))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x608=IKPowWithIntegerCheck(sj3,-1);
if(!x608.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x608.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x608.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x608.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x609=IKsin(j4);
IkReal x610=IKcos(j4);
IkReal x611=((1.0)*sj3);
IkReal x612=((1.0)*x610);
evalcond[0]=(((sj3*x610))+new_r20);
evalcond[1]=(((cj3*x609))+new_r11);
evalcond[2]=((((-1.0)*x609*x611))+new_r21);
evalcond[3]=((((-1.0)*cj3*x612))+new_r10);
evalcond[4]=((((-1.0)*x609))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x612))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x611))+x609+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x612))+((cj3*new_r10))+(((-1.0)*new_r20*x611)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x613=IKPowWithIntegerCheck(IKsign(cj3),-1);
if(!x613.valid){
continue;
}
CheckValue<IkReal> x614 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x614.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x613.value)))+(x614.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x615=IKsin(j4);
IkReal x616=IKcos(j4);
IkReal x617=((1.0)*sj3);
IkReal x618=((1.0)*x616);
evalcond[0]=(((sj3*x616))+new_r20);
evalcond[1]=(((cj3*x615))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x615*x617)));
evalcond[3]=((((-1.0)*cj3*x618))+new_r10);
evalcond[4]=((((-1.0)*x615))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x618))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x617))+x615+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x618))+((cj3*new_r10))+(((-1.0)*new_r20*x617)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x619=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x619.valid){
continue;
}
CheckValue<IkReal> x620 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x620.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x619.value)))+(x620.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x621=IKsin(j4);
IkReal x622=IKcos(j4);
IkReal x623=((1.0)*sj3);
IkReal x624=((1.0)*x622);
evalcond[0]=(((sj3*x622))+new_r20);
evalcond[1]=(((cj3*x621))+new_r11);
evalcond[2]=((((-1.0)*x621*x623))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj3*x624)));
evalcond[4]=((((-1.0)*x621))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x624))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x623))+x621+((cj3*new_r11)));
evalcond[7]=((((-1.0)*x624))+((cj3*new_r10))+(((-1.0)*new_r20*x623)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x625=IKcos(j4);
IkReal x626=IKsin(j4);
IkReal x627=((1.0)*sj3);
IkReal x628=((1.0)*new_r11);
IkReal x629=((1.0)*new_r10);
IkReal x630=((1.0)*x625);
evalcond[0]=(((sj3*x625))+new_r20);
evalcond[1]=((((-1.0)*x626))+new_r00);
evalcond[2]=((((-1.0)*x630))+new_r01);
evalcond[3]=((((-1.0)*x626*x627))+new_r21);
evalcond[4]=(((cj3*x626))+(((-1.0)*x628)));
evalcond[5]=((((-1.0)*x629))+(((-1.0)*cj3*x630)));
evalcond[6]=((((-1.0)*new_r21*x627))+x626+(((-1.0)*cj3*x628)));
evalcond[7]=((((-1.0)*x630))+(((-1.0)*new_r20*x627))+(((-1.0)*cj3*x629)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x631=IKcos(j4);
IkReal x632=IKsin(j4);
IkReal x633=((1.0)*sj2);
IkReal x634=((1.0)*cj2);
IkReal x635=((1.0)*x632);
evalcond[0]=(x631+new_r20);
evalcond[1]=((((-1.0)*x635))+new_r21);
evalcond[2]=(((sj2*x631))+new_r01);
evalcond[3]=(((sj2*x632))+new_r00);
evalcond[4]=((((-1.0)*x631*x634))+new_r11);
evalcond[5]=(new_r10+(((-1.0)*x632*x634)));
evalcond[6]=((((-1.0)*new_r00*x633))+(((-1.0)*x635))+((cj2*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x633))+((cj2*new_r11))+(((-1.0)*x631)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x636=IKcos(j4);
IkReal x637=IKsin(j4);
IkReal x638=((1.0)*sj2);
IkReal x639=((1.0)*x636);
IkReal x640=((1.0)*x637);
evalcond[0]=(x637+new_r21);
evalcond[1]=((((-1.0)*x639))+new_r20);
evalcond[2]=(((sj2*x636))+new_r01);
evalcond[3]=(((sj2*x637))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj2*x639)));
evalcond[5]=((((-1.0)*cj2*x640))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x638))+(((-1.0)*x640))+((cj2*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x638))+(((-1.0)*x639))+((cj2*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x641=((1.0)*sj2);
if( IKabs(((((-1.0)*new_r00*x641))+(((-1.0)*cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x641))+((cj2*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x641))+(((-1.0)*cj2*new_r01))))+IKsqr(((((-1.0)*new_r01*x641))+((cj2*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*x641))+(((-1.0)*cj2*new_r01))), ((((-1.0)*new_r01*x641))+((cj2*new_r00))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x642=IKsin(j4);
IkReal x643=IKcos(j4);
IkReal x644=((1.0)*sj2);
IkReal x645=((1.0)*x643);
IkReal x646=(sj2*x642);
IkReal x647=(cj2*x642);
IkReal x648=(cj2*x645);
evalcond[0]=(((new_r11*sj2))+((cj2*new_r01))+x642);
evalcond[1]=(((sj2*x643))+x647+new_r01);
evalcond[2]=(((new_r10*sj2))+(((-1.0)*x645))+((cj2*new_r00)));
evalcond[3]=((((-1.0)*x642))+(((-1.0)*new_r00*x644))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*x645))+(((-1.0)*new_r01*x644))+((cj2*new_r11)));
evalcond[5]=((((-1.0)*x648))+x646+new_r00);
evalcond[6]=((((-1.0)*x648))+x646+new_r11);
evalcond[7]=((((-1.0)*x647))+(((-1.0)*x643*x644))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x649=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj2*x649))+((cj2*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x649)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj2*x649))+((cj2*new_r01))))+IKsqr(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x649))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*sj2*x649))+((cj2*new_r01))), ((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x649))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x650=IKcos(j4);
IkReal x651=IKsin(j4);
IkReal x652=((1.0)*sj2);
IkReal x653=((1.0)*cj2);
IkReal x654=((1.0)*x651);
IkReal x655=(sj2*x650);
IkReal x656=(x651*x653);
evalcond[0]=(((new_r10*sj2))+((cj2*new_r00))+x650);
evalcond[1]=(((new_r11*sj2))+(((-1.0)*x654))+((cj2*new_r01)));
evalcond[2]=(((cj2*x650))+((sj2*x651))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x652))+(((-1.0)*x654))+((cj2*new_r10)));
evalcond[4]=((((-1.0)*x650))+(((-1.0)*new_r01*x652))+((cj2*new_r11)));
evalcond[5]=((((-1.0)*x656))+x655+new_r01);
evalcond[6]=((((-1.0)*x656))+x655+new_r10);
evalcond[7]=((((-1.0)*x651*x652))+(((-1.0)*x650*x653))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x657=IKcos(j4);
IkReal x658=IKsin(j4);
IkReal x659=((1.0)*sj3);
IkReal x660=((1.0)*x657);
evalcond[0]=(((sj3*x657))+new_r20);
evalcond[1]=((((-1.0)*x658))+new_r10);
evalcond[2]=((((-1.0)*x660))+new_r11);
evalcond[3]=(((cj3*x658))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x658*x659)));
evalcond[5]=((((-1.0)*cj3*x660))+new_r00);
evalcond[6]=(x658+((cj3*new_r01))+(((-1.0)*new_r21*x659)));
evalcond[7]=((((-1.0)*new_r20*x659))+(((-1.0)*x660))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
j4eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x661=IKcos(j4);
IkReal x662=((1.0)*(IKsin(j4)));
evalcond[0]=(x661+new_r20);
evalcond[1]=((((-1.0)*x662))+new_r21);
evalcond[2]=((((-1.0)*x662))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x661))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x663=IKsin(j4);
IkReal x664=((1.0)*(IKcos(j4)));
evalcond[0]=(x663+new_r21);
evalcond[1]=((((-1.0)*x664))+new_r20);
evalcond[2]=((((-1.0)*x663))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x664))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x665=IKsin(j4);
IkReal x666=((1.0)*(IKcos(j4)));
evalcond[0]=(x665+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x665))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x666))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x666))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x667=IKcos(j4);
IkReal x668=((1.0)*(IKsin(j4)));
evalcond[0]=(x667+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x668))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x667))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x668))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x669=IKsin(j4);
IkReal x670=IKcos(j4);
IkReal x671=((-1.0)*x670);
evalcond[0]=x669;
evalcond[1]=(new_r22*x669);
evalcond[2]=x671;
evalcond[3]=(new_r22*x671);
evalcond[4]=((((-1.0)*x669))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x670))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x672=IKPowWithIntegerCheck(cj3,-1);
if(!x672.valid){
continue;
}
CheckValue<IkReal> x673=IKPowWithIntegerCheck(sj3,-1);
if(!x673.valid){
continue;
}
if( IKabs((new_r01*(x672.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x673.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x672.value)))+IKsqr(((-1.0)*new_r20*(x673.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r01*(x672.value)), ((-1.0)*new_r20*(x673.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x674=IKsin(j4);
IkReal x675=IKcos(j4);
IkReal x676=((1.0)*new_r00);
IkReal x677=((1.0)*sj3);
IkReal x678=((1.0)*new_r01);
IkReal x679=((1.0)*x675);
evalcond[0]=(((sj3*x675))+new_r20);
evalcond[1]=((((-1.0)*x674*x677))+new_r21);
evalcond[2]=((((-1.0)*x674))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x679)));
evalcond[4]=(((cj3*x674))+(((-1.0)*x678)));
evalcond[5]=((((-1.0)*cj3*x679))+(((-1.0)*x676)));
evalcond[6]=((((-1.0)*cj3*x678))+(((-1.0)*new_r21*x677))+x674);
evalcond[7]=((((-1.0)*cj3*x676))+(((-1.0)*new_r20*x677))+(((-1.0)*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x680=IKPowWithIntegerCheck(sj3,-1);
if(!x680.valid){
continue;
}
if( IKabs((new_r21*(x680.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x680.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r21*(x680.value)), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x681=IKsin(j4);
IkReal x682=IKcos(j4);
IkReal x683=((1.0)*new_r00);
IkReal x684=((1.0)*sj3);
IkReal x685=((1.0)*new_r01);
IkReal x686=((1.0)*x682);
evalcond[0]=(((sj3*x682))+new_r20);
evalcond[1]=((((-1.0)*x681*x684))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x681)));
evalcond[3]=((((-1.0)*x686))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x685))+((cj3*x681)));
evalcond[5]=((((-1.0)*x683))+(((-1.0)*cj3*x686)));
evalcond[6]=((((-1.0)*new_r21*x684))+x681+(((-1.0)*cj3*x685)));
evalcond[7]=((((-1.0)*x686))+(((-1.0)*new_r20*x684))+(((-1.0)*cj3*x683)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x687=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x687.valid){
continue;
}
CheckValue<IkReal> x688 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x688.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x687.value)))+(x688.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x689=IKsin(j4);
IkReal x690=IKcos(j4);
IkReal x691=((1.0)*new_r00);
IkReal x692=((1.0)*sj3);
IkReal x693=((1.0)*new_r01);
IkReal x694=((1.0)*x690);
evalcond[0]=(((sj3*x690))+new_r20);
evalcond[1]=((((-1.0)*x689*x692))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x689)));
evalcond[3]=((((-1.0)*x694))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x693))+((cj3*x689)));
evalcond[5]=((((-1.0)*cj3*x694))+(((-1.0)*x691)));
evalcond[6]=((((-1.0)*cj3*x693))+x689+(((-1.0)*new_r21*x692)));
evalcond[7]=((((-1.0)*cj3*x691))+(((-1.0)*x694))+(((-1.0)*new_r20*x692)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x696=IKPowWithIntegerCheck(sj3,-1);
if(!x696.valid){
continue;
}
IkReal x695=x696.value;
CheckValue<IkReal> x697=IKPowWithIntegerCheck(cj2,-1);
if(!x697.valid){
continue;
}
CheckValue<IkReal> x698=IKPowWithIntegerCheck(cj3,-1);
if(!x698.valid){
continue;
}
if( IKabs((x695*(x697.value)*(x698.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x695)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x695*(x697.value)*(x698.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))))+IKsqr(((-1.0)*new_r20*x695))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x695*(x697.value)*(x698.value)*((((new_r20*sj2))+(((-1.0)*new_r01*sj3))))), ((-1.0)*new_r20*x695));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x699=IKsin(j4);
IkReal x700=IKcos(j4);
IkReal x701=(cj2*new_r01);
IkReal x702=(new_r10*sj2);
IkReal x703=((1.0)*sj3);
IkReal x704=((1.0)*sj2);
IkReal x705=(new_r11*sj2);
IkReal x706=(cj2*new_r00);
IkReal x707=((1.0)*x700);
IkReal x708=(sj2*x699);
IkReal x709=(cj2*x699);
evalcond[0]=(((sj3*x700))+new_r20);
evalcond[1]=((((-1.0)*x699*x703))+new_r21);
evalcond[2]=(((cj3*x699))+x701+x705);
evalcond[3]=(((cj2*new_r10))+(((-1.0)*x699))+(((-1.0)*new_r00*x704)));
evalcond[4]=((((-1.0)*x707))+((cj2*new_r11))+(((-1.0)*new_r01*x704)));
evalcond[5]=(((sj2*x700))+new_r01+((cj3*x709)));
evalcond[6]=((((-1.0)*cj3*x707))+x702+x706);
evalcond[7]=(x708+new_r00+(((-1.0)*cj2*cj3*x707)));
evalcond[8]=((((-1.0)*cj2*x707))+new_r11+((cj3*x708)));
evalcond[9]=((((-1.0)*x709))+(((-1.0)*cj3*x700*x704))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x703))+x699+((cj3*x701))+((cj3*x705)));
evalcond[11]=((((-1.0)*new_r20*x703))+(((-1.0)*x707))+((cj3*x702))+((cj3*x706)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x711=IKPowWithIntegerCheck(sj3,-1);
if(!x711.valid){
continue;
}
IkReal x710=x711.value;
CheckValue<IkReal> x712=IKPowWithIntegerCheck(sj2,-1);
if(!x712.valid){
continue;
}
if( IKabs((x710*(x712.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x710)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x710*(x712.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))))+IKsqr(((-1.0)*new_r20*x710))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x710*(x712.value)*(((((-1.0)*cj2*cj3*new_r20))+(((-1.0)*new_r00*sj3))))), ((-1.0)*new_r20*x710));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x713=IKsin(j4);
IkReal x714=IKcos(j4);
IkReal x715=(cj2*new_r01);
IkReal x716=(new_r10*sj2);
IkReal x717=((1.0)*sj3);
IkReal x718=((1.0)*sj2);
IkReal x719=(new_r11*sj2);
IkReal x720=(cj2*new_r00);
IkReal x721=((1.0)*x714);
IkReal x722=(sj2*x713);
IkReal x723=(cj2*x713);
evalcond[0]=(((sj3*x714))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x713*x717)));
evalcond[2]=(x719+x715+((cj3*x713)));
evalcond[3]=((((-1.0)*x713))+((cj2*new_r10))+(((-1.0)*new_r00*x718)));
evalcond[4]=((((-1.0)*x721))+((cj2*new_r11))+(((-1.0)*new_r01*x718)));
evalcond[5]=(((sj2*x714))+((cj3*x723))+new_r01);
evalcond[6]=((((-1.0)*cj3*x721))+x716+x720);
evalcond[7]=((((-1.0)*cj2*cj3*x721))+x722+new_r00);
evalcond[8]=((((-1.0)*cj2*x721))+((cj3*x722))+new_r11);
evalcond[9]=((((-1.0)*x723))+(((-1.0)*cj3*x714*x718))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x717))+x713+((cj3*x719))+((cj3*x715)));
evalcond[11]=((((-1.0)*new_r20*x717))+(((-1.0)*x721))+((cj3*x720))+((cj3*x716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x724=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x724.valid){
continue;
}
CheckValue<IkReal> x725 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x725.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x724.value)))+(x725.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x726=IKsin(j4);
IkReal x727=IKcos(j4);
IkReal x728=(cj2*new_r01);
IkReal x729=(new_r10*sj2);
IkReal x730=((1.0)*sj3);
IkReal x731=((1.0)*sj2);
IkReal x732=(new_r11*sj2);
IkReal x733=(cj2*new_r00);
IkReal x734=((1.0)*x727);
IkReal x735=(sj2*x726);
IkReal x736=(cj2*x726);
evalcond[0]=(((sj3*x727))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x726*x730)));
evalcond[2]=(((cj3*x726))+x732+x728);
evalcond[3]=((((-1.0)*x726))+((cj2*new_r10))+(((-1.0)*new_r00*x731)));
evalcond[4]=((((-1.0)*x734))+((cj2*new_r11))+(((-1.0)*new_r01*x731)));
evalcond[5]=(((sj2*x727))+((cj3*x736))+new_r01);
evalcond[6]=((((-1.0)*cj3*x734))+x733+x729);
evalcond[7]=(x735+new_r00+(((-1.0)*cj2*cj3*x734)));
evalcond[8]=((((-1.0)*cj2*x734))+((cj3*x735))+new_r11);
evalcond[9]=((((-1.0)*x736))+(((-1.0)*cj3*x727*x731))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x730))+((cj3*x732))+((cj3*x728))+x726);
evalcond[11]=((((-1.0)*new_r20*x730))+(((-1.0)*x734))+((cj3*x733))+((cj3*x729)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - Mitsubishi-PA10 (05a80246cb3ab03e665aa89e4ea2c802)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
