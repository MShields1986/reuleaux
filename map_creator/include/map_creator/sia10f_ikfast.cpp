/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2017-07-11 12:50:04.777966
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42;
x0=IKcos(j[0]);
x1=IKcos(j[2]);
x2=IKsin(j[0]);
x3=IKcos(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKsin(j[5]);
x9=IKcos(j[5]);
x10=IKcos(j[4]);
x11=IKsin(j[4]);
x12=((1.0)*x5);
x13=((0.155)*x0);
x14=((0.36)*x0);
x15=((0.155)*x6);
x16=((1.0)*x0);
x17=((1.0)*x3);
x18=((0.155)*x3);
x19=(x2*x4);
x20=(x5*x7);
x21=(x0*x1);
x22=(x1*x7);
x23=(x6*x7);
x24=(x1*x2);
x25=(x3*x4);
x26=(x4*x7);
x27=(x12*x3);
x28=(x16*x4);
x29=((1.0)*x26);
x30=((((-1.0)*x16*x25))+x24);
x31=(((x21*x3))+x19);
x32=((((-1.0)*x28))+((x24*x3)));
x33=((((-1.0)*x17*x24))+x28);
x34=((((-1.0)*x19))+(((-1.0)*x1*x16*x3)));
x35=(((x17*x6))+((x12*x22)));
x36=(((x1*x16))+((x17*x19)));
x37=(x32*x6);
x38=(x31*x6);
x39=((((-1.0)*x11*x29))+((x10*((((x22*x6))+(((-1.0)*x27)))))));
x40=(((x2*x20))+x37);
x41=(((x10*((((x0*x20))+x38))))+((x11*x30)));
x42=((((1.0)*x11*x36))+(((-1.0)*x10*x40)));
eerot[0]=(((x41*x9))+((x8*((((x0*x23))+((x34*x5)))))));
eerot[1]=(((x41*x8))+((x9*(((((-1.0)*x12*x34))+(((-1.0)*x16*x23)))))));
eerot[2]=(((x10*x30))+((x11*(((((-1.0)*x38))+(((-1.0)*x0*x12*x7)))))));
IkReal x43=((1.0)*x13);
eetrans[0]=((((0.36)*x24))+((x11*(((((-1.0)*x20*x43))+(((-1.0)*x15*x31))))))+(((-1.0)*x14*x25))+((x10*(((((0.155)*x24))+(((-1.0)*x25*x43))))))+(((0.36)*x2)));
eerot[3]=((((-1.0)*x35*x8))+((x39*x9)));
eerot[4]=(((x35*x9))+((x39*x8)));
eerot[5]=((((-1.0)*x10*x29))+((x11*((x27+(((-1.0)*x22*x6)))))));
eetrans[1]=(((x11*((((x18*x5))+(((-1.0)*x15*x22))))))+(((-0.155)*x10*x26))+(((-0.36)*x26)));
eerot[6]=(((x42*x9))+((x8*(((((-1.0)*x12*x33))+(((-1.0)*x2*x23)))))));
eerot[7]=(((x42*x8))+((x9*((((x33*x5))+((x2*x23)))))));
eerot[8]=(((x10*x36))+((x11*x40)));
eetrans[2]=((((0.36)*x19*x3))+((x1*x14))+x14+((x11*((((x15*x32))+(((0.155)*x2*x20))))))+((x10*((((x18*x19))+((x1*x13)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r01);
new_r02=((-1.0)*r02);
new_px=(px+(((-0.155)*r02)));
new_r10=((-1.0)*r20);
new_r11=r21;
new_r12=r22;
new_py=((((-1.0)*pz))+(((0.155)*r22)));
new_r20=r10;
new_r21=((-1.0)*r11);
new_r22=((-1.0)*r12);
new_pz=(py+(((-0.155)*r12)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x44=((1.0)*px);
IkReal x45=((1.0)*pz);
IkReal x46=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x46))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x45)));
rxp0_2=((((-1.0)*r10*x44))+((py*r00)));
rxp1_0=((((-1.0)*r21*x46))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x45)));
rxp1_2=((((-1.0)*r11*x44))+((py*r01)));
rxp2_0=((((-1.0)*r22*x46))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x45))+((px*r22)));
rxp2_2=((((-1.0)*r12*x44))+((py*r02)));
{
IkReal j1eval[2];
j1eval[0]=((px*px)+(py*py));
j1eval[1]=(pp+(((-1.0)*(pz*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x47=((0.36)*r22);
IkReal x48=((1.0)*pz);
IkReal x49=((((-1.0)*x48))+x47);
IkReal x50=((-1.0)*pz);
IkReal x51=((((-1.0)*x47))+(((-1.0)*x48)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x50);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x50);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x50);
rxp2_2=0;
IkReal gconst0=x51;
IkReal gconst1=x49;
IkReal gconst2=x51;
IkReal gconst3=x49;
IkReal gconst4=x51;
IkReal gconst5=x49;
IkReal gconst6=x51;
IkReal gconst7=x49;
IkReal x52=pz*pz*pz*pz;
IkReal x53=r20*r20;
IkReal x54=r22*r22;
IkReal x55=r21*r21;
IkReal x56=(x52*x53);
IkReal x57=(x52*x55);
IkReal x58=(x52*x54);
j6eval[0]=((((2.0)*(IKabs(((((-8.2944)*x57))+(((-8.2944)*x58)))))))+(IKabs(((((-2.0736)*x56))+(((-2.0736)*x58)))))+(((33.1776)*(IKabs((r20*r21*x52)))))+(IKabs(((((-12.4416)*x58))+(((-16.5888)*x57))+(((4.1472)*x56))))));
if( IKabs(j6eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x59=pz*pz;
IkReal x60=r20*r20;
IkReal x61=r22*r22;
IkReal x62=r21*r21;
IkReal x63=pz*pz*pz*pz;
IkReal x64=(gconst2*gconst5);
IkReal x65=(gconst3*gconst4);
IkReal x66=((0.5184)*gconst7);
IkReal x67=(gconst3*gconst5);
IkReal x68=(gconst1*gconst2);
IkReal x69=(gconst2*gconst4);
IkReal x70=(gconst0*gconst3);
IkReal x71=(gconst1*gconst6);
IkReal x72=(gconst0*gconst2);
IkReal x73=(gconst1*gconst3);
IkReal x74=(gconst5*gconst6);
IkReal x75=(gconst4*gconst6);
IkReal x76=(gconst0*gconst6);
IkReal x77=(r22*x59);
IkReal x78=(gconst6*x60);
IkReal x79=((2.985984)*x62);
IkReal x80=((2.0736)*x59);
IkReal x81=((4.1472)*x59);
IkReal x82=((0.746496)*x60);
IkReal x83=(x59*x61);
IkReal x84=(r20*r21*x63);
IkReal x85=((8.2944)*x84);
IkReal x86=((1.0368)*x83);
IkReal x87=((8.2944)*x59*x62);
IkReal x88=((-8.2944)*x84);
IkReal x89=(gconst5*x77*x82);
IkReal x90=((0.746496)*x77*x78);
IkReal x91=(gconst1*x77*x82);
IkReal x92=(gconst6*x77*x79);
IkReal x93=(gconst5*x66*x83);
IkReal x94=(gconst2*x77*x82);
IkReal x95=((0.5184)*x74*x83);
IkReal x96=(gconst5*x77*x79);
IkReal x97=(x60*x74*x80);
IkReal x98=((0.5184)*x75*x83);
IkReal x99=(gconst4*x66*x83);
IkReal x100=(gconst2*x77*x79);
IkReal x101=((1.07495424)*x62*x83);
IkReal x102=(gconst1*x66*x83);
IkReal x103=((0.5184)*x71*x83);
IkReal x104=((0.5184)*x69*x83);
IkReal x105=(gconst0*x66*x83);
IkReal x106=((0.5184)*x64*x83);
IkReal x107=(gconst1*x77*x79);
IkReal x108=(x60*x71*x80);
IkReal x109=((0.5184)*x76*x83);
IkReal x110=((0.5184)*x67*x83);
IkReal x111=(x60*x64*x80);
IkReal x112=((0.5184)*x65*x83);
IkReal x113=((0.26873856)*x60*x83);
IkReal x114=((0.5184)*x72*x83);
IkReal x115=((0.5184)*x70*x83);
IkReal x116=(x60*x68*x80);
IkReal x117=((0.5184)*x73*x83);
IkReal x118=((0.5184)*x68*x83);
IkReal x119=(x90+x96);
IkReal x120=(x89+x94);
IkReal x121=(x100+x91);
IkReal x122=(x99+x98+x93+x95+x97);
IkReal x123=(x117+x116+x115+x114+x118);
IkReal x124=(x112+x111+x110+x108+x109+x104+x105+x106+x102+x103);
op[0]=((((-1.0)*x122))+x113+x90+(((-1.0)*x89)));
op[1]=x88;
op[2]=((((-1.0)*x119))+(((-1.0)*x124))+x120+x101+x92+(((-1.0)*x74*x86))+(((-1.0)*x74*x87))+((x60*x74*x81))+(((-1.0)*x91))+(((-1.0)*gconst5*gconst7*x86))+(((-1.0)*x75*x86))+(((-1.0)*gconst4*gconst7*x86)));
op[3]=x88;
op[4]=((((-1.0)*x67*x86))+(((-1.0)*gconst0*gconst7*x86))+((x60*x64*x81))+(((-1.0)*x71*x87))+(((-1.0)*x71*x86))+(((2.14990848)*x62*x83))+(((-1.0)*x107))+(((-1.0)*gconst1*gconst7*x86))+(((-1.0)*x119))+(((-1.0)*x123))+(((-1.0)*x122))+x121+((x60*x71*x81))+(((-1.0)*x65*x86))+x89+x92+(((-1.0)*x76*x86))+(((-1.0)*x94))+(((-1.0)*x69*x86))+(((-0.53747712)*x60*x83))+(((-1.0)*x64*x86))+(((-1.0)*x64*x87)));
op[5]=x85;
op[6]=(((x60*x68*x81))+(((-1.0)*x73*x86))+(((-1.0)*x72*x86))+(((-1.0)*x70*x86))+(((-1.0)*x107))+(((-1.0)*x120))+(((-1.0)*x124))+x121+x101+x90+(((-1.0)*x68*x87))+(((-1.0)*x68*x86)));
op[7]=x85;
op[8]=((((-1.0)*x123))+x113+x94+(((-1.0)*x91)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[1];
IkReal x125=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x125);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x125);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x125);
rxp2_2=0;
j5eval[0]=((IKabs((pz*r22)))+(IKabs((((cj6*pz*r20))+(((-1.0)*pz*r21*sj6))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x126=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x126);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x126);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x126);
rxp2_2=0;
IkReal x127=(r21*sj6);
IkReal x128=(cj6*r20);
j5eval[0]=((((2.77777777777778)*(IKabs(((((0.36)*x128))+(((-0.36)*x127)))))))+(IKabs(r22)));
j5eval[1]=((r22*r22)+(((-2.0)*x127*x128))+(x127*x127)+(x128*x128));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x129=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x129);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x129);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x129);
rxp2_2=0;
IkReal x130=cj6*cj6;
IkReal x131=sj6*sj6;
IkReal x132=((0.36)*cj6);
IkReal x133=(r00*sj6);
IkReal x134=((2.0)*cj6);
IkReal x135=(r10*sj6);
j1eval[0]=(((x131*(r10*r10)))+((x130*(r11*r11)))+((x130*(r01*r01)))+((r01*x133*x134))+((x131*(r00*r00)))+((r11*x134*x135)));
j1eval[1]=((IKabs(((((-1.0)*r11*x132))+(((-0.36)*x135)))))+(IKabs((((r01*x132))+(((0.36)*x133))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((IKabs(r22))+(((2.77777777777778)*(IKabs(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x136=((0.36)*cj6);
IkReal x137=((0.36)*sj6);
j1eval[0]=((IKabs((((r00*x137))+((r01*x136)))))+(IKabs(((((-1.0)*r10*x137))+(((-1.0)*r11*x136))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x138=((0.36)*cj6);
IkReal x139=((0.36)*sj6);
CheckValue<IkReal> x141 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x139))+(((-1.0)*r11*x138)))),IkReal((((r00*x139))+((r01*x138)))),IKFAST_ATAN2_MAGTHRESH);
if(!x141.valid){
continue;
}
IkReal x140=x141.value;
j1array[0]=((-1.0)*x140);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x140)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x142=(r02*sj1);
IkReal x143=((9.0)*cj1);
CheckValue<IkReal> x144=IKPowWithIntegerCheck(((((9.0)*cj6*r10))+(((-9.0)*r11*sj6))),-1);
if(!x144.valid){
continue;
}
if( IKabs(((x144.value)*(((((9.0)*r12*x142))+x143+(((-1.0)*x143*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x142+(((-1.0)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x144.value)*(((((9.0)*r12*x142))+x143+(((-1.0)*x143*(r12*r12)))))))+IKsqr((x142+(((-1.0)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x144.value)*(((((9.0)*r12*x142))+x143+(((-1.0)*x143*(r12*r12)))))), (x142+(((-1.0)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x145=IKcos(j5);
IkReal x146=IKsin(j5);
IkReal x147=((0.36)*cj6);
IkReal x148=((0.36)*sj6);
IkReal x149=((0.36)*r12);
IkReal x150=((0.36)*r02);
IkReal x151=((0.36)*x145);
evalcond[0]=((((-1.0)*x151))+((sj1*x150))+(((-1.0)*cj1*x149)));
evalcond[1]=(((r20*x146*x147))+(((-1.0)*r21*x146*x148))+(((-1.0)*r22*x151)));
evalcond[2]=((((0.36)*sj1))+(((-1.0)*r01*x146*x148))+(((-1.0)*x145*x150))+((r00*x146*x147)));
evalcond[3]=((((-1.0)*r11*x146*x148))+((r10*x146*x147))+(((-1.0)*x145*x149))+(((-0.36)*cj1)));
evalcond[4]=((((-1.0)*cj1*r10*x147))+(((-1.0)*r01*sj1*x148))+((cj1*r11*x148))+(((0.36)*x146))+((r00*sj1*x147)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1046=((9.0)*sj1);
IkReal x1047=(cj1*r12);
CheckValue<IkReal> x1048=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1048.valid){
continue;
}
if( IKabs(((x1048.value)*(((((-9.0)*r02*x1047))+(((-1.0)*x1046))+((x1046*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj1))+(((-1.0)*x1047)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1048.value)*(((((-9.0)*r02*x1047))+(((-1.0)*x1046))+((x1046*(r02*r02)))))))+IKsqr((((r02*sj1))+(((-1.0)*x1047))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1048.value)*(((((-9.0)*r02*x1047))+(((-1.0)*x1046))+((x1046*(r02*r02)))))), (((r02*sj1))+(((-1.0)*x1047))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1049=IKcos(j5);
IkReal x1050=IKsin(j5);
IkReal x1051=((0.36)*cj6);
IkReal x1052=((0.36)*sj6);
IkReal x1053=((0.36)*r12);
IkReal x1054=((0.36)*r02);
IkReal x1055=((0.36)*x1049);
evalcond[0]=((((-1.0)*x1055))+(((-1.0)*cj1*x1053))+((sj1*x1054)));
evalcond[1]=(((r20*x1050*x1051))+(((-1.0)*r22*x1055))+(((-1.0)*r21*x1050*x1052)));
evalcond[2]=((((0.36)*sj1))+((r00*x1050*x1051))+(((-1.0)*r01*x1050*x1052))+(((-1.0)*x1049*x1054)));
evalcond[3]=((((-1.0)*r11*x1050*x1052))+((r10*x1050*x1051))+(((-1.0)*x1049*x1053))+(((-0.36)*cj1)));
evalcond[4]=(((cj1*r11*x1052))+((r00*sj1*x1051))+(((0.36)*x1050))+(((-1.0)*r01*sj1*x1052))+(((-1.0)*cj1*r10*x1051)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1056=(r02*sj1);
IkReal x1057=((0.36)*r22);
IkReal x1058=(cj1*r12);
CheckValue<IkReal> x1059=IKPowWithIntegerCheck(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))),-1);
if(!x1059.valid){
continue;
}
if( IKabs(((x1059.value)*((((x1056*x1057))+(((-1.0)*x1057*x1058)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1056+(((-1.0)*x1058)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1059.value)*((((x1056*x1057))+(((-1.0)*x1057*x1058))))))+IKsqr((x1056+(((-1.0)*x1058))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1059.value)*((((x1056*x1057))+(((-1.0)*x1057*x1058))))), (x1056+(((-1.0)*x1058))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1060=IKcos(j5);
IkReal x1061=IKsin(j5);
IkReal x1062=((0.36)*cj6);
IkReal x1063=((0.36)*sj6);
IkReal x1064=((0.36)*r12);
IkReal x1065=((0.36)*r02);
IkReal x1066=((0.36)*x1060);
evalcond[0]=((((-1.0)*cj1*x1064))+((sj1*x1065))+(((-1.0)*x1066)));
evalcond[1]=(((r20*x1061*x1062))+(((-1.0)*r22*x1066))+(((-1.0)*r21*x1061*x1063)));
evalcond[2]=((((0.36)*sj1))+((r00*x1061*x1062))+(((-1.0)*x1060*x1065))+(((-1.0)*r01*x1061*x1063)));
evalcond[3]=((((-1.0)*x1060*x1064))+((r10*x1061*x1062))+(((-1.0)*r11*x1061*x1063))+(((-0.36)*cj1)));
evalcond[4]=(((cj1*r11*x1063))+((r00*sj1*x1062))+(((0.36)*x1061))+(((-1.0)*r01*sj1*x1063))+(((-1.0)*cj1*r10*x1062)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1068 = IKatan2WithCheck(IkReal(((-0.36)*r22)),IkReal(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1068.valid){
continue;
}
IkReal x1067=x1068.value;
j5array[0]=((-1.0)*x1067);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1067)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1069=((1.0)*sj6);
IkReal x1070=(cj6*r20);
IkReal x1071=((1.0)*cj5*cj6);
j1eval[0]=((((-1.0)*r21*x1069))+x1070);
j1eval[1]=IKsign(((((0.36)*x1070))+(((-0.36)*r21*sj6))));
j1eval[2]=((IKabs(((((-1.0)*cj5*r10*x1069))+(((-1.0)*r11*x1071)))))+(IKabs(((((-1.0)*r01*x1071))+(((-1.0)*cj5*r00*x1069))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1072=((9.0)*sj5);
IkReal x1073=(r20*sj6);
IkReal x1074=(cj6*r21);
IkReal x1075=((9.0)*cj5*cj6);
IkReal x1076=((9.0)*cj5*sj6);
j1eval[0]=((((-1.0)*x1073))+(((-1.0)*x1074)));
j1eval[1]=IKsign(((((-9.0)*x1073))+(((-9.0)*x1074))));
j1eval[2]=((IKabs(((((-1.0)*r12*x1072))+(((-1.0)*r10*x1075))+((r11*x1076)))))+(IKabs(((((-1.0)*r00*x1075))+(((-1.0)*r02*x1072))+((r01*x1076))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j1eval[0]=r12;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1077=(r01*sj6);
IkReal x1078=(cj6*r00);
IkReal x1079=((9.0)*cj5);
IkReal x1080=((9.0)*r02*sj5);
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(r12,-1);
if(!x1081.valid){
continue;
}
if( IKabs((((sj5*x1077))+(((-1.0)*sj5*x1078))+((cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.111111111111111)*(x1081.value)*((((x1079*(r02*r02)))+(((-1.0)*x1078*x1080))+((x1077*x1080))+(((-1.0)*x1079)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj5*x1077))+(((-1.0)*sj5*x1078))+((cj5*r02))))+IKsqr(((0.111111111111111)*(x1081.value)*((((x1079*(r02*r02)))+(((-1.0)*x1078*x1080))+((x1077*x1080))+(((-1.0)*x1079))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((sj5*x1077))+(((-1.0)*sj5*x1078))+((cj5*r02))), ((0.111111111111111)*(x1081.value)*((((x1079*(r02*r02)))+(((-1.0)*x1078*x1080))+((x1077*x1080))+(((-1.0)*x1079))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1082=IKsin(j1);
IkReal x1083=IKcos(j1);
IkReal x1084=(cj6*r00);
IkReal x1085=((0.36)*sj5);
IkReal x1086=(r01*sj6);
IkReal x1087=(r11*sj6);
IkReal x1088=(cj6*r10);
IkReal x1089=((0.36)*cj5);
IkReal x1090=((0.36)*x1082);
IkReal x1091=((0.36)*x1083);
evalcond[0]=(((r02*x1090))+(((-1.0)*r12*x1091))+(((-1.0)*x1089)));
evalcond[1]=(x1090+(((-1.0)*r02*x1089))+(((-1.0)*x1085*x1086))+((x1084*x1085)));
evalcond[2]=((((-1.0)*x1091))+(((-1.0)*x1085*x1087))+((x1085*x1088))+(((-1.0)*r12*x1089)));
evalcond[3]=(((r00*sj6*x1090))+(((-1.0)*r10*sj6*x1091))+(((-1.0)*cj6*r11*x1091))+((cj6*r01*x1090)));
evalcond[4]=((((-1.0)*x1086*x1090))+((x1087*x1091))+x1085+((x1084*x1090))+(((-1.0)*x1088*x1091)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1092=((9.0)*sj5);
IkReal x1093=((9.0)*sj6);
IkReal x1094=((9.0)*cj5*cj6);
CheckValue<IkReal> x1095 = IKatan2WithCheck(IkReal((((cj5*r11*x1093))+(((-1.0)*r12*x1092))+(((-1.0)*r10*x1094)))),IkReal((((cj5*r01*x1093))+(((-1.0)*r02*x1092))+(((-1.0)*r00*x1094)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1095.valid){
continue;
}
CheckValue<IkReal> x1096=IKPowWithIntegerCheck(IKsign(((((-9.0)*cj6*r21))+(((-1.0)*r20*x1093)))),-1);
if(!x1096.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1095.value)+(((1.5707963267949)*(x1096.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1097=IKsin(j1);
IkReal x1098=IKcos(j1);
IkReal x1099=(cj6*r00);
IkReal x1100=((0.36)*sj5);
IkReal x1101=(r01*sj6);
IkReal x1102=(r11*sj6);
IkReal x1103=(cj6*r10);
IkReal x1104=((0.36)*cj5);
IkReal x1105=((0.36)*x1097);
IkReal x1106=((0.36)*x1098);
evalcond[0]=(((r02*x1105))+(((-1.0)*r12*x1106))+(((-1.0)*x1104)));
evalcond[1]=(x1105+((x1099*x1100))+(((-1.0)*x1100*x1101))+(((-1.0)*r02*x1104)));
evalcond[2]=((((-1.0)*r12*x1104))+(((-1.0)*x1100*x1102))+((x1100*x1103))+(((-1.0)*x1106)));
evalcond[3]=((((-1.0)*r10*sj6*x1106))+((cj6*r01*x1105))+((r00*sj6*x1105))+(((-1.0)*cj6*r11*x1106)));
evalcond[4]=((((-1.0)*x1103*x1106))+x1100+((x1102*x1106))+((x1099*x1105))+(((-1.0)*x1101*x1105)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1107=((0.36)*sj6);
IkReal x1108=((0.36)*cj6);
CheckValue<IkReal> x1109=IKPowWithIntegerCheck(IKsign((((r20*x1108))+(((-1.0)*r21*x1107)))),-1);
if(!x1109.valid){
continue;
}
CheckValue<IkReal> x1110 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r10*x1107))+(((-1.0)*cj5*r11*x1108)))),IkReal(((((-1.0)*cj5*r00*x1107))+(((-1.0)*cj5*r01*x1108)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1110.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1109.value)))+(x1110.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1111=IKsin(j1);
IkReal x1112=IKcos(j1);
IkReal x1113=(cj6*r00);
IkReal x1114=((0.36)*sj5);
IkReal x1115=(r01*sj6);
IkReal x1116=(r11*sj6);
IkReal x1117=(cj6*r10);
IkReal x1118=((0.36)*cj5);
IkReal x1119=((0.36)*x1111);
IkReal x1120=((0.36)*x1112);
evalcond[0]=((((-1.0)*r12*x1120))+(((-1.0)*x1118))+((r02*x1119)));
evalcond[1]=(x1119+(((-1.0)*x1114*x1115))+((x1113*x1114))+(((-1.0)*r02*x1118)));
evalcond[2]=(((x1114*x1117))+(((-1.0)*x1114*x1116))+(((-1.0)*r12*x1118))+(((-1.0)*x1120)));
evalcond[3]=(((cj6*r01*x1119))+(((-1.0)*cj6*r11*x1120))+((r00*sj6*x1119))+(((-1.0)*r10*sj6*x1120)));
evalcond[4]=(x1114+((x1113*x1119))+(((-1.0)*x1117*x1120))+((x1116*x1120))+(((-1.0)*x1115*x1119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1121=((0.36)*cj6);
IkReal x1122=((1.0)*pz);
IkReal x1123=((0.36)*sj6);
IkReal x1124=((((-1.0)*r11*x1121))+(((-1.0)*r10*x1123)));
IkReal x1125=(((r00*x1123))+((r01*x1121)));
CheckValue<IkReal> x1128 = IKatan2WithCheck(IkReal(x1124),IkReal(x1125),IKFAST_ATAN2_MAGTHRESH);
if(!x1128.valid){
continue;
}
IkReal x1126=((1.0)*(x1128.value));
if((((x1124*x1124)+(x1125*x1125))) < -0.00001)
continue;
CheckValue<IkReal> x1129=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1124*x1124)+(x1125*x1125)))),-1);
if(!x1129.valid){
continue;
}
if( (((-1.0)*(x1129.value)*(((((-1.0)*cj6*r21*x1122))+(((-1.0)*r20*sj6*x1122)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1129.value)*(((((-1.0)*cj6*r21*x1122))+(((-1.0)*r20*sj6*x1122)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1127=((-1.0)*(IKasin(((-1.0)*(x1129.value)*(((((-1.0)*cj6*r21*x1122))+(((-1.0)*r20*sj6*x1122))))))));
j1array[0]=((((-1.0)*x1127))+(((-1.0)*x1126)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((1.0)*x1127))+(((-1.0)*x1126)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
IkReal x1130=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1130);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1130);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1130);
rxp2_2=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1131=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1131);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1131);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1131);
rxp2_2=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1132=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1132);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1132);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1132);
rxp2_2=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1133=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1133);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1133);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1134=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1134);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1134);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1135=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1135);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1135);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
j5eval[1]=r12;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1136=IKPowWithIntegerCheck(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))),-1);
if(!x1136.valid){
continue;
}
CheckValue<IkReal> x1137=IKPowWithIntegerCheck(r12,-1);
if(!x1137.valid){
continue;
}
if( IKabs((pz*(x1136.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj1*(x1137.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x1136.value)))+IKsqr(((-1.0)*cj1*(x1137.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((pz*(x1136.value)), ((-1.0)*cj1*(x1137.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1138=IKcos(j5);
IkReal x1139=IKsin(j5);
IkReal x1140=((1.0)*pz);
IkReal x1141=(cj6*r20);
IkReal x1142=((0.36)*r12);
IkReal x1143=((0.36)*sj1);
IkReal x1144=(cj6*r00);
IkReal x1145=(pz*r21*sj6);
IkReal x1146=((0.72)*x1139);
IkReal x1147=((0.36)*x1139);
IkReal x1148=(sj6*x1147);
evalcond[0]=((((-0.36)*x1138))+(((-1.0)*cj1*x1142)));
evalcond[1]=((((-0.36)*cj1))+(((-1.0)*x1138*x1142)));
evalcond[2]=((((-1.0)*x1145*x1146))+((pz*x1141*x1146)));
evalcond[3]=(((x1141*x1147))+(((-1.0)*x1140))+(((-1.0)*r21*x1148)));
evalcond[4]=((((-1.0)*r01*x1148))+x1143+((x1144*x1147)));
evalcond[5]=((((-1.0)*x1140*x1141))+x1147+x1145+((x1143*x1144))+(((-1.0)*r01*sj6*x1143)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1149=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1149.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1149.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1149.value)))+IKsqr(((-1.0)*cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1149.value)), ((-1.0)*cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1150=IKcos(j5);
IkReal x1151=IKsin(j5);
IkReal x1152=((1.0)*pz);
IkReal x1153=(cj6*r20);
IkReal x1154=((0.36)*r12);
IkReal x1155=((0.36)*sj1);
IkReal x1156=(cj6*r00);
IkReal x1157=(pz*r21*sj6);
IkReal x1158=((0.72)*x1151);
IkReal x1159=((0.36)*x1151);
IkReal x1160=(sj6*x1159);
evalcond[0]=((((-1.0)*cj1*x1154))+(((-0.36)*x1150)));
evalcond[1]=((((-1.0)*x1150*x1154))+(((-0.36)*cj1)));
evalcond[2]=((((-1.0)*x1157*x1158))+((pz*x1153*x1158)));
evalcond[3]=((((-1.0)*r21*x1160))+(((-1.0)*x1152))+((x1153*x1159)));
evalcond[4]=(x1155+(((-1.0)*r01*x1160))+((x1156*x1159)));
evalcond[5]=(x1159+x1157+(((-1.0)*r01*sj6*x1155))+(((-1.0)*x1152*x1153))+((x1155*x1156)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1161=IKPowWithIntegerCheck(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))),-1);
if(!x1161.valid){
continue;
}
if( IKabs((pz*(x1161.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj1*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x1161.value)))+IKsqr(((-1.0)*cj1*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((pz*(x1161.value)), ((-1.0)*cj1*r12));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1162=IKcos(j5);
IkReal x1163=IKsin(j5);
IkReal x1164=((1.0)*pz);
IkReal x1165=(cj6*r20);
IkReal x1166=((0.36)*r12);
IkReal x1167=((0.36)*sj1);
IkReal x1168=(cj6*r00);
IkReal x1169=(pz*r21*sj6);
IkReal x1170=((0.72)*x1163);
IkReal x1171=((0.36)*x1163);
IkReal x1172=(sj6*x1171);
evalcond[0]=((((-1.0)*cj1*x1166))+(((-0.36)*x1162)));
evalcond[1]=((((-1.0)*x1162*x1166))+(((-0.36)*cj1)));
evalcond[2]=((((-1.0)*x1169*x1170))+((pz*x1165*x1170)));
evalcond[3]=((((-1.0)*r21*x1172))+((x1165*x1171))+(((-1.0)*x1164)));
evalcond[4]=(x1167+((x1168*x1171))+(((-1.0)*r01*x1172)));
evalcond[5]=(x1169+x1171+((x1167*x1168))+(((-1.0)*r01*sj6*x1167))+(((-1.0)*x1164*x1165)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1173=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1173);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1173);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1174=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1174);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1174);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1175=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1175);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1175);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
j5eval[1]=r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1176=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1176.valid){
continue;
}
CheckValue<IkReal> x1177=IKPowWithIntegerCheck(r22,-1);
if(!x1177.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1176.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.77777777777778)*pz*(x1177.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1176.value)))+IKsqr(((-2.77777777777778)*pz*(x1177.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1176.value)), ((-2.77777777777778)*pz*(x1177.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1178=IKcos(j5);
IkReal x1179=IKsin(j5);
IkReal x1180=((0.36)*cj6);
IkReal x1181=((1.0)*pz);
IkReal x1182=((0.36)*sj1);
IkReal x1183=(r11*sj6);
IkReal x1184=((0.36)*cj1);
IkReal x1185=(r01*sj6);
IkReal x1186=((0.36)*x1179);
IkReal x1187=((0.36)*x1178);
evalcond[0]=((-0.72)*pz*r22*x1178);
evalcond[1]=((((-1.0)*x1187))+(((-1.0)*r22*x1181)));
evalcond[2]=((((-1.0)*x1181))+(((-1.0)*r22*x1187)));
evalcond[3]=(x1182+((r00*x1179*x1180))+(((-1.0)*x1185*x1186)));
evalcond[4]=((((-1.0)*x1184))+((r10*x1179*x1180))+(((-1.0)*x1183*x1186)));
evalcond[5]=(x1186+((x1183*x1184))+((r00*sj1*x1180))+(((-1.0)*x1182*x1185))+(((-1.0)*cj1*r10*x1180)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1188=IKPowWithIntegerCheck(((((9.0)*cj6*r10))+(((-9.0)*r11*sj6))),-1);
if(!x1188.valid){
continue;
}
if( IKabs(((9.0)*cj1*(x1188.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.77777777777778)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((9.0)*cj1*(x1188.value)))+IKsqr(((-2.77777777777778)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((9.0)*cj1*(x1188.value)), ((-2.77777777777778)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1189=IKcos(j5);
IkReal x1190=IKsin(j5);
IkReal x1191=((0.36)*cj6);
IkReal x1192=((1.0)*pz);
IkReal x1193=((0.36)*sj1);
IkReal x1194=(r11*sj6);
IkReal x1195=((0.36)*cj1);
IkReal x1196=(r01*sj6);
IkReal x1197=((0.36)*x1190);
IkReal x1198=((0.36)*x1189);
evalcond[0]=((-0.72)*pz*r22*x1189);
evalcond[1]=((((-1.0)*x1198))+(((-1.0)*r22*x1192)));
evalcond[2]=((((-1.0)*x1192))+(((-1.0)*r22*x1198)));
evalcond[3]=(x1193+((r00*x1190*x1191))+(((-1.0)*x1196*x1197)));
evalcond[4]=((((-1.0)*x1194*x1197))+(((-1.0)*x1195))+((r10*x1190*x1191)));
evalcond[5]=(x1197+(((-1.0)*x1193*x1196))+((x1194*x1195))+((r00*sj1*x1191))+(((-1.0)*cj1*r10*x1191)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1199=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1199.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1199.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.77777777777778)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1199.value)))+IKsqr(((-2.77777777777778)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1199.value)), ((-2.77777777777778)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1200=IKcos(j5);
IkReal x1201=IKsin(j5);
IkReal x1202=((0.36)*cj6);
IkReal x1203=((1.0)*pz);
IkReal x1204=((0.36)*sj1);
IkReal x1205=(r11*sj6);
IkReal x1206=((0.36)*cj1);
IkReal x1207=(r01*sj6);
IkReal x1208=((0.36)*x1201);
IkReal x1209=((0.36)*x1200);
evalcond[0]=((-0.72)*pz*r22*x1200);
evalcond[1]=((((-1.0)*r22*x1203))+(((-1.0)*x1209)));
evalcond[2]=((((-1.0)*r22*x1209))+(((-1.0)*x1203)));
evalcond[3]=(x1204+((r00*x1201*x1202))+(((-1.0)*x1207*x1208)));
evalcond[4]=((((-1.0)*x1205*x1208))+((r10*x1201*x1202))+(((-1.0)*x1206)));
evalcond[5]=((((-1.0)*x1204*x1207))+x1208+(((-1.0)*cj1*r10*x1202))+((x1205*x1206))+((r00*sj1*x1202)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1210=(pz*r22);
IkReal x1211=(r02*sj1);
IkReal x1212=((9.0)*cj1);
CheckValue<IkReal> x1213=IKPowWithIntegerCheck(((((9.0)*cj6*r10))+(((-9.0)*r11*sj6))),-1);
if(!x1213.valid){
continue;
}
if( IKabs(((x1213.value)*((x1212+(((-1.0)*x1212*(r12*r12)))+(((9.0)*r12*x1211))+(((-25.0)*r12*x1210)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1211+(((-2.77777777777778)*x1210))+(((-1.0)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1213.value)*((x1212+(((-1.0)*x1212*(r12*r12)))+(((9.0)*r12*x1211))+(((-25.0)*r12*x1210))))))+IKsqr((x1211+(((-2.77777777777778)*x1210))+(((-1.0)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1213.value)*((x1212+(((-1.0)*x1212*(r12*r12)))+(((9.0)*r12*x1211))+(((-25.0)*r12*x1210))))), (x1211+(((-2.77777777777778)*x1210))+(((-1.0)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1214=IKcos(j5);
IkReal x1215=IKsin(j5);
IkReal x1216=((0.36)*cj6);
IkReal x1217=((0.36)*cj1);
IkReal x1218=((1.0)*pz);
IkReal x1219=(cj6*r20);
IkReal x1220=((0.36)*sj1);
IkReal x1221=((0.36)*x1214);
IkReal x1222=(pz*r21*sj6);
IkReal x1223=((0.72)*x1215);
IkReal x1224=((0.36)*sj6*x1215);
evalcond[0]=((((-1.0)*x1221))+(((-1.0)*r22*x1218))+((r02*x1220))+(((-1.0)*r12*x1217)));
evalcond[1]=((((-1.0)*r21*x1224))+((r20*x1215*x1216))+(((-1.0)*x1218))+(((-1.0)*r22*x1221)));
evalcond[2]=((((-0.72)*pz*r22*x1214))+(((-1.0)*x1222*x1223))+((pz*x1219*x1223)));
evalcond[3]=((((-1.0)*r01*x1224))+x1220+((r00*x1215*x1216))+(((-1.0)*r02*x1221)));
evalcond[4]=((((-1.0)*r11*x1224))+(((-1.0)*r12*x1221))+(((-1.0)*x1217))+((r10*x1215*x1216)));
evalcond[5]=(x1222+(((0.36)*x1215))+(((-1.0)*cj1*r10*x1216))+(((-1.0)*x1218*x1219))+((r00*sj1*x1216))+(((-1.0)*r01*sj6*x1220))+((r11*sj6*x1217)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1225=((9.0)*sj1);
IkReal x1226=(pz*r22);
IkReal x1227=(cj1*r12);
CheckValue<IkReal> x1228=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1228.valid){
continue;
}
if( IKabs(((x1228.value)*((((x1225*(r02*r02)))+(((-1.0)*x1225))+(((-9.0)*r02*x1227))+(((-25.0)*r02*x1226)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-2.77777777777778)*x1226))+(((-1.0)*x1227))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1228.value)*((((x1225*(r02*r02)))+(((-1.0)*x1225))+(((-9.0)*r02*x1227))+(((-25.0)*r02*x1226))))))+IKsqr(((((-2.77777777777778)*x1226))+(((-1.0)*x1227))+((r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1228.value)*((((x1225*(r02*r02)))+(((-1.0)*x1225))+(((-9.0)*r02*x1227))+(((-25.0)*r02*x1226))))), ((((-2.77777777777778)*x1226))+(((-1.0)*x1227))+((r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1229=IKcos(j5);
IkReal x1230=IKsin(j5);
IkReal x1231=((0.36)*cj6);
IkReal x1232=((0.36)*cj1);
IkReal x1233=((1.0)*pz);
IkReal x1234=(cj6*r20);
IkReal x1235=((0.36)*sj1);
IkReal x1236=((0.36)*x1229);
IkReal x1237=(pz*r21*sj6);
IkReal x1238=((0.72)*x1230);
IkReal x1239=((0.36)*sj6*x1230);
evalcond[0]=((((-1.0)*x1236))+(((-1.0)*r12*x1232))+((r02*x1235))+(((-1.0)*r22*x1233)));
evalcond[1]=(((r20*x1230*x1231))+(((-1.0)*x1233))+(((-1.0)*r21*x1239))+(((-1.0)*r22*x1236)));
evalcond[2]=((((-0.72)*pz*r22*x1229))+((pz*x1234*x1238))+(((-1.0)*x1237*x1238)));
evalcond[3]=(x1235+(((-1.0)*r01*x1239))+((r00*x1230*x1231))+(((-1.0)*r02*x1236)));
evalcond[4]=((((-1.0)*x1232))+(((-1.0)*r12*x1236))+(((-1.0)*r11*x1239))+((r10*x1230*x1231)));
evalcond[5]=(x1237+(((0.36)*x1230))+((r00*sj1*x1231))+(((-1.0)*r01*sj6*x1235))+(((-1.0)*x1233*x1234))+((r11*sj6*x1232))+(((-1.0)*cj1*r10*x1231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1240=((0.36)*r22);
IkReal x1241=(r02*sj1);
IkReal x1242=(cj1*r12);
CheckValue<IkReal> x1243=IKPowWithIntegerCheck(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))),-1);
if(!x1243.valid){
continue;
}
if( IKabs(((x1243.value)*((((x1240*x1241))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1240*x1242)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1241+(((-1.0)*x1242))+(((-2.77777777777778)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1243.value)*((((x1240*x1241))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1240*x1242))))))+IKsqr((x1241+(((-1.0)*x1242))+(((-2.77777777777778)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1243.value)*((((x1240*x1241))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1240*x1242))))), (x1241+(((-1.0)*x1242))+(((-2.77777777777778)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1244=IKcos(j5);
IkReal x1245=IKsin(j5);
IkReal x1246=((0.36)*cj6);
IkReal x1247=((0.36)*cj1);
IkReal x1248=((1.0)*pz);
IkReal x1249=(cj6*r20);
IkReal x1250=((0.36)*sj1);
IkReal x1251=((0.36)*x1244);
IkReal x1252=(pz*r21*sj6);
IkReal x1253=((0.72)*x1245);
IkReal x1254=((0.36)*sj6*x1245);
evalcond[0]=((((-1.0)*x1251))+((r02*x1250))+(((-1.0)*r12*x1247))+(((-1.0)*r22*x1248)));
evalcond[1]=((((-1.0)*r21*x1254))+(((-1.0)*r22*x1251))+(((-1.0)*x1248))+((r20*x1245*x1246)));
evalcond[2]=((((-0.72)*pz*r22*x1244))+(((-1.0)*x1252*x1253))+((pz*x1249*x1253)));
evalcond[3]=(x1250+(((-1.0)*r01*x1254))+(((-1.0)*r02*x1251))+((r00*x1245*x1246)));
evalcond[4]=((((-1.0)*r12*x1251))+(((-1.0)*r11*x1254))+(((-1.0)*x1247))+((r10*x1245*x1246)));
evalcond[5]=(x1252+(((-1.0)*cj1*r10*x1246))+(((0.36)*x1245))+((r11*sj6*x1247))+((r00*sj1*x1246))+(((-1.0)*r01*sj6*x1250))+(((-1.0)*x1248*x1249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1255=((((0.36)*cj6*r20))+(((-0.36)*r21*sj6)));
CheckValue<IkReal> x1258 = IKatan2WithCheck(IkReal(((-0.36)*r22)),IkReal(x1255),IKFAST_ATAN2_MAGTHRESH);
if(!x1258.valid){
continue;
}
IkReal x1256=((1.0)*(x1258.value));
if((((x1255*x1255)+(((0.1296)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x1259=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1255*x1255)+(((0.1296)*(r22*r22)))))),-1);
if(!x1259.valid){
continue;
}
if( ((pz*(x1259.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1259.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1257=IKasin((pz*(x1259.value)));
j5array[0]=((((-1.0)*x1256))+x1257);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1256))+(((-1.0)*x1257)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1260=IKsin(j5);
IkReal x1261=((0.72)*pz);
evalcond[0]=((((-1.0)*r21*sj6*x1260*x1261))+(((-1.0)*r22*x1261*(IKcos(j5))))+((cj6*r20*x1260*x1261)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1262=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1262))+((cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1262)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1262))+((cj5*r02))))+IKsqr(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1262))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1262))+((cj5*r02))), ((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1262))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1263=IKsin(j1);
IkReal x1264=IKcos(j1);
IkReal x1265=((0.36)*sj5);
IkReal x1266=((0.36)*cj5);
IkReal x1267=(pz*sj6);
IkReal x1268=(cj6*r10);
IkReal x1269=(r01*sj6);
IkReal x1270=((1.0)*r20);
IkReal x1271=(cj6*pz);
IkReal x1272=(cj6*r00);
IkReal x1273=(r11*sj6);
IkReal x1274=((0.36)*x1264);
IkReal x1275=((0.36)*x1263);
evalcond[0]=((((-1.0)*pz*r22))+(((-1.0)*r12*x1274))+((r02*x1275))+(((-1.0)*x1266)));
evalcond[1]=(x1275+((x1265*x1272))+(((-1.0)*x1265*x1269))+(((-1.0)*r02*x1266)));
evalcond[2]=((((-1.0)*r12*x1266))+(((-1.0)*x1274))+(((-1.0)*x1265*x1273))+((x1265*x1268)));
evalcond[3]=(((cj6*r01*x1275))+(((-1.0)*x1267*x1270))+((r00*sj6*x1275))+(((-1.0)*r21*x1271))+(((-1.0)*cj6*r11*x1274))+(((-1.0)*r10*sj6*x1274)));
evalcond[4]=((((-1.0)*x1268*x1274))+x1265+((r21*x1267))+(((-1.0)*x1270*x1271))+((x1272*x1275))+((x1273*x1274))+(((-1.0)*x1269*x1275)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1276=((0.72)*pz);
CheckValue<IkReal> x1278 = IKatan2WithCheck(IkReal(((-0.72)*pz*r22)),IkReal(((((-1.0)*r21*sj6*x1276))+((cj6*r20*x1276)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1278.valid){
continue;
}
IkReal x1277=x1278.value;
j5array[0]=((-1.0)*x1277);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1277)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1279=IKsin(j5);
IkReal x1280=((0.36)*x1279);
evalcond[0]=(((cj6*r20*x1280))+(((-1.0)*pz))+(((-1.0)*r21*sj6*x1280))+(((-0.36)*r22*(IKcos(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1281=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1281))+((cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1281)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1281))+((cj5*r02))))+IKsqr(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1281))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1281))+((cj5*r02))), ((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1281))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1282=IKsin(j1);
IkReal x1283=IKcos(j1);
IkReal x1284=((0.36)*sj5);
IkReal x1285=((0.36)*cj5);
IkReal x1286=(pz*sj6);
IkReal x1287=(cj6*r10);
IkReal x1288=(r01*sj6);
IkReal x1289=((1.0)*r20);
IkReal x1290=(cj6*pz);
IkReal x1291=(cj6*r00);
IkReal x1292=(r11*sj6);
IkReal x1293=((0.36)*x1283);
IkReal x1294=((0.36)*x1282);
evalcond[0]=((((-1.0)*pz*r22))+(((-1.0)*r12*x1293))+((r02*x1294))+(((-1.0)*x1285)));
evalcond[1]=((((-1.0)*r02*x1285))+x1294+(((-1.0)*x1284*x1288))+((x1284*x1291)));
evalcond[2]=((((-1.0)*x1284*x1292))+(((-1.0)*x1293))+((x1284*x1287))+(((-1.0)*r12*x1285)));
evalcond[3]=((((-1.0)*r10*sj6*x1293))+(((-1.0)*r21*x1290))+((cj6*r01*x1294))+((r00*sj6*x1294))+(((-1.0)*x1286*x1289))+(((-1.0)*cj6*r11*x1293)));
evalcond[4]=(x1284+(((-1.0)*x1287*x1293))+(((-1.0)*x1288*x1294))+(((-1.0)*x1289*x1290))+((x1291*x1294))+((r21*x1286))+((x1292*x1293)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x1295=((0.36)*r22);
IkReal x1296=((1.0)*pz);
IkReal x1297=(x1295+(((-1.0)*x1296)));
IkReal x1298=((-1.0)*pz);
IkReal x1299=((((-1.0)*x1295))+(((-1.0)*x1296)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1298);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1298);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1298);
rxp2_2=0;
IkReal gconst24=x1299;
IkReal gconst25=x1297;
IkReal gconst26=x1299;
IkReal gconst27=x1297;
IkReal gconst28=x1299;
IkReal gconst29=x1297;
IkReal gconst30=x1299;
IkReal gconst31=x1297;
IkReal x1300=pz*pz*pz*pz;
IkReal x1301=r20*r20;
IkReal x1302=r22*r22;
IkReal x1303=r21*r21;
IkReal x1304=(x1300*x1301);
IkReal x1305=(x1300*x1303);
IkReal x1306=(x1300*x1302);
j6eval[0]=((IKabs(((((4.1472)*x1304))+(((-12.4416)*x1306))+(((-16.5888)*x1305)))))+(((2.0)*(IKabs(((((-8.2944)*x1306))+(((-8.2944)*x1305)))))))+(((33.1776)*(IKabs((r20*r21*x1300)))))+(IKabs(((((-2.0736)*x1304))+(((-2.0736)*x1306))))));
if( IKabs(j6eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j5, j6]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x1307=pz*pz;
IkReal x1308=r20*r20;
IkReal x1309=r22*r22;
IkReal x1310=r21*r21;
IkReal x1311=pz*pz*pz*pz;
IkReal x1312=((0.5184)*gconst31);
IkReal x1313=((1.0368)*gconst29);
IkReal x1314=(gconst25*gconst26);
IkReal x1315=((1.0368)*gconst28);
IkReal x1316=((0.5184)*gconst24);
IkReal x1317=((1.0368)*gconst25);
IkReal x1318=((0.5184)*gconst27);
IkReal x1319=((0.5184)*gconst30);
IkReal x1320=((0.5184)*gconst26);
IkReal x1321=(gconst26*x1307);
IkReal x1322=(gconst29*x1307);
IkReal x1323=(gconst30*x1308);
IkReal x1324=(gconst30*x1307);
IkReal x1325=(gconst25*x1307);
IkReal x1326=((4.1472)*x1308);
IkReal x1327=((2.0736)*x1308);
IkReal x1328=((8.2944)*x1310);
IkReal x1329=(x1307*x1309);
IkReal x1330=(gconst25*x1328);
IkReal x1331=((0.746496)*r22*x1308);
IkReal x1332=((2.985984)*r22*x1310);
IkReal x1333=(r20*r21*x1311);
IkReal x1334=((8.2944)*x1333);
IkReal x1335=((-8.2944)*x1333);
IkReal x1336=((1.0368)*gconst24*x1329);
IkReal x1337=(x1322*x1331);
IkReal x1338=((0.746496)*r22*x1307*x1323);
IkReal x1339=(x1324*x1332);
IkReal x1340=(x1325*x1331);
IkReal x1341=(gconst28*x1312*x1329);
IkReal x1342=(x1309*x1319*x1322);
IkReal x1343=(gconst28*x1319*x1329);
IkReal x1344=((2.0736)*x1322*x1323);
IkReal x1345=(x1322*x1332);
IkReal x1346=(x1309*x1312*x1322);
IkReal x1347=(x1321*x1331);
IkReal x1348=(x1321*x1332);
IkReal x1349=((1.07495424)*x1310*x1329);
IkReal x1350=(x1309*x1316*x1324);
IkReal x1351=(x1309*x1312*x1325);
IkReal x1352=(gconst29*x1321*x1327);
IkReal x1353=(x1309*x1320*x1322);
IkReal x1354=(x1325*x1332);
IkReal x1355=(gconst24*x1312*x1329);
IkReal x1356=(x1309*x1318*x1322);
IkReal x1357=((2.0736)*x1323*x1325);
IkReal x1358=(gconst28*x1320*x1329);
IkReal x1359=(x1309*x1319*x1325);
IkReal x1360=(gconst28*x1318*x1329);
IkReal x1361=((0.26873856)*x1308*x1329);
IkReal x1362=(x1309*x1318*x1325);
IkReal x1363=(x1309*x1316*x1321);
IkReal x1364=((0.5184)*x1314*x1329);
IkReal x1365=(x1307*x1314*x1327);
IkReal x1366=(gconst27*x1316*x1329);
IkReal x1367=(x1345+x1338);
IkReal x1368=(x1347+x1354);
IkReal x1369=(x1339+x1337);
IkReal x1370=(x1348+x1340);
IkReal x1371=(x1366+x1364+x1365+x1362+x1363);
IkReal x1372=(x1341+x1342+x1343+x1344+x1346);
IkReal x1373=(x1359+x1358+x1353+x1352+x1351+x1350+x1357+x1356+x1355+x1360);
op[0]=(x1361+x1338+(((-1.0)*x1372))+(((-1.0)*x1337)));
op[1]=x1335;
op[2]=(x1349+x1347+x1369+(((-1.0)*x1340))+(((-1.0)*gconst31*x1315*x1329))+(((-1.0)*gconst30*x1322*x1328))+(((-1.0)*x1373))+(((-1.0)*x1309*x1315*x1324))+(((-1.0)*gconst31*x1313*x1329))+(((-1.0)*x1309*x1313*x1324))+(((4.1472)*x1322*x1323))+(((-1.0)*x1367)));
op[3]=x1335;
op[4]=(x1369+x1370+(((-1.0368)*gconst24*x1309*x1324))+(((-1.0)*gconst31*x1317*x1329))+(((-1.0)*x1324*x1330))+(((-1.0)*x1309*x1317*x1324))+(((-1.0)*x1372))+(((-1.0)*x1371))+(((-1.0)*x1309*x1315*x1321))+(((-1.0)*x1309*x1313*x1321))+(((-1.0)*gconst31*x1336))+(((-1.0)*gconst27*x1313*x1329))+(((-1.0)*gconst29*x1321*x1328))+((gconst29*x1321*x1326))+(((-0.53747712)*x1308*x1329))+(((4.1472)*x1323*x1325))+(((2.14990848)*x1310*x1329))+(((-1.0)*gconst27*x1315*x1329))+(((-1.0)*x1367))+(((-1.0)*x1368)));
op[5]=x1334;
op[6]=(x1349+x1370+x1338+(((-1.0368)*gconst24*x1309*x1321))+(((-1.0)*x1307*x1314*x1328))+(((-1.0)*x1373))+(((-1.0)*gconst27*x1317*x1329))+(((-1.0)*x1337))+(((-1.0368)*x1314*x1329))+((x1307*x1314*x1326))+(((-1.0)*gconst27*x1336))+(((-1.0)*x1368)));
op[7]=x1334;
op[8]=(x1347+x1361+(((-1.0)*x1340))+(((-1.0)*x1371)));
polyroots8(op,zeror,numroots);
IkReal j6array[8], cj6array[8], sj6array[8], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[8]={true,true,true,true,true,true,true,true};
_nj6 = 8;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5eval[1];
IkReal x1374=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1374);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1374);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1374);
rxp2_2=0;
j5eval[0]=((IKabs((pz*r22)))+(IKabs((((cj6*pz*r20))+(((-1.0)*pz*r21*sj6))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1375=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1375);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1375);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1375);
rxp2_2=0;
IkReal x1376=(r21*sj6);
IkReal x1377=(cj6*r20);
j5eval[0]=((IKabs(r22))+(((2.77777777777778)*(IKabs(((((0.36)*x1377))+(((-0.36)*x1376))))))));
j5eval[1]=((x1376*x1376)+(((-2.0)*x1376*x1377))+(r22*r22)+(x1377*x1377));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1378=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1378);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1378);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1378);
rxp2_2=0;
IkReal x1379=cj6*cj6;
IkReal x1380=sj6*sj6;
IkReal x1381=((0.36)*cj6);
IkReal x1382=(r00*sj6);
IkReal x1383=((2.0)*cj6);
IkReal x1384=(r10*sj6);
j1eval[0]=(((r11*x1383*x1384))+((x1380*(r10*r10)))+((x1379*(r11*r11)))+((r01*x1382*x1383))+((x1379*(r01*r01)))+((x1380*(r00*r00))));
j1eval[1]=((IKabs(((((-1.0)*r11*x1381))+(((-0.36)*x1384)))))+(IKabs((((r01*x1381))+(((0.36)*x1382))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((IKabs(r22))+(((2.77777777777778)*(IKabs(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1385=((0.36)*cj6);
IkReal x1386=((0.36)*sj6);
j1eval[0]=((IKabs((((r00*x1386))+((r01*x1385)))))+(IKabs(((((-1.0)*r11*x1385))+(((-1.0)*r10*x1386))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1, j5]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1387=((0.36)*cj6);
IkReal x1388=((0.36)*sj6);
CheckValue<IkReal> x1390 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1387))+(((-1.0)*r10*x1388)))),IkReal((((r00*x1388))+((r01*x1387)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1390.valid){
continue;
}
IkReal x1389=x1390.value;
j1array[0]=((-1.0)*x1389);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1389)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=((-1.0)*cj1*r12);
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1391=IKsin(j5);
IkReal x1392=((0.36)*x1391);
evalcond[0]=x1392;
evalcond[1]=((((-0.36)*r12*(IKcos(j5))))+(((-0.36)*cj1)));
evalcond[2]=(((cj6*r20*x1392))+(((-1.0)*r21*sj6*x1392)));
evalcond[3]=((((-1.0)*r01*sj6*x1392))+((cj6*r00*x1392)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
sj5array[0]=((((-1.0)*cj1*r11*sj6))+((cj1*cj6*r10))+((r01*sj1*sj6))+(((-1.0)*cj6*r00*sj1)));
if( sj5array[0] >= -1-IKFAST_SINCOS_THRESH && sj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKasin(sj5array[0]);
    cj5array[0] = IKcos(j5array[0]);
    sj5array[1] = sj5array[0];
    j5array[1] = j5array[0] > 0 ? (IKPI-j5array[0]) : (-IKPI-j5array[0]);
    cj5array[1] = -cj5array[0];
}
else if( isnan(sj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x1393=IKcos(j5);
IkReal x1394=IKsin(j5);
IkReal x1395=((-0.36)*x1393);
IkReal x1396=((0.36)*sj6*x1394);
IkReal x1397=((0.36)*cj6*x1394);
evalcond[0]=x1395;
evalcond[1]=(r22*x1395);
evalcond[2]=((((0.36)*sj1))+(((-1.0)*r01*x1396))+((r00*x1397)));
evalcond[3]=(((r10*x1397))+(((-0.36)*cj1))+(((-1.0)*r11*x1396)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1398=(r02*sj1);
IkReal x1399=((9.0)*cj1);
CheckValue<IkReal> x1400=IKPowWithIntegerCheck(((((9.0)*cj6*r10))+(((-9.0)*r11*sj6))),-1);
if(!x1400.valid){
continue;
}
if( IKabs(((x1400.value)*((x1399+(((9.0)*r12*x1398))+(((-1.0)*x1399*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1398+(((-1.0)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1400.value)*((x1399+(((9.0)*r12*x1398))+(((-1.0)*x1399*(r12*r12)))))))+IKsqr((x1398+(((-1.0)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1400.value)*((x1399+(((9.0)*r12*x1398))+(((-1.0)*x1399*(r12*r12)))))), (x1398+(((-1.0)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1401=IKcos(j5);
IkReal x1402=IKsin(j5);
IkReal x1403=((0.36)*cj6);
IkReal x1404=((0.36)*sj6);
IkReal x1405=((0.36)*r12);
IkReal x1406=((0.36)*r02);
IkReal x1407=((0.36)*x1401);
evalcond[0]=((((-1.0)*cj1*x1405))+(((-1.0)*x1407))+((sj1*x1406)));
evalcond[1]=(((r20*x1402*x1403))+(((-1.0)*r22*x1407))+(((-1.0)*r21*x1402*x1404)));
evalcond[2]=((((0.36)*sj1))+(((-1.0)*r01*x1402*x1404))+((r00*x1402*x1403))+(((-1.0)*x1401*x1406)));
evalcond[3]=((((-1.0)*r11*x1402*x1404))+(((-1.0)*x1401*x1405))+((r10*x1402*x1403))+(((-0.36)*cj1)));
evalcond[4]=(((r00*sj1*x1403))+(((-1.0)*cj1*r10*x1403))+((cj1*r11*x1404))+(((-1.0)*r01*sj1*x1404))+(((0.36)*x1402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1408=((9.0)*sj1);
IkReal x1409=(cj1*r12);
CheckValue<IkReal> x1410=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1410.valid){
continue;
}
if( IKabs(((x1410.value)*(((((-1.0)*x1408))+((x1408*(r02*r02)))+(((-9.0)*r02*x1409)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1409))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1410.value)*(((((-1.0)*x1408))+((x1408*(r02*r02)))+(((-9.0)*r02*x1409))))))+IKsqr(((((-1.0)*x1409))+((r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1410.value)*(((((-1.0)*x1408))+((x1408*(r02*r02)))+(((-9.0)*r02*x1409))))), ((((-1.0)*x1409))+((r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1411=IKcos(j5);
IkReal x1412=IKsin(j5);
IkReal x1413=((0.36)*cj6);
IkReal x1414=((0.36)*sj6);
IkReal x1415=((0.36)*r12);
IkReal x1416=((0.36)*r02);
IkReal x1417=((0.36)*x1411);
evalcond[0]=((((-1.0)*x1417))+(((-1.0)*cj1*x1415))+((sj1*x1416)));
evalcond[1]=((((-1.0)*r22*x1417))+(((-1.0)*r21*x1412*x1414))+((r20*x1412*x1413)));
evalcond[2]=((((0.36)*sj1))+(((-1.0)*r01*x1412*x1414))+(((-1.0)*x1411*x1416))+((r00*x1412*x1413)));
evalcond[3]=((((-1.0)*r11*x1412*x1414))+((r10*x1412*x1413))+(((-1.0)*x1411*x1415))+(((-0.36)*cj1)));
evalcond[4]=((((-1.0)*r01*sj1*x1414))+(((-1.0)*cj1*r10*x1413))+((cj1*r11*x1414))+(((0.36)*x1412))+((r00*sj1*x1413)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1418=(r02*sj1);
IkReal x1419=((0.36)*r22);
IkReal x1420=(cj1*r12);
CheckValue<IkReal> x1421=IKPowWithIntegerCheck(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))),-1);
if(!x1421.valid){
continue;
}
if( IKabs(((x1421.value)*((((x1418*x1419))+(((-1.0)*x1419*x1420)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1420))+x1418)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1421.value)*((((x1418*x1419))+(((-1.0)*x1419*x1420))))))+IKsqr(((((-1.0)*x1420))+x1418))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1421.value)*((((x1418*x1419))+(((-1.0)*x1419*x1420))))), ((((-1.0)*x1420))+x1418));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1422=IKcos(j5);
IkReal x1423=IKsin(j5);
IkReal x1424=((0.36)*cj6);
IkReal x1425=((0.36)*sj6);
IkReal x1426=((0.36)*r12);
IkReal x1427=((0.36)*r02);
IkReal x1428=((0.36)*x1422);
evalcond[0]=(((sj1*x1427))+(((-1.0)*cj1*x1426))+(((-1.0)*x1428)));
evalcond[1]=((((-1.0)*r21*x1423*x1425))+(((-1.0)*r22*x1428))+((r20*x1423*x1424)));
evalcond[2]=((((0.36)*sj1))+((r00*x1423*x1424))+(((-1.0)*x1422*x1427))+(((-1.0)*r01*x1423*x1425)));
evalcond[3]=(((r10*x1423*x1424))+(((-1.0)*r11*x1423*x1425))+(((-1.0)*x1422*x1426))+(((-0.36)*cj1)));
evalcond[4]=((((-1.0)*r01*sj1*x1425))+((r00*sj1*x1424))+(((-1.0)*cj1*r10*x1424))+((cj1*r11*x1425))+(((0.36)*x1423)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1430 = IKatan2WithCheck(IkReal(((-0.36)*r22)),IkReal(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1430.valid){
continue;
}
IkReal x1429=x1430.value;
j5array[0]=((-1.0)*x1429);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1429)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1431=((1.0)*sj6);
IkReal x1432=(cj6*r20);
IkReal x1433=((1.0)*cj5*cj6);
j1eval[0]=(x1432+(((-1.0)*r21*x1431)));
j1eval[1]=IKsign(((((0.36)*x1432))+(((-0.36)*r21*sj6))));
j1eval[2]=((IKabs(((((-1.0)*cj5*r00*x1431))+(((-1.0)*r01*x1433)))))+(IKabs(((((-1.0)*r11*x1433))+(((-1.0)*cj5*r10*x1431))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1434=((9.0)*sj5);
IkReal x1435=(r20*sj6);
IkReal x1436=(cj6*r21);
IkReal x1437=((9.0)*cj5*cj6);
IkReal x1438=((9.0)*cj5*sj6);
j1eval[0]=((((-1.0)*x1436))+(((-1.0)*x1435)));
j1eval[1]=IKsign(((((-9.0)*x1435))+(((-9.0)*x1436))));
j1eval[2]=((IKabs(((((-1.0)*r12*x1434))+((r11*x1438))+(((-1.0)*r10*x1437)))))+(IKabs(((((-1.0)*r02*x1434))+(((-1.0)*r00*x1437))+((r01*x1438))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j1eval[0]=r12;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs((((r01*sj6))+(((-1.0)*cj6*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r11*sj6))+((cj6*r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj6))+(((-1.0)*cj6*r00))))+IKsqr(((((-1.0)*r11*sj6))+((cj6*r10))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj6))+(((-1.0)*cj6*r00))), ((((-1.0)*r11*sj6))+((cj6*r10))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1439=IKsin(j1);
IkReal x1440=IKcos(j1);
IkReal x1441=(cj6*r00);
IkReal x1442=(cj6*r10);
IkReal x1443=((0.36)*sj6);
IkReal x1444=((0.36)*x1439);
IkReal x1445=((0.36)*x1440);
evalcond[0]=((((-1.0)*r12*x1445))+((r02*x1444)));
evalcond[1]=((((-1.0)*r01*x1443))+x1444+(((0.36)*x1441)));
evalcond[2]=((((-1.0)*r11*x1443))+(((0.36)*x1442))+(((-1.0)*x1445)));
evalcond[3]=(((cj6*r01*x1444))+(((-1.0)*r10*x1440*x1443))+((r00*x1439*x1443))+(((-1.0)*cj6*r11*x1445)));
evalcond[4]=((0.36)+((x1441*x1444))+(((-1.0)*r01*x1439*x1443))+(((-1.0)*x1442*x1445))+((r11*x1440*x1443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((((-1.0)*r01*sj6))+((cj6*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj6*r10))+((r11*sj6)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj6))+((cj6*r00))))+IKsqr(((((-1.0)*cj6*r10))+((r11*sj6))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*r01*sj6))+((cj6*r00))), ((((-1.0)*cj6*r10))+((r11*sj6))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1446=IKsin(j1);
IkReal x1447=IKcos(j1);
IkReal x1448=(cj6*r00);
IkReal x1449=(cj6*r10);
IkReal x1450=((0.36)*sj6);
IkReal x1451=((0.36)*x1446);
IkReal x1452=((0.36)*x1447);
evalcond[0]=(((r02*x1451))+(((-1.0)*r12*x1452)));
evalcond[1]=(((r01*x1450))+(((-0.36)*x1448))+x1451);
evalcond[2]=((((-1.0)*x1452))+((r11*x1450))+(((-0.36)*x1449)));
evalcond[3]=(((r00*x1446*x1450))+((cj6*r01*x1451))+(((-1.0)*cj6*r11*x1452))+(((-1.0)*r10*x1447*x1450)));
evalcond[4]=((-0.36)+((x1448*x1451))+(((-1.0)*r01*x1446*x1450))+(((-1.0)*x1449*x1452))+((r11*x1447*x1450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1453=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1453)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1453)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1453))))+IKsqr((((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1453))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1453))), (((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1453))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1454=IKsin(j1);
IkReal x1455=IKcos(j1);
IkReal x1456=(cj6*r00);
IkReal x1457=((0.36)*sj5);
IkReal x1458=(r11*sj6);
IkReal x1459=(r01*sj6);
IkReal x1460=(cj6*r10);
IkReal x1461=((0.36)*x1454);
IkReal x1462=((0.36)*x1455);
evalcond[0]=(((x1456*x1457))+(((-1.0)*x1457*x1459))+x1461);
evalcond[1]=((((-1.0)*x1457*x1458))+(((-1.0)*x1462))+((x1457*x1460)));
evalcond[2]=((((-1.0)*r10*sj6*x1462))+(((-1.0)*cj6*r11*x1462))+((r00*sj6*x1461))+((cj6*r01*x1461)));
evalcond[3]=((((-1.0)*x1459*x1461))+((x1458*x1462))+((x1456*x1461))+(((-1.0)*x1460*x1462))+x1457);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1463=(r01*sj6);
IkReal x1464=(cj6*r00);
IkReal x1465=((9.0)*cj5);
IkReal x1466=((9.0)*r02*sj5);
CheckValue<IkReal> x1467=IKPowWithIntegerCheck(r12,-1);
if(!x1467.valid){
continue;
}
if( IKabs((((sj5*x1463))+(((-1.0)*sj5*x1464))+((cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.111111111111111)*(x1467.value)*((((x1463*x1466))+(((-1.0)*x1465))+(((-1.0)*x1464*x1466))+((x1465*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj5*x1463))+(((-1.0)*sj5*x1464))+((cj5*r02))))+IKsqr(((0.111111111111111)*(x1467.value)*((((x1463*x1466))+(((-1.0)*x1465))+(((-1.0)*x1464*x1466))+((x1465*(r02*r02)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((sj5*x1463))+(((-1.0)*sj5*x1464))+((cj5*r02))), ((0.111111111111111)*(x1467.value)*((((x1463*x1466))+(((-1.0)*x1465))+(((-1.0)*x1464*x1466))+((x1465*(r02*r02)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1468=IKsin(j1);
IkReal x1469=IKcos(j1);
IkReal x1470=(cj6*r00);
IkReal x1471=((0.36)*sj5);
IkReal x1472=(r01*sj6);
IkReal x1473=(r11*sj6);
IkReal x1474=(cj6*r10);
IkReal x1475=((0.36)*cj5);
IkReal x1476=((0.36)*x1468);
IkReal x1477=((0.36)*x1469);
evalcond[0]=(((r02*x1476))+(((-1.0)*r12*x1477))+(((-1.0)*x1475)));
evalcond[1]=((((-1.0)*x1471*x1472))+((x1470*x1471))+x1476+(((-1.0)*r02*x1475)));
evalcond[2]=(((x1471*x1474))+(((-1.0)*x1471*x1473))+(((-1.0)*r12*x1475))+(((-1.0)*x1477)));
evalcond[3]=(((r00*sj6*x1476))+((cj6*r01*x1476))+(((-1.0)*r10*sj6*x1477))+(((-1.0)*cj6*r11*x1477)));
evalcond[4]=((((-1.0)*x1474*x1477))+((x1470*x1476))+((x1473*x1477))+x1471+(((-1.0)*x1472*x1476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1478=((9.0)*sj5);
IkReal x1479=((9.0)*sj6);
IkReal x1480=((9.0)*cj5*cj6);
CheckValue<IkReal> x1481=IKPowWithIntegerCheck(IKsign(((((-1.0)*r20*x1479))+(((-9.0)*cj6*r21)))),-1);
if(!x1481.valid){
continue;
}
CheckValue<IkReal> x1482 = IKatan2WithCheck(IkReal(((((-1.0)*r12*x1478))+((cj5*r11*x1479))+(((-1.0)*r10*x1480)))),IkReal(((((-1.0)*r00*x1480))+((cj5*r01*x1479))+(((-1.0)*r02*x1478)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1482.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1481.value)))+(x1482.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1483=IKsin(j1);
IkReal x1484=IKcos(j1);
IkReal x1485=(cj6*r00);
IkReal x1486=((0.36)*sj5);
IkReal x1487=(r01*sj6);
IkReal x1488=(r11*sj6);
IkReal x1489=(cj6*r10);
IkReal x1490=((0.36)*cj5);
IkReal x1491=((0.36)*x1483);
IkReal x1492=((0.36)*x1484);
evalcond[0]=((((-1.0)*r12*x1492))+(((-1.0)*x1490))+((r02*x1491)));
evalcond[1]=((((-1.0)*x1486*x1487))+(((-1.0)*r02*x1490))+((x1485*x1486))+x1491);
evalcond[2]=((((-1.0)*r12*x1490))+(((-1.0)*x1492))+(((-1.0)*x1486*x1488))+((x1486*x1489)));
evalcond[3]=((((-1.0)*cj6*r11*x1492))+((cj6*r01*x1491))+((r00*sj6*x1491))+(((-1.0)*r10*sj6*x1492)));
evalcond[4]=((((-1.0)*x1487*x1491))+((x1485*x1491))+x1486+((x1488*x1492))+(((-1.0)*x1489*x1492)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1493=((0.36)*sj6);
IkReal x1494=((0.36)*cj6);
CheckValue<IkReal> x1495=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*x1493))+((r20*x1494)))),-1);
if(!x1495.valid){
continue;
}
CheckValue<IkReal> x1496 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r11*x1494))+(((-1.0)*cj5*r10*x1493)))),IkReal(((((-1.0)*cj5*r01*x1494))+(((-1.0)*cj5*r00*x1493)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1496.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1495.value)))+(x1496.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1497=IKsin(j1);
IkReal x1498=IKcos(j1);
IkReal x1499=(cj6*r00);
IkReal x1500=((0.36)*sj5);
IkReal x1501=(r01*sj6);
IkReal x1502=(r11*sj6);
IkReal x1503=(cj6*r10);
IkReal x1504=((0.36)*cj5);
IkReal x1505=((0.36)*x1497);
IkReal x1506=((0.36)*x1498);
evalcond[0]=((((-1.0)*x1504))+((r02*x1505))+(((-1.0)*r12*x1506)));
evalcond[1]=(((x1499*x1500))+(((-1.0)*r02*x1504))+x1505+(((-1.0)*x1500*x1501)));
evalcond[2]=((((-1.0)*x1506))+((x1500*x1503))+(((-1.0)*x1500*x1502))+(((-1.0)*r12*x1504)));
evalcond[3]=(((cj6*r01*x1505))+(((-1.0)*cj6*r11*x1506))+(((-1.0)*r10*sj6*x1506))+((r00*sj6*x1505)));
evalcond[4]=(((x1499*x1505))+(((-1.0)*x1501*x1505))+x1500+(((-1.0)*x1503*x1506))+((x1502*x1506)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x1507=((0.36)*cj6);
IkReal x1508=((1.0)*pz);
IkReal x1509=((0.36)*sj6);
IkReal x1510=((((-1.0)*r11*x1507))+(((-1.0)*r10*x1509)));
IkReal x1511=(((r01*x1507))+((r00*x1509)));
CheckValue<IkReal> x1514 = IKatan2WithCheck(IkReal(x1510),IkReal(x1511),IKFAST_ATAN2_MAGTHRESH);
if(!x1514.valid){
continue;
}
IkReal x1512=((1.0)*(x1514.value));
if((((x1511*x1511)+(x1510*x1510))) < -0.00001)
continue;
CheckValue<IkReal> x1515=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1511*x1511)+(x1510*x1510)))),-1);
if(!x1515.valid){
continue;
}
if( (((-1.0)*(x1515.value)*(((((-1.0)*r20*sj6*x1508))+(((-1.0)*cj6*r21*x1508)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1515.value)*(((((-1.0)*r20*sj6*x1508))+(((-1.0)*cj6*r21*x1508)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1513=((-1.0)*(IKasin(((-1.0)*(x1515.value)*(((((-1.0)*r20*sj6*x1508))+(((-1.0)*cj6*r21*x1508))))))));
j1array[0]=((((-1.0)*x1512))+(((-1.0)*x1513)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x1512))+(((1.0)*x1513)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5eval[1];
IkReal x1516=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1516);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1516);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1516);
rxp2_2=0;
j5eval[0]=(((cj6*r20))+(((-1.0)*r21*sj6)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1517=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1517);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1517);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1517);
rxp2_2=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1518=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1518);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1518);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1518);
rxp2_2=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x1521 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1521)==0){
continue;
}
IkReal x1519=pow(x1521,-0.5);
IkReal x1520=((-1.0)*x1519);
CheckValue<IkReal> x1522 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1522.valid){
continue;
}
IkReal gconst48=((-1.0)*(x1522.value));
IkReal gconst49=(r10*x1520);
IkReal gconst50=(r11*x1520);
CheckValue<IkReal> x1523 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1523.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j6+(x1523.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1524=((0.36)*r22);
IkReal x1525=(r02*sj1);
IkReal x1526=(cj1*r12);
CheckValue<IkReal> x1527=IKPowWithIntegerCheck(((((-0.36)*gconst49*r21))+(((0.36)*gconst50*r20))),-1);
if(!x1527.valid){
continue;
}
if( IKabs(((x1527.value)*((((x1524*x1525))+(((-1.0)*x1524*x1526))+(((-1.0)*pz*(r22*r22)))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1525+(((-2.77777777777778)*pz*r22))+(((-1.0)*x1526)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1527.value)*((((x1524*x1525))+(((-1.0)*x1524*x1526))+(((-1.0)*pz*(r22*r22)))+pz))))+IKsqr((x1525+(((-2.77777777777778)*pz*r22))+(((-1.0)*x1526))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1527.value)*((((x1524*x1525))+(((-1.0)*x1524*x1526))+(((-1.0)*pz*(r22*r22)))+pz))), (x1525+(((-2.77777777777778)*pz*r22))+(((-1.0)*x1526))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1528=IKcos(j5);
IkReal x1529=IKsin(j5);
IkReal x1530=(pz*r20);
IkReal x1531=((0.36)*r12);
IkReal x1532=(gconst49*r21);
IkReal x1533=((1.0)*pz);
IkReal x1534=((0.36)*r00);
IkReal x1535=((0.36)*sj1);
IkReal x1536=(gconst49*r01);
IkReal x1537=(gconst49*r11);
IkReal x1538=((0.36)*cj1);
IkReal x1539=((0.72)*pz);
IkReal x1540=(gconst50*x1529);
IkReal x1541=((0.36)*x1528);
IkReal x1542=((0.36)*x1529);
evalcond[0]=((((-1.0)*r22*x1533))+((r02*x1535))+(((-1.0)*x1541))+(((-1.0)*cj1*x1531)));
evalcond[1]=((((-1.0)*x1533))+(((-1.0)*r22*x1541))+(((-1.0)*x1532*x1542))+(((0.36)*r20*x1540)));
evalcond[2]=((((-1.0)*x1529*x1532*x1539))+(((0.72)*x1530*x1540))+(((-1.0)*r22*x1528*x1539)));
evalcond[3]=((((-1.0)*r02*x1541))+((x1534*x1540))+x1535+(((-1.0)*x1536*x1542)));
evalcond[4]=((((-1.0)*x1538))+(((-1.0)*x1537*x1542))+(((-1.0)*x1528*x1531))+(((0.36)*r10*x1540)));
evalcond[5]=(((x1537*x1538))+(((-1.0)*gconst50*r10*x1538))+(((-1.0)*x1535*x1536))+x1542+((gconst50*sj1*x1534))+(((-1.0)*gconst50*x1530))+((pz*x1532)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1545 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1545)==0){
continue;
}
IkReal x1543=pow(x1545,-0.5);
IkReal x1544=((1.0)*x1543);
CheckValue<IkReal> x1546 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1546.valid){
continue;
}
IkReal gconst51=((3.14159265358979)+(((-1.0)*(x1546.value))));
IkReal gconst52=(r10*x1544);
IkReal gconst53=(r11*x1544);
CheckValue<IkReal> x1547 = IKatan2WithCheck(IkReal(r10),IkReal(((-1.0)*r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x1547.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6+(x1547.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1548=((0.36)*r22);
IkReal x1549=(r02*sj1);
IkReal x1550=(cj1*r12);
CheckValue<IkReal> x1551=IKPowWithIntegerCheck(((((-0.36)*gconst52*r21))+(((0.36)*gconst53*r20))),-1);
if(!x1551.valid){
continue;
}
if( IKabs(((x1551.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1548*x1550))+pz+((x1548*x1549)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1550))+x1549+(((-2.77777777777778)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1551.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1548*x1550))+pz+((x1548*x1549))))))+IKsqr(((((-1.0)*x1550))+x1549+(((-2.77777777777778)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1551.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1548*x1550))+pz+((x1548*x1549))))), ((((-1.0)*x1550))+x1549+(((-2.77777777777778)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1552=IKsin(j5);
IkReal x1553=IKcos(j5);
IkReal x1554=((0.36)*r12);
IkReal x1555=((0.36)*gconst52);
IkReal x1556=((0.36)*r00);
IkReal x1557=((0.72)*pz);
IkReal x1558=((1.0)*pz);
IkReal x1559=((0.36)*sj1);
IkReal x1560=((0.36)*r10);
IkReal x1561=((0.36)*x1553);
IkReal x1562=(gconst53*x1552);
IkReal x1563=(r21*x1552);
evalcond[0]=((((-1.0)*r22*x1558))+(((-1.0)*cj1*x1554))+((r02*x1559))+(((-1.0)*x1561)));
evalcond[1]=((((-1.0)*x1555*x1563))+(((0.36)*r20*x1562))+(((-1.0)*r22*x1561))+(((-1.0)*x1558)));
evalcond[2]=(((r20*x1557*x1562))+(((-1.0)*r22*x1553*x1557))+(((-1.0)*gconst52*x1557*x1563)));
evalcond[3]=(((x1556*x1562))+(((-1.0)*r02*x1561))+x1559+(((-1.0)*r01*x1552*x1555)));
evalcond[4]=(((x1560*x1562))+(((-1.0)*x1553*x1554))+(((-1.0)*r11*x1552*x1555))+(((-0.36)*cj1)));
evalcond[5]=(((gconst53*sj1*x1556))+((gconst52*pz*r21))+(((-1.0)*cj1*gconst53*x1560))+(((-1.0)*r01*sj1*x1555))+(((0.36)*x1552))+(((-1.0)*gconst53*r20*x1558))+((cj1*r11*x1555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1566 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1566)==0){
continue;
}
IkReal x1564=pow(x1566,-0.5);
IkReal x1565=((-1.0)*x1564);
CheckValue<IkReal> x1567 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1567.valid){
continue;
}
IkReal gconst54=((-1.0)*(x1567.value));
IkReal gconst55=(r00*x1565);
IkReal gconst56=(r01*x1565);
CheckValue<IkReal> x1568 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1568.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1568.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1569=((0.36)*r22);
IkReal x1570=(r02*sj1);
IkReal x1571=(cj1*r12);
CheckValue<IkReal> x1572=IKPowWithIntegerCheck(((((-0.36)*gconst55*r21))+(((0.36)*gconst56*r20))),-1);
if(!x1572.valid){
continue;
}
if( IKabs(((x1572.value)*((((x1569*x1570))+(((-1.0)*pz*(r22*r22)))+(((-1.0)*x1569*x1571))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1570+(((-2.77777777777778)*pz*r22))+(((-1.0)*x1571)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1572.value)*((((x1569*x1570))+(((-1.0)*pz*(r22*r22)))+(((-1.0)*x1569*x1571))+pz))))+IKsqr((x1570+(((-2.77777777777778)*pz*r22))+(((-1.0)*x1571))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1572.value)*((((x1569*x1570))+(((-1.0)*pz*(r22*r22)))+(((-1.0)*x1569*x1571))+pz))), (x1570+(((-2.77777777777778)*pz*r22))+(((-1.0)*x1571))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1573=IKsin(j5);
IkReal x1574=IKcos(j5);
IkReal x1575=((0.36)*cj1);
IkReal x1576=(gconst55*r11);
IkReal x1577=(gconst56*r00);
IkReal x1578=(gconst56*r10);
IkReal x1579=(gconst55*r21);
IkReal x1580=(gconst55*r01);
IkReal x1581=((0.36)*sj1);
IkReal x1582=(gconst56*r20);
IkReal x1583=((1.0)*pz);
IkReal x1584=((0.36)*x1574);
IkReal x1585=((0.36)*x1573);
IkReal x1586=((0.72)*pz*x1573);
evalcond[0]=((((-1.0)*x1584))+((r02*x1581))+(((-1.0)*r22*x1583))+(((-1.0)*r12*x1575)));
evalcond[1]=((((-1.0)*x1583))+((x1582*x1585))+(((-1.0)*x1579*x1585))+(((-1.0)*r22*x1584)));
evalcond[2]=(((x1582*x1586))+(((-0.72)*pz*r22*x1574))+(((-1.0)*x1579*x1586)));
evalcond[3]=((((-1.0)*x1580*x1585))+(((-1.0)*r02*x1584))+x1581+((x1577*x1585)));
evalcond[4]=((((-1.0)*x1575))+((x1578*x1585))+(((-1.0)*x1576*x1585))+(((-1.0)*r12*x1584)));
evalcond[5]=((((-1.0)*x1580*x1581))+(((-1.0)*x1575*x1578))+((x1575*x1576))+x1585+((x1577*x1581))+((pz*x1579))+(((-1.0)*x1582*x1583)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1589 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1589)==0){
continue;
}
IkReal x1587=pow(x1589,-0.5);
IkReal x1588=((1.0)*x1587);
CheckValue<IkReal> x1590 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1590.valid){
continue;
}
IkReal gconst57=((3.14159265358979)+(((-1.0)*(x1590.value))));
IkReal gconst58=(r00*x1588);
IkReal gconst59=(r01*x1588);
CheckValue<IkReal> x1591 = IKatan2WithCheck(IkReal(r00),IkReal(((-1.0)*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x1591.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1591.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1592=((0.36)*r22);
IkReal x1593=(r02*sj1);
IkReal x1594=(cj1*r12);
CheckValue<IkReal> x1595=IKPowWithIntegerCheck(((((-0.36)*gconst58*r21))+(((0.36)*gconst59*r20))),-1);
if(!x1595.valid){
continue;
}
if( IKabs(((x1595.value)*(((((-1.0)*x1592*x1594))+((x1592*x1593))+(((-1.0)*pz*(r22*r22)))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1593+(((-1.0)*x1594))+(((-2.77777777777778)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1595.value)*(((((-1.0)*x1592*x1594))+((x1592*x1593))+(((-1.0)*pz*(r22*r22)))+pz))))+IKsqr((x1593+(((-1.0)*x1594))+(((-2.77777777777778)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1595.value)*(((((-1.0)*x1592*x1594))+((x1592*x1593))+(((-1.0)*pz*(r22*r22)))+pz))), (x1593+(((-1.0)*x1594))+(((-2.77777777777778)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1596=IKsin(j5);
IkReal x1597=IKcos(j5);
IkReal x1598=((0.36)*cj1);
IkReal x1599=(gconst59*r10);
IkReal x1600=((0.36)*sj1);
IkReal x1601=(gconst59*r00);
IkReal x1602=((1.0)*pz);
IkReal x1603=(gconst59*r20);
IkReal x1604=(gconst58*r21);
IkReal x1605=(gconst58*r01);
IkReal x1606=(gconst58*r11);
IkReal x1607=((0.36)*x1597);
IkReal x1608=((0.36)*x1596);
IkReal x1609=((0.72)*pz*x1596);
evalcond[0]=((((-1.0)*x1607))+(((-1.0)*r22*x1602))+((r02*x1600))+(((-1.0)*r12*x1598)));
evalcond[1]=((((-1.0)*x1602))+(((-1.0)*r22*x1607))+((x1603*x1608))+(((-1.0)*x1604*x1608)));
evalcond[2]=(((x1603*x1609))+(((-0.72)*pz*r22*x1597))+(((-1.0)*x1604*x1609)));
evalcond[3]=(x1600+((x1601*x1608))+(((-1.0)*x1605*x1608))+(((-1.0)*r02*x1607)));
evalcond[4]=((((-1.0)*x1598))+((x1599*x1608))+(((-1.0)*x1606*x1608))+(((-1.0)*r12*x1607)));
evalcond[5]=(x1608+((x1600*x1601))+(((-1.0)*x1600*x1605))+((x1598*x1606))+(((-1.0)*x1598*x1599))+(((-1.0)*x1602*x1603))+((pz*x1604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1610=((-1.0)*r21);
IkReal x1612 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1612)==0){
continue;
}
IkReal x1611=pow(x1612,-0.5);
CheckValue<IkReal> x1613 = IKatan2WithCheck(IkReal(r20),IkReal(x1610),IKFAST_ATAN2_MAGTHRESH);
if(!x1613.valid){
continue;
}
IkReal gconst60=((-1.0)*(x1613.value));
IkReal gconst61=((-1.0)*r20*x1611);
IkReal gconst62=(x1610*x1611);
CheckValue<IkReal> x1614 = IKatan2WithCheck(IkReal(r20),IkReal(((-1.0)*r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1614.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1614.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1615=((9.0)*sj1);
IkReal x1616=(pz*r22);
IkReal x1617=(cj1*r12);
CheckValue<IkReal> x1618=IKPowWithIntegerCheck(((((-9.0)*gconst61*r01))+(((9.0)*gconst62*r00))),-1);
if(!x1618.valid){
continue;
}
if( IKabs(((x1618.value)*(((((-9.0)*r02*x1617))+(((-1.0)*x1615))+(((-25.0)*r02*x1616))+((x1615*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-2.77777777777778)*x1616))+(((-1.0)*x1617))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1618.value)*(((((-9.0)*r02*x1617))+(((-1.0)*x1615))+(((-25.0)*r02*x1616))+((x1615*(r02*r02)))))))+IKsqr(((((-2.77777777777778)*x1616))+(((-1.0)*x1617))+((r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1618.value)*(((((-9.0)*r02*x1617))+(((-1.0)*x1615))+(((-25.0)*r02*x1616))+((x1615*(r02*r02)))))), ((((-2.77777777777778)*x1616))+(((-1.0)*x1617))+((r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1619=IKsin(j5);
IkReal x1620=IKcos(j5);
IkReal x1621=((0.36)*r12);
IkReal x1622=((0.36)*sj1);
IkReal x1623=(gconst61*r01);
IkReal x1624=((1.0)*pz);
IkReal x1625=(gconst62*r20);
IkReal x1626=((0.36)*cj1);
IkReal x1627=(gconst61*pz*r21);
IkReal x1628=((0.36)*x1620);
IkReal x1629=((0.72)*x1619);
IkReal x1630=((0.36)*gconst61*r11);
IkReal x1631=((0.36)*x1619);
IkReal x1632=(gconst62*x1631);
evalcond[0]=(((r02*x1622))+(((-1.0)*x1628))+(((-1.0)*r22*x1624))+(((-1.0)*cj1*x1621)));
evalcond[1]=((((-1.0)*x1624))+(((-1.0)*gconst61*r21*x1631))+((x1625*x1631))+(((-1.0)*r22*x1628)));
evalcond[2]=(((pz*x1625*x1629))+(((-0.72)*pz*r22*x1620))+(((-1.0)*x1627*x1629)));
evalcond[3]=((((-1.0)*x1623*x1631))+x1622+(((-1.0)*r02*x1628))+((r00*x1632)));
evalcond[4]=(((r10*x1632))+(((-1.0)*x1626))+(((-1.0)*x1620*x1621))+(((-1.0)*x1619*x1630)));
evalcond[5]=(((gconst61*r11*x1626))+x1627+x1631+(((-1.0)*gconst62*r10*x1626))+(((-1.0)*x1622*x1623))+(((-1.0)*x1624*x1625))+((gconst62*r00*x1622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1635 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1635)==0){
continue;
}
IkReal x1633=pow(x1635,-0.5);
IkReal x1634=((1.0)*x1633);
CheckValue<IkReal> x1636 = IKatan2WithCheck(IkReal(r20),IkReal(((-1.0)*r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1636.valid){
continue;
}
IkReal gconst63=((3.14159265358979)+(((-1.0)*(x1636.value))));
IkReal gconst64=(r20*x1634);
IkReal gconst65=(r21*x1634);
CheckValue<IkReal> x1637 = IKatan2WithCheck(IkReal(r20),IkReal(((-1.0)*r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1637.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1637.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1638=((9.0)*sj1);
IkReal x1639=(pz*r22);
IkReal x1640=(cj1*r12);
CheckValue<IkReal> x1641=IKPowWithIntegerCheck(((((-9.0)*gconst64*r01))+(((9.0)*gconst65*r00))),-1);
if(!x1641.valid){
continue;
}
if( IKabs(((x1641.value)*((((x1638*(r02*r02)))+(((-9.0)*r02*x1640))+(((-1.0)*x1638))+(((-25.0)*r02*x1639)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-2.77777777777778)*x1639))+((r02*sj1))+(((-1.0)*x1640)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1641.value)*((((x1638*(r02*r02)))+(((-9.0)*r02*x1640))+(((-1.0)*x1638))+(((-25.0)*r02*x1639))))))+IKsqr(((((-2.77777777777778)*x1639))+((r02*sj1))+(((-1.0)*x1640))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1641.value)*((((x1638*(r02*r02)))+(((-9.0)*r02*x1640))+(((-1.0)*x1638))+(((-25.0)*r02*x1639))))), ((((-2.77777777777778)*x1639))+((r02*sj1))+(((-1.0)*x1640))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1642=IKsin(j5);
IkReal x1643=IKcos(j5);
IkReal x1644=((0.36)*gconst64);
IkReal x1645=((0.36)*r12);
IkReal x1646=((0.36)*gconst65);
IkReal x1647=((1.0)*pz);
IkReal x1648=((0.36)*sj1);
IkReal x1649=(gconst65*r20);
IkReal x1650=((0.36)*x1643);
IkReal x1651=(gconst64*pz*r21);
IkReal x1652=((0.72)*x1642);
evalcond[0]=(((r02*x1648))+(((-1.0)*r22*x1647))+(((-1.0)*cj1*x1645))+(((-1.0)*x1650)));
evalcond[1]=((((-1.0)*r21*x1642*x1644))+(((-1.0)*r22*x1650))+(((-1.0)*x1647))+((r20*x1642*x1646)));
evalcond[2]=(((pz*x1649*x1652))+(((-0.72)*pz*r22*x1643))+(((-1.0)*x1651*x1652)));
evalcond[3]=(x1648+((r00*x1642*x1646))+(((-1.0)*r01*x1642*x1644))+(((-1.0)*r02*x1650)));
evalcond[4]=((((-1.0)*r11*x1642*x1644))+((r10*x1642*x1646))+(((-1.0)*x1643*x1645))+(((-0.36)*cj1)));
evalcond[5]=((((-1.0)*x1647*x1649))+x1651+(((-1.0)*cj1*r10*x1646))+((r00*sj1*x1646))+(((0.36)*x1642))+((cj1*r11*x1644))+(((-1.0)*r01*sj1*x1644)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1653=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1653);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1653);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x1654=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1654);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1654);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r11*sj6))+((cj6*r10)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1655=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1655);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1655);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j5eval[0]=((((-1.0)*r01*sj6))+((cj6*r00)));
j5eval[1]=r22;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1656=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1656.valid){
continue;
}
CheckValue<IkReal> x1657=IKPowWithIntegerCheck(r22,-1);
if(!x1657.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1656.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.77777777777778)*pz*(x1657.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1656.value)))+IKsqr(((-2.77777777777778)*pz*(x1657.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1656.value)), ((-2.77777777777778)*pz*(x1657.value)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1658=IKcos(j5);
IkReal x1659=IKsin(j5);
IkReal x1660=((0.36)*cj6);
IkReal x1661=((1.0)*pz);
IkReal x1662=((0.36)*sj1);
IkReal x1663=(r11*sj6);
IkReal x1664=((0.36)*cj1);
IkReal x1665=(r01*sj6);
IkReal x1666=((0.36)*x1659);
IkReal x1667=((0.36)*x1658);
evalcond[0]=((-0.72)*pz*r22*x1658);
evalcond[1]=((((-1.0)*r22*x1661))+(((-1.0)*x1667)));
evalcond[2]=((((-1.0)*r22*x1667))+(((-1.0)*x1661)));
evalcond[3]=(x1662+((r00*x1659*x1660))+(((-1.0)*x1665*x1666)));
evalcond[4]=(((r10*x1659*x1660))+(((-1.0)*x1663*x1666))+(((-1.0)*x1664)));
evalcond[5]=((((-1.0)*x1662*x1665))+x1666+(((-1.0)*cj1*r10*x1660))+((r00*sj1*x1660))+((x1663*x1664)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1668=IKPowWithIntegerCheck(((((9.0)*cj6*r10))+(((-9.0)*r11*sj6))),-1);
if(!x1668.valid){
continue;
}
if( IKabs(((9.0)*cj1*(x1668.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.77777777777778)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((9.0)*cj1*(x1668.value)))+IKsqr(((-2.77777777777778)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((9.0)*cj1*(x1668.value)), ((-2.77777777777778)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1669=IKcos(j5);
IkReal x1670=IKsin(j5);
IkReal x1671=((0.36)*cj6);
IkReal x1672=((1.0)*pz);
IkReal x1673=((0.36)*sj1);
IkReal x1674=(r11*sj6);
IkReal x1675=((0.36)*cj1);
IkReal x1676=(r01*sj6);
IkReal x1677=((0.36)*x1670);
IkReal x1678=((0.36)*x1669);
evalcond[0]=((-0.72)*pz*r22*x1669);
evalcond[1]=((((-1.0)*x1678))+(((-1.0)*r22*x1672)));
evalcond[2]=((((-1.0)*x1672))+(((-1.0)*r22*x1678)));
evalcond[3]=(x1673+((r00*x1670*x1671))+(((-1.0)*x1676*x1677)));
evalcond[4]=(((r10*x1670*x1671))+(((-1.0)*x1674*x1677))+(((-1.0)*x1675)));
evalcond[5]=((((-1.0)*cj1*r10*x1671))+(((-1.0)*x1673*x1676))+((x1674*x1675))+x1677+((r00*sj1*x1671)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x1679=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1679.valid){
continue;
}
if( IKabs(((-9.0)*sj1*(x1679.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.77777777777778)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-9.0)*sj1*(x1679.value)))+IKsqr(((-2.77777777777778)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-9.0)*sj1*(x1679.value)), ((-2.77777777777778)*pz*r22));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1680=IKcos(j5);
IkReal x1681=IKsin(j5);
IkReal x1682=((0.36)*cj6);
IkReal x1683=((1.0)*pz);
IkReal x1684=((0.36)*sj1);
IkReal x1685=(r11*sj6);
IkReal x1686=((0.36)*cj1);
IkReal x1687=(r01*sj6);
IkReal x1688=((0.36)*x1681);
IkReal x1689=((0.36)*x1680);
evalcond[0]=((-0.72)*pz*r22*x1680);
evalcond[1]=((((-1.0)*x1689))+(((-1.0)*r22*x1683)));
evalcond[2]=((((-1.0)*x1683))+(((-1.0)*r22*x1689)));
evalcond[3]=((((-1.0)*x1687*x1688))+x1684+((r00*x1681*x1682)));
evalcond[4]=((((-1.0)*x1686))+(((-1.0)*x1685*x1688))+((r10*x1681*x1682)));
evalcond[5]=((((-1.0)*cj1*r10*x1682))+x1688+((r00*sj1*x1682))+((x1685*x1686))+(((-1.0)*x1684*x1687)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1690=(pz*r22);
IkReal x1691=(r02*sj1);
IkReal x1692=((9.0)*cj1);
CheckValue<IkReal> x1693=IKPowWithIntegerCheck(((((9.0)*cj6*r10))+(((-9.0)*r11*sj6))),-1);
if(!x1693.valid){
continue;
}
if( IKabs(((x1693.value)*((x1692+(((-25.0)*r12*x1690))+(((9.0)*r12*x1691))+(((-1.0)*x1692*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-2.77777777777778)*x1690))+x1691+(((-1.0)*cj1*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1693.value)*((x1692+(((-25.0)*r12*x1690))+(((9.0)*r12*x1691))+(((-1.0)*x1692*(r12*r12)))))))+IKsqr(((((-2.77777777777778)*x1690))+x1691+(((-1.0)*cj1*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1693.value)*((x1692+(((-25.0)*r12*x1690))+(((9.0)*r12*x1691))+(((-1.0)*x1692*(r12*r12)))))), ((((-2.77777777777778)*x1690))+x1691+(((-1.0)*cj1*r12))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1694=IKcos(j5);
IkReal x1695=IKsin(j5);
IkReal x1696=((0.36)*cj6);
IkReal x1697=((0.36)*cj1);
IkReal x1698=((1.0)*pz);
IkReal x1699=(cj6*r20);
IkReal x1700=((0.36)*sj1);
IkReal x1701=((0.36)*x1694);
IkReal x1702=(pz*r21*sj6);
IkReal x1703=((0.72)*x1695);
IkReal x1704=((0.36)*sj6*x1695);
evalcond[0]=(((r02*x1700))+(((-1.0)*r12*x1697))+(((-1.0)*x1701))+(((-1.0)*r22*x1698)));
evalcond[1]=((((-1.0)*x1698))+(((-1.0)*r21*x1704))+(((-1.0)*r22*x1701))+((r20*x1695*x1696)));
evalcond[2]=((((-1.0)*x1702*x1703))+(((-0.72)*pz*r22*x1694))+((pz*x1699*x1703)));
evalcond[3]=(x1700+(((-1.0)*r02*x1701))+(((-1.0)*r01*x1704))+((r00*x1695*x1696)));
evalcond[4]=((((-1.0)*x1697))+((r10*x1695*x1696))+(((-1.0)*r11*x1704))+(((-1.0)*r12*x1701)));
evalcond[5]=((((0.36)*x1695))+(((-1.0)*x1698*x1699))+(((-1.0)*r01*sj6*x1700))+x1702+((r00*sj1*x1696))+(((-1.0)*cj1*r10*x1696))+((r11*sj6*x1697)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1705=((9.0)*sj1);
IkReal x1706=(pz*r22);
IkReal x1707=(cj1*r12);
CheckValue<IkReal> x1708=IKPowWithIntegerCheck(((((9.0)*cj6*r00))+(((-9.0)*r01*sj6))),-1);
if(!x1708.valid){
continue;
}
if( IKabs(((x1708.value)*(((((-1.0)*x1705))+((x1705*(r02*r02)))+(((-25.0)*r02*x1706))+(((-9.0)*r02*x1707)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1707))+(((-2.77777777777778)*x1706))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1708.value)*(((((-1.0)*x1705))+((x1705*(r02*r02)))+(((-25.0)*r02*x1706))+(((-9.0)*r02*x1707))))))+IKsqr(((((-1.0)*x1707))+(((-2.77777777777778)*x1706))+((r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1708.value)*(((((-1.0)*x1705))+((x1705*(r02*r02)))+(((-25.0)*r02*x1706))+(((-9.0)*r02*x1707))))), ((((-1.0)*x1707))+(((-2.77777777777778)*x1706))+((r02*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1709=IKcos(j5);
IkReal x1710=IKsin(j5);
IkReal x1711=((0.36)*cj6);
IkReal x1712=((0.36)*cj1);
IkReal x1713=((1.0)*pz);
IkReal x1714=(cj6*r20);
IkReal x1715=((0.36)*sj1);
IkReal x1716=((0.36)*x1709);
IkReal x1717=(pz*r21*sj6);
IkReal x1718=((0.72)*x1710);
IkReal x1719=((0.36)*sj6*x1710);
evalcond[0]=(((r02*x1715))+(((-1.0)*x1716))+(((-1.0)*r22*x1713))+(((-1.0)*r12*x1712)));
evalcond[1]=(((r20*x1710*x1711))+(((-1.0)*x1713))+(((-1.0)*r21*x1719))+(((-1.0)*r22*x1716)));
evalcond[2]=((((-0.72)*pz*r22*x1709))+((pz*x1714*x1718))+(((-1.0)*x1717*x1718)));
evalcond[3]=(x1715+((r00*x1710*x1711))+(((-1.0)*r02*x1716))+(((-1.0)*r01*x1719)));
evalcond[4]=((((-1.0)*x1712))+((r10*x1710*x1711))+(((-1.0)*r11*x1719))+(((-1.0)*r12*x1716)));
evalcond[5]=(x1717+(((-1.0)*x1713*x1714))+(((0.36)*x1710))+(((-1.0)*r01*sj6*x1715))+((r11*sj6*x1712))+((r00*sj1*x1711))+(((-1.0)*cj1*r10*x1711)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1720=((0.36)*r22);
IkReal x1721=(r02*sj1);
IkReal x1722=(cj1*r12);
CheckValue<IkReal> x1723=IKPowWithIntegerCheck(((((0.36)*cj6*r20))+(((-0.36)*r21*sj6))),-1);
if(!x1723.valid){
continue;
}
if( IKabs(((x1723.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1720*x1722))+((x1720*x1721))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1721+(((-1.0)*x1722))+(((-2.77777777777778)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1723.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1720*x1722))+((x1720*x1721))+pz))))+IKsqr((x1721+(((-1.0)*x1722))+(((-2.77777777777778)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1723.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1720*x1722))+((x1720*x1721))+pz))), (x1721+(((-1.0)*x1722))+(((-2.77777777777778)*pz*r22))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1724=IKcos(j5);
IkReal x1725=IKsin(j5);
IkReal x1726=((0.36)*cj6);
IkReal x1727=((0.36)*cj1);
IkReal x1728=((1.0)*pz);
IkReal x1729=(cj6*r20);
IkReal x1730=((0.36)*sj1);
IkReal x1731=((0.36)*x1724);
IkReal x1732=(pz*r21*sj6);
IkReal x1733=((0.72)*x1725);
IkReal x1734=((0.36)*sj6*x1725);
evalcond[0]=((((-1.0)*r22*x1728))+(((-1.0)*r12*x1727))+((r02*x1730))+(((-1.0)*x1731)));
evalcond[1]=(((r20*x1725*x1726))+(((-1.0)*x1728))+(((-1.0)*r21*x1734))+(((-1.0)*r22*x1731)));
evalcond[2]=((((-0.72)*pz*r22*x1724))+(((-1.0)*x1732*x1733))+((pz*x1729*x1733)));
evalcond[3]=(x1730+(((-1.0)*r01*x1734))+((r00*x1725*x1726))+(((-1.0)*r02*x1731)));
evalcond[4]=(((r10*x1725*x1726))+(((-1.0)*r11*x1734))+(((-1.0)*r12*x1731))+(((-1.0)*x1727)));
evalcond[5]=(((r11*sj6*x1727))+((r00*sj1*x1726))+x1732+(((-1.0)*x1728*x1729))+(((-1.0)*cj1*r10*x1726))+(((-1.0)*r01*sj6*x1730))+(((0.36)*x1725)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1735=((((0.36)*cj6*r20))+(((-0.36)*r21*sj6)));
CheckValue<IkReal> x1738 = IKatan2WithCheck(IkReal(((-0.36)*r22)),IkReal(x1735),IKFAST_ATAN2_MAGTHRESH);
if(!x1738.valid){
continue;
}
IkReal x1736=((1.0)*(x1738.value));
if((((x1735*x1735)+(((0.1296)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x1739=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1735*x1735)+(((0.1296)*(r22*r22)))))),-1);
if(!x1739.valid){
continue;
}
if( ((pz*(x1739.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1739.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1737=IKasin((pz*(x1739.value)));
j5array[0]=(x1737+(((-1.0)*x1736)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1737))+(((-1.0)*x1736)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1740=IKsin(j5);
IkReal x1741=((0.72)*pz);
evalcond[0]=(((cj6*r20*x1740*x1741))+(((-1.0)*r22*x1741*(IKcos(j5))))+(((-1.0)*r21*sj6*x1740*x1741)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1742=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1742))+((cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1742)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1742))+((cj5*r02))))+IKsqr(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1742))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1742))+((cj5*r02))), ((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1742))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1743=IKsin(j1);
IkReal x1744=IKcos(j1);
IkReal x1745=((0.36)*sj5);
IkReal x1746=((0.36)*cj5);
IkReal x1747=(pz*sj6);
IkReal x1748=(cj6*r10);
IkReal x1749=(r01*sj6);
IkReal x1750=((1.0)*r20);
IkReal x1751=(cj6*pz);
IkReal x1752=(cj6*r00);
IkReal x1753=(r11*sj6);
IkReal x1754=((0.36)*x1744);
IkReal x1755=((0.36)*x1743);
evalcond[0]=((((-1.0)*r12*x1754))+(((-1.0)*pz*r22))+((r02*x1755))+(((-1.0)*x1746)));
evalcond[1]=(x1755+((x1745*x1752))+(((-1.0)*x1745*x1749))+(((-1.0)*r02*x1746)));
evalcond[2]=((((-1.0)*r12*x1746))+((x1745*x1748))+(((-1.0)*x1754))+(((-1.0)*x1745*x1753)));
evalcond[3]=((((-1.0)*r10*sj6*x1754))+((cj6*r01*x1755))+(((-1.0)*x1747*x1750))+((r00*sj6*x1755))+(((-1.0)*r21*x1751))+(((-1.0)*cj6*r11*x1754)));
evalcond[4]=(((x1752*x1755))+(((-1.0)*x1748*x1754))+((x1753*x1754))+x1745+(((-1.0)*x1749*x1755))+((r21*x1747))+(((-1.0)*x1750*x1751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1756=((0.72)*pz);
CheckValue<IkReal> x1758 = IKatan2WithCheck(IkReal(((-0.72)*pz*r22)),IkReal((((cj6*r20*x1756))+(((-1.0)*r21*sj6*x1756)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1758.valid){
continue;
}
IkReal x1757=x1758.value;
j5array[0]=((-1.0)*x1757);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1757)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1759=IKsin(j5);
IkReal x1760=((0.36)*x1759);
evalcond[0]=(((cj6*r20*x1760))+(((-1.0)*r21*sj6*x1760))+(((-1.0)*pz))+(((-0.36)*r22*(IKcos(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1761=((1.0)*sj5);
if( IKabs((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1761))+((cj5*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1761)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1761))+((cj5*r02))))+IKsqr(((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1761))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((((r01*sj5*sj6))+(((-1.0)*cj6*r00*x1761))+((cj5*r02))), ((((-1.0)*cj5*r12))+((cj6*r10*sj5))+(((-1.0)*r11*sj6*x1761))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1762=IKsin(j1);
IkReal x1763=IKcos(j1);
IkReal x1764=((0.36)*sj5);
IkReal x1765=((0.36)*cj5);
IkReal x1766=(pz*sj6);
IkReal x1767=(cj6*r10);
IkReal x1768=(r01*sj6);
IkReal x1769=((1.0)*r20);
IkReal x1770=(cj6*pz);
IkReal x1771=(cj6*r00);
IkReal x1772=(r11*sj6);
IkReal x1773=((0.36)*x1763);
IkReal x1774=((0.36)*x1762);
evalcond[0]=((((-1.0)*x1765))+(((-1.0)*pz*r22))+((r02*x1774))+(((-1.0)*r12*x1773)));
evalcond[1]=(x1774+((x1764*x1771))+(((-1.0)*r02*x1765))+(((-1.0)*x1764*x1768)));
evalcond[2]=(((x1764*x1767))+(((-1.0)*r12*x1765))+(((-1.0)*x1773))+(((-1.0)*x1764*x1772)));
evalcond[3]=((((-1.0)*r10*sj6*x1773))+((cj6*r01*x1774))+(((-1.0)*cj6*r11*x1773))+(((-1.0)*x1766*x1769))+(((-1.0)*r21*x1770))+((r00*sj6*x1774)));
evalcond[4]=(((r21*x1766))+x1764+((x1771*x1774))+(((-1.0)*x1767*x1773))+((x1772*x1773))+(((-1.0)*x1768*x1774))+(((-1.0)*x1769*x1770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1777 = IKatan2WithCheck(IkReal(((0.72)*py)),IkReal(((-0.72)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1777.valid){
continue;
}
IkReal x1775=((1.0)*(x1777.value));
if((((((0.5184)*(px*px)))+(((0.5184)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1778=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.5184)*(px*px)))+(((0.5184)*(py*py)))))),-1);
if(!x1778.valid){
continue;
}
if( ((pp*(x1778.value))) < -1-IKFAST_SINCOS_THRESH || ((pp*(x1778.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1776=IKasin((pp*(x1778.value)));
j1array[0]=((((-1.0)*x1776))+(((-1.0)*x1775)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x1776+(((-1.0)*x1775)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=((((-2.77777777777778)*npz))+((r02*sj1))+(((-1.0)*cj1*r12)));
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x1779=(r02*sj5);
IkReal x1780=((9.0)*cj5);
IkReal x1781=((9.0)*cj1);
j6eval[0]=x1779;
j6eval[1]=IKsign(x1779);
j6eval[2]=((IKabs(((((-1.0)*r00*x1780))+((r21*x1781))+(((-25.0)*rxp1_0)))))+(IKabs((((r20*x1781))+(((-25.0)*rxp0_0))+((r01*x1780))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1782=(r12*sj5);
IkReal x1783=((9.0)*sj1);
IkReal x1784=((9.0)*cj5);
j6eval[0]=x1782;
j6eval[1]=IKsign(x1782);
j6eval[2]=((IKabs(((((-1.0)*r11*x1784))+(((25.0)*rxp0_1))+(((-1.0)*r20*x1783)))))+(IKabs((((r10*x1784))+(((25.0)*rxp1_1))+(((-1.0)*r21*x1783))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1785=((50.0)*pz);
IkReal x1786=((18.0)*cj5);
IkReal x1787=((25.0)*pp);
IkReal x1788=(npy*r20*sj5);
IkReal x1789=(npx*r21*sj5);
j6eval[0]=(x1788+(((-1.0)*x1789)));
j6eval[1]=IKsign(((((-18.0)*x1789))+(((18.0)*x1788))));
j6eval[2]=((IKabs((((npy*r22*x1786))+((npy*x1785))+(((-1.0)*r21*x1787))+(((-1.0)*npz*r21*x1786)))))+(IKabs((((npx*x1785))+(((-1.0)*r20*x1787))+(((-1.0)*npz*r20*x1786))+((npx*r22*x1786))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1790=((0.36)*cj1);
IkReal x1791=((0.36)*sj1);
j6eval[0]=((IKabs(((((-1.0)*r01*x1791))+npy+((r11*x1790)))))+(IKabs((((r00*x1791))+(((-1.0)*r10*x1790))+(((-1.0)*npx))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1792=((0.36)*cj1);
IkReal x1793=((0.36)*sj1);
j6eval[0]=((IKabs((((r00*x1793))+(((-1.0)*r10*x1792))+(((-1.0)*npx)))))+(IKabs(((((-1.0)*r11*x1792))+(((-1.0)*npy))+((r01*x1793))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1794=((0.36)*cj1);
IkReal x1795=((0.36)*sj1);
CheckValue<IkReal> x1797 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1794))+(((-1.0)*npy))+((r01*x1795)))),IkReal((((r00*x1795))+(((-1.0)*r10*x1794))+(((-1.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1797.valid){
continue;
}
IkReal x1796=x1797.value;
j6array[0]=((-1.0)*x1796);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1796)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1798=IKsin(j6);
IkReal x1799=IKcos(j6);
IkReal x1800=((0.36)*sj1);
IkReal x1801=((0.36)*cj1);
evalcond[0]=((((-1.0)*r10*x1799*x1801))+((r11*x1798*x1801))+((npy*x1798))+((r00*x1799*x1800))+(((-1.0)*r01*x1798*x1800))+(((-1.0)*npx*x1799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1802=((0.36)*cj1);
IkReal x1803=((0.36)*sj1);
CheckValue<IkReal> x1805 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1802))+(((-1.0)*npx))+((r00*x1803)))),IkReal(((((-1.0)*r01*x1803))+npy+((r11*x1802)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1805.valid){
continue;
}
IkReal x1804=x1805.value;
j6array[0]=((-1.0)*x1804);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1804)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1806=IKsin(j6);
IkReal x1807=IKcos(j6);
IkReal x1808=((0.36)*x1807);
IkReal x1809=((0.36)*x1806);
evalcond[0]=((((-1.0)*cj1*r10*x1809))+(((-1.0)*npy*x1807))+((r00*sj1*x1809))+(((-1.0)*cj1*r11*x1808))+(((-1.0)*npx*x1806))+((r01*sj1*x1808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1810=((0.36)*cj1);
IkReal x1811=((0.36)*sj1);
j6eval[0]=((IKabs((npy+(((-1.0)*r01*x1811))+((r11*x1810)))))+(IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1810))+((r00*x1811))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1812=((0.36)*cj1);
IkReal x1813=((0.36)*sj1);
j6eval[0]=((IKabs(((((-1.0)*npy))+(((-1.0)*r11*x1812))+((r01*x1813)))))+(IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1812))+((r00*x1813))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1814=((0.36)*cj1);
IkReal x1815=((0.36)*sj1);
CheckValue<IkReal> x1817 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+(((-1.0)*r11*x1814))+((r01*x1815)))),IkReal(((((-1.0)*npx))+(((-1.0)*r10*x1814))+((r00*x1815)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1817.valid){
continue;
}
IkReal x1816=x1817.value;
j6array[0]=((-1.0)*x1816);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1816)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1818=IKsin(j6);
IkReal x1819=IKcos(j6);
IkReal x1820=((0.36)*sj1);
IkReal x1821=((0.36)*cj1);
evalcond[0]=((((-1.0)*r10*x1819*x1821))+(((-1.0)*r01*x1818*x1820))+(((-1.0)*npx*x1819))+((npy*x1818))+((r11*x1818*x1821))+((r00*x1819*x1820)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1822=((0.36)*cj1);
IkReal x1823=((0.36)*sj1);
CheckValue<IkReal> x1825 = IKatan2WithCheck(IkReal((((r00*x1823))+(((-1.0)*npx))+(((-1.0)*r10*x1822)))),IkReal((npy+(((-1.0)*r01*x1823))+((r11*x1822)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1825.valid){
continue;
}
IkReal x1824=x1825.value;
j6array[0]=((-1.0)*x1824);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1824)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1826=IKsin(j6);
IkReal x1827=IKcos(j6);
IkReal x1828=((0.36)*x1827);
IkReal x1829=((0.36)*x1826);
evalcond[0]=((((-1.0)*npy*x1827))+((r01*sj1*x1828))+(((-1.0)*npx*x1826))+(((-1.0)*cj1*r11*x1828))+(((-1.0)*cj1*r10*x1829))+((r00*sj1*x1829)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r02);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1830=(r12*sj5);
IkReal x1831=((9.0)*sj1);
IkReal x1832=((9.0)*cj5*r22);
j6eval[0]=x1830;
j6eval[1]=((IKabs(((((25.0)*rxp1_1))+(((-1.0)*r21*x1831))+(((-1.0)*r01*x1832)))))+(IKabs(((((-1.0)*r20*x1831))+(((-1.0)*r00*x1832))+(((25.0)*rxp0_1))))));
j6eval[2]=IKsign(x1830);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1833=(r22*sj5);
IkReal x1834=((9.0)*r00);
IkReal x1835=((9.0)*sj1);
IkReal x1836=(cj5*r12);
IkReal x1837=((9.0)*r01);
j6eval[0]=x1833;
j6eval[1]=IKsign(x1833);
j6eval[2]=((IKabs(((((-1.0)*x1834*x1836))+(((-1.0)*r10*x1835))+(((-25.0)*rxp0_2))+(((-1.0)*cj1*x1834)))))+(IKabs(((((-1.0)*x1836*x1837))+(((-25.0)*rxp1_2))+(((-1.0)*r11*x1835))+(((-1.0)*cj1*x1837))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1838=((0.36)*cj1);
j6eval[0]=((IKabs((((px*r00))+(((-1.0)*r10*x1838))+(((-1.0)*npx)))))+(IKabs(((((-1.0)*px*r01))+npy+((r11*x1838))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=1.0;
j5=0;
IkReal x1839=((0.36)*cj1);
j6eval[0]=((IKabs((((px*r00))+(((-1.0)*r10*x1839))+(((-1.0)*npx)))))+(IKabs((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1839))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1840=((0.36)*cj1);
CheckValue<IkReal> x1842 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1840)))),IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1840)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1842.valid){
continue;
}
IkReal x1841=x1842.value;
j6array[0]=((-1.0)*x1841);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1841)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1843=IKsin(j6);
IkReal x1844=IKcos(j6);
IkReal x1845=((0.36)*cj1);
evalcond[0]=(((px*r00*x1844))+((npy*x1843))+(((-1.0)*px*r01*x1843))+(((-1.0)*npx*x1844))+((r11*x1843*x1845))+(((-1.0)*r10*x1844*x1845)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1846=((0.36)*cj1);
CheckValue<IkReal> x1848 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1846)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1846)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1848.valid){
continue;
}
IkReal x1847=x1848.value;
j6array[0]=((-1.0)*x1847);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1847)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1849=IKsin(j6);
IkReal x1850=IKcos(j6);
IkReal x1851=((0.36)*cj1);
evalcond[0]=(((px*r00*x1849))+((px*r01*x1850))+(((-1.0)*r10*x1849*x1851))+(((-1.0)*npy*x1850))+(((-1.0)*npx*x1849))+(((-1.0)*r11*x1850*x1851)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1852=((0.36)*cj1);
j6eval[0]=((IKabs(((((-1.0)*px*r01))+npy+((r11*x1852)))))+(IKabs((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1852))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1853=((0.36)*cj1);
j6eval[0]=((IKabs((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1853)))))+(IKabs((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1853))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1854=((0.36)*cj1);
CheckValue<IkReal> x1856 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+(((-1.0)*r11*x1854)))),IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1854)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1856.valid){
continue;
}
IkReal x1855=x1856.value;
j6array[0]=((-1.0)*x1855);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1855)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1857=IKsin(j6);
IkReal x1858=IKcos(j6);
IkReal x1859=((0.36)*cj1);
evalcond[0]=(((px*r00*x1858))+((npy*x1857))+(((-1.0)*npx*x1858))+((r11*x1857*x1859))+(((-1.0)*px*r01*x1857))+(((-1.0)*r10*x1858*x1859)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1860=((0.36)*cj1);
CheckValue<IkReal> x1862 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1860)))),IkReal((((r11*x1860))+(((-1.0)*px*r01))+npy)),IKFAST_ATAN2_MAGTHRESH);
if(!x1862.valid){
continue;
}
IkReal x1861=x1862.value;
j6array[0]=((-1.0)*x1861);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1861)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1863=IKsin(j6);
IkReal x1864=IKcos(j6);
IkReal x1865=((0.36)*cj1);
evalcond[0]=(((px*r01*x1864))+(((-1.0)*npx*x1863))+((px*r00*x1863))+(((-1.0)*npy*x1864))+(((-1.0)*r10*x1863*x1865))+(((-1.0)*r11*x1864*x1865)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r12);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
IkReal x1866=(r22*sj5);
IkReal x1867=((9.0)*cj1);
IkReal x1868=((9.0)*sj1);
j6eval[0]=x1866;
j6eval[1]=((IKabs(((((-25.0)*rxp1_2))+(((-1.0)*r11*x1868))+(((-1.0)*r01*x1867)))))+(IKabs(((((-25.0)*rxp0_2))+(((-1.0)*r00*x1867))+(((-1.0)*r10*x1868))))));
j6eval[2]=IKsign(x1866);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj5=0;
cj5=1.0;
j5=0;
j6eval[0]=((((7.71604938271605)*(npy*npy)))+(((5.55555555555556)*cj1*py))+(cj1*cj1)+(((7.71604938271605)*(npx*npx)))+(((-7.71604938271605)*(px*px))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1869=((0.36)*cj1);
CheckValue<IkReal> x1871 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*npx))+(((-1.0)*r10*x1869)))),IkReal((((r11*x1869))+(((-1.0)*px*r01))+npy)),IKFAST_ATAN2_MAGTHRESH);
if(!x1871.valid){
continue;
}
IkReal x1870=x1871.value;
j6array[0]=((-1.0)*x1870);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1870)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1872=IKsin(j6);
IkReal x1873=IKcos(j6);
IkReal x1874=((0.36)*cj1);
evalcond[0]=(((px*r01*x1873))+(((-1.0)*r11*x1873*x1874))+((px*r00*x1872))+(((-1.0)*r10*x1872*x1874))+(((-1.0)*npx*x1872))+(((-1.0)*npy*x1873)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j6eval[0]=((((7.71604938271605)*(npy*npy)))+(((5.55555555555556)*cj1*py))+(cj1*cj1)+(((7.71604938271605)*(npx*npx)))+(((-7.71604938271605)*(px*px))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1875=((0.36)*cj1);
CheckValue<IkReal> x1877 = IKatan2WithCheck(IkReal((((px*r00))+(((-1.0)*r10*x1875))+(((-1.0)*npx)))),IkReal(((((-1.0)*px*r01))+npy+((r11*x1875)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1877.valid){
continue;
}
IkReal x1876=x1877.value;
j6array[0]=((-1.0)*x1876);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1876)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
IkReal x1878=IKsin(j6);
IkReal x1879=IKcos(j6);
IkReal x1880=((0.36)*cj1);
evalcond[0]=(((px*r01*x1879))+(((-1.0)*r10*x1878*x1880))+(((-1.0)*r11*x1879*x1880))+((px*r00*x1878))+(((-1.0)*npx*x1878))+(((-1.0)*npy*x1879)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1881=((9.0)*cj1);
IkReal x1882=((9.0)*sj1);
CheckValue<IkReal> x1883=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1883.valid){
continue;
}
CheckValue<IkReal> x1884 = IKatan2WithCheck(IkReal(((((-25.0)*rxp0_2))+(((-1.0)*r10*x1882))+(((-1.0)*r00*x1881)))),IkReal(((((-25.0)*rxp1_2))+(((-1.0)*r11*x1882))+(((-1.0)*r01*x1881)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1884.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1883.value)))+(x1884.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1885=IKcos(j6);
IkReal x1886=IKsin(j6);
IkReal x1887=((0.36)*sj5);
IkReal x1888=(cj1*r11);
IkReal x1889=((1.0)*npx);
IkReal x1890=((0.72)*sj5);
IkReal x1891=(cj1*r10);
IkReal x1892=((0.36)*sj1);
IkReal x1893=(npy*x1886);
IkReal x1894=(r00*x1885);
IkReal x1895=((0.36)*x1885);
IkReal x1896=((0.36)*x1886);
IkReal x1897=(x1886*x1892);
evalcond[0]=((((-1.0)*r01*x1886*x1887))+(((-1.0)*px))+x1892+((x1887*x1894)));
evalcond[1]=((((-1.0)*py))+(((-1.0)*r11*x1886*x1887))+((r10*x1885*x1887))+(((-0.36)*cj1)));
evalcond[2]=((((-1.0)*pz))+((pz*(r22*r22)))+(((-1.0)*r21*x1886*x1887))+((r20*x1885*x1887)));
evalcond[3]=(((npx*x1885*x1890))+(((-1.0)*x1890*x1893))+(((-1.0)*pp))+(((-0.72)*cj5*pz*r22)));
evalcond[4]=((((-1.0)*npy*x1885))+((r01*x1885*x1892))+((r00*x1897))+(((-1.0)*x1891*x1896))+(((-1.0)*x1888*x1895))+(((-1.0)*x1886*x1889)));
evalcond[5]=(((x1892*x1894))+(((-1.0)*x1891*x1895))+((x1888*x1896))+(((-1.0)*r01*x1897))+x1893+x1887+(((-1.0)*x1885*x1889)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1898=((9.0)*r00);
IkReal x1899=((9.0)*sj1);
IkReal x1900=(cj5*r12);
IkReal x1901=((9.0)*r01);
CheckValue<IkReal> x1902 = IKatan2WithCheck(IkReal(((((-25.0)*rxp0_2))+(((-1.0)*cj1*x1898))+(((-1.0)*x1898*x1900))+(((-1.0)*r10*x1899)))),IkReal(((((-25.0)*rxp1_2))+(((-1.0)*x1900*x1901))+(((-1.0)*cj1*x1901))+(((-1.0)*r11*x1899)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1902.valid){
continue;
}
CheckValue<IkReal> x1903=IKPowWithIntegerCheck(IKsign((r22*sj5)),-1);
if(!x1903.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1902.value)+(((1.5707963267949)*(x1903.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1904=IKcos(j6);
IkReal x1905=IKsin(j6);
IkReal x1906=((0.36)*sj5);
IkReal x1907=((1.0)*npx);
IkReal x1908=(cj5*r12);
IkReal x1909=((0.72)*sj5);
IkReal x1910=((0.36)*cj1);
IkReal x1911=((0.36)*sj1);
IkReal x1912=(cj5*r22);
IkReal x1913=(npy*x1905);
IkReal x1914=(r00*x1904);
IkReal x1915=(r10*x1904);
IkReal x1916=(r11*x1905);
IkReal x1917=((0.36)*x1904);
IkReal x1918=(x1905*x1911);
evalcond[0]=((((-1.0)*px))+x1911+((x1906*x1914))+(((-1.0)*r01*x1905*x1906)));
evalcond[1]=((((-1.0)*r21*x1905*x1906))+((r20*x1904*x1906))+(((-0.36)*x1912))+(((-1.0)*pz)));
evalcond[2]=((((-0.36)*x1908))+(((-1.0)*py))+((x1906*x1915))+(((-1.0)*x1906*x1916))+(((-1.0)*x1910)));
evalcond[3]=((((-0.72)*pz*x1912))+(((-0.72)*py*x1908))+(((-1.0)*pp))+((npx*x1904*x1909))+(((-1.0)*x1909*x1913)));
evalcond[4]=((((-1.0)*r10*x1905*x1910))+(((-1.0)*r11*x1904*x1910))+((r01*x1904*x1911))+((r00*x1918))+(((-1.0)*npy*x1904))+(((-1.0)*x1905*x1907)));
evalcond[5]=((((-1.0)*x1910*x1915))+(((-1.0)*r01*x1918))+((x1910*x1916))+((x1911*x1914))+(((-1.0)*x1904*x1907))+x1906+x1913);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1919=((9.0)*sj1);
IkReal x1920=((9.0)*cj5*r22);
CheckValue<IkReal> x1921 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x1920))+(((25.0)*rxp0_1))+(((-1.0)*r20*x1919)))),IkReal(((((25.0)*rxp1_1))+(((-1.0)*r01*x1920))+(((-1.0)*r21*x1919)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1921.valid){
continue;
}
CheckValue<IkReal> x1922=IKPowWithIntegerCheck(IKsign((r12*sj5)),-1);
if(!x1922.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1921.value)+(((-1.5707963267949)*(x1922.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1923=IKcos(j6);
IkReal x1924=IKsin(j6);
IkReal x1925=((0.36)*sj5);
IkReal x1926=((1.0)*npx);
IkReal x1927=(cj5*r12);
IkReal x1928=((0.72)*sj5);
IkReal x1929=((0.36)*cj1);
IkReal x1930=((0.36)*sj1);
IkReal x1931=(cj5*r22);
IkReal x1932=(npy*x1924);
IkReal x1933=(r00*x1923);
IkReal x1934=(r10*x1923);
IkReal x1935=(r11*x1924);
IkReal x1936=((0.36)*x1923);
IkReal x1937=(x1924*x1930);
evalcond[0]=((((-1.0)*r01*x1924*x1925))+((x1925*x1933))+(((-1.0)*px))+x1930);
evalcond[1]=((((-0.36)*x1931))+(((-1.0)*pz))+((r20*x1923*x1925))+(((-1.0)*r21*x1924*x1925)));
evalcond[2]=(((x1925*x1934))+(((-1.0)*x1925*x1935))+(((-1.0)*x1929))+(((-1.0)*py))+(((-0.36)*x1927)));
evalcond[3]=((((-1.0)*x1928*x1932))+(((-0.72)*pz*x1931))+((npx*x1923*x1928))+(((-1.0)*pp))+(((-0.72)*py*x1927)));
evalcond[4]=(((r00*x1937))+(((-1.0)*r11*x1923*x1929))+((r01*x1923*x1930))+(((-1.0)*r10*x1924*x1929))+(((-1.0)*x1924*x1926))+(((-1.0)*npy*x1923)));
evalcond[5]=((((-1.0)*r01*x1937))+((x1930*x1933))+x1925+x1932+(((-1.0)*x1929*x1934))+((x1929*x1935))+(((-1.0)*x1923*x1926)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1938=((50.0)*pz);
IkReal x1939=((18.0)*cj5);
IkReal x1940=((25.0)*pp);
IkReal x1941=((18.0)*sj5);
CheckValue<IkReal> x1942 = IKatan2WithCheck(IkReal((((npx*x1938))+(((-1.0)*r20*x1940))+((npx*r22*x1939))+(((-1.0)*npz*r20*x1939)))),IkReal(((((-1.0)*r21*x1940))+(((-1.0)*npz*r21*x1939))+((npy*r22*x1939))+((npy*x1938)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1942.valid){
continue;
}
CheckValue<IkReal> x1943=IKPowWithIntegerCheck(IKsign((((npy*r20*x1941))+(((-1.0)*npx*r21*x1941)))),-1);
if(!x1943.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1942.value)+(((1.5707963267949)*(x1943.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1944=IKcos(j6);
IkReal x1945=IKsin(j6);
IkReal x1946=((0.36)*sj5);
IkReal x1947=((0.36)*cj5);
IkReal x1948=((1.0)*npx);
IkReal x1949=((0.72)*sj5);
IkReal x1950=((0.36)*cj1);
IkReal x1951=((0.36)*sj1);
IkReal x1952=(npy*x1945);
IkReal x1953=(r00*x1944);
IkReal x1954=(r10*x1944);
IkReal x1955=(r11*x1945);
IkReal x1956=((0.36)*x1944);
IkReal x1957=(x1945*x1951);
evalcond[0]=((((-1.0)*r22*x1947))+(((-1.0)*pz))+((r20*x1944*x1946))+(((-1.0)*r21*x1945*x1946)));
evalcond[1]=((((-1.0)*x1949*x1952))+(((-0.72)*cj5*npz))+(((-1.0)*pp))+((npx*x1944*x1949)));
evalcond[2]=((((-1.0)*r01*x1945*x1946))+(((-1.0)*r02*x1947))+((x1946*x1953))+(((-1.0)*px))+x1951);
evalcond[3]=((((-1.0)*x1950))+((x1946*x1954))+(((-1.0)*py))+(((-1.0)*x1946*x1955))+(((-1.0)*r12*x1947)));
evalcond[4]=((((-1.0)*x1945*x1948))+(((-1.0)*npy*x1944))+(((-1.0)*r10*x1945*x1950))+((r00*x1957))+(((-1.0)*r11*x1944*x1950))+((r01*x1944*x1951)));
evalcond[5]=((((-1.0)*x1950*x1954))+((x1950*x1955))+((x1951*x1953))+(((-1.0)*x1944*x1948))+x1946+x1952+(((-1.0)*r01*x1957)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1958=((9.0)*sj1);
IkReal x1959=((9.0)*cj5);
CheckValue<IkReal> x1960 = IKatan2WithCheck(IkReal(((((25.0)*rxp0_1))+(((-1.0)*r11*x1959))+(((-1.0)*r20*x1958)))),IkReal(((((25.0)*rxp1_1))+((r10*x1959))+(((-1.0)*r21*x1958)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1960.valid){
continue;
}
CheckValue<IkReal> x1961=IKPowWithIntegerCheck(IKsign((r12*sj5)),-1);
if(!x1961.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1960.value)+(((-1.5707963267949)*(x1961.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1962=IKcos(j6);
IkReal x1963=IKsin(j6);
IkReal x1964=((0.36)*sj5);
IkReal x1965=((0.36)*cj5);
IkReal x1966=((1.0)*npx);
IkReal x1967=((0.72)*sj5);
IkReal x1968=((0.36)*cj1);
IkReal x1969=((0.36)*sj1);
IkReal x1970=(npy*x1963);
IkReal x1971=(r00*x1962);
IkReal x1972=(r10*x1962);
IkReal x1973=(r11*x1963);
IkReal x1974=((0.36)*x1962);
IkReal x1975=(x1963*x1969);
evalcond[0]=((((-1.0)*r22*x1965))+((r20*x1962*x1964))+(((-1.0)*pz))+(((-1.0)*r21*x1963*x1964)));
evalcond[1]=(((npx*x1962*x1967))+(((-0.72)*cj5*npz))+(((-1.0)*pp))+(((-1.0)*x1967*x1970)));
evalcond[2]=((((-1.0)*r02*x1965))+((x1964*x1971))+(((-1.0)*px))+x1969+(((-1.0)*r01*x1963*x1964)));
evalcond[3]=((((-1.0)*x1964*x1973))+((x1964*x1972))+(((-1.0)*x1968))+(((-1.0)*py))+(((-1.0)*r12*x1965)));
evalcond[4]=((((-1.0)*npy*x1962))+((r00*x1975))+(((-1.0)*r10*x1963*x1968))+((r01*x1962*x1969))+(((-1.0)*x1963*x1966))+(((-1.0)*r11*x1962*x1968)));
evalcond[5]=(((x1969*x1971))+(((-1.0)*x1968*x1972))+(((-1.0)*r01*x1975))+x1964+x1970+(((-1.0)*x1962*x1966))+((x1968*x1973)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1976=((9.0)*cj5);
IkReal x1977=((9.0)*cj1);
CheckValue<IkReal> x1978=IKPowWithIntegerCheck(IKsign((r02*sj5)),-1);
if(!x1978.valid){
continue;
}
CheckValue<IkReal> x1979 = IKatan2WithCheck(IkReal((((r20*x1977))+(((-25.0)*rxp0_0))+((r01*x1976)))),IkReal(((((-25.0)*rxp1_0))+(((-1.0)*r00*x1976))+((r21*x1977)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1979.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1978.value)))+(x1979.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x1980=IKcos(j6);
IkReal x1981=IKsin(j6);
IkReal x1982=((0.36)*sj5);
IkReal x1983=((0.36)*cj5);
IkReal x1984=((1.0)*npx);
IkReal x1985=((0.72)*sj5);
IkReal x1986=((0.36)*cj1);
IkReal x1987=((0.36)*sj1);
IkReal x1988=(npy*x1981);
IkReal x1989=(r00*x1980);
IkReal x1990=(r10*x1980);
IkReal x1991=(r11*x1981);
IkReal x1992=((0.36)*x1980);
IkReal x1993=(x1981*x1987);
evalcond[0]=(((r20*x1980*x1982))+(((-1.0)*pz))+(((-1.0)*r21*x1981*x1982))+(((-1.0)*r22*x1983)));
evalcond[1]=((((-0.72)*cj5*npz))+(((-1.0)*x1985*x1988))+(((-1.0)*pp))+((npx*x1980*x1985)));
evalcond[2]=((((-1.0)*r02*x1983))+(((-1.0)*px))+x1987+((x1982*x1989))+(((-1.0)*r01*x1981*x1982)));
evalcond[3]=((((-1.0)*x1986))+(((-1.0)*x1982*x1991))+(((-1.0)*py))+(((-1.0)*r12*x1983))+((x1982*x1990)));
evalcond[4]=((((-1.0)*x1981*x1984))+(((-1.0)*npy*x1980))+(((-1.0)*r10*x1981*x1986))+((r01*x1980*x1987))+((r00*x1993))+(((-1.0)*r11*x1980*x1986)));
evalcond[5]=(((x1987*x1989))+(((-1.0)*x1980*x1984))+(((-1.0)*x1986*x1990))+((x1986*x1991))+(((-1.0)*r01*x1993))+x1982+x1988);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x152=((1.0)*sj5);
IkReal x153=((1.0)*r02);
IkReal x154=((1.0)*cj1);
IkReal x155=((1.0)*sj6);
IkReal x156=((1.0)*cj5);
IkReal x157=(((r10*sj1))+((cj1*r00)));
IkReal x158=(((cj1*r01))+((r11*sj1)));
IkReal x159=(((cj6*r20))+(((-1.0)*r21*x155)));
IkReal x160=(((r01*sj1))+(((-1.0)*r11*x154)));
IkReal x161=(((r00*sj1))+(((-1.0)*r10*x154)));
IkReal x162=(((cj1*r12))+(((-1.0)*sj1*x153)));
IkReal x163=((((-1.0)*cj1*x153))+(((-1.0)*r12*sj1)));
IkReal x164=(((cj6*x157))+(((-1.0)*x155*x158)));
IkReal x165=(((cj6*x161))+(((-1.0)*x155*x160)));
new_r00=(((cj5*x164))+(((-1.0)*x152*x163)));
new_r01=(((cj6*x158))+((sj6*x157)));
new_r02=((((-1.0)*x152*x164))+(((-1.0)*x156*x163)));
new_r10=(((r22*sj5))+((cj5*x159)));
new_r11=(((cj6*r21))+((r20*sj6)));
new_r12=(((cj5*r22))+(((-1.0)*x152*x159)));
new_r20=(((cj5*x165))+(((-1.0)*x152*x162)));
new_r21=(((cj6*x160))+((sj6*x161)));
new_r22=((((-1.0)*x152*x165))+(((-1.0)*x156*x162)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=((-1.0)*new_r22);
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
j4eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=new_r12;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].fmul = j2mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].fmul = j4mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j4mul = 1;
j4=0;
j2mul=-1.0;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].fmul = j2mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].fmul = j4mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x166=new_r22*new_r22;
IkReal x167=((16.0)*new_r10);
IkReal x168=((16.0)*new_r01);
IkReal x169=((16.0)*new_r22);
IkReal x170=((8.0)*new_r11);
IkReal x171=((8.0)*new_r00);
IkReal x172=(x166*x167);
IkReal x173=(x166*x168);
j2eval[0]=((IKabs(((((-1.0)*x172))+x167)))+(IKabs(((((-1.0)*x167))+x172)))+(IKabs(((((-32.0)*new_r00*x166))+((new_r11*x169))+(((16.0)*new_r00)))))+(IKabs(((((-1.0)*new_r00*x169))+(((32.0)*new_r11))+(((-16.0)*new_r11*x166)))))+(IKabs((((x166*x170))+(((-1.0)*new_r22*x171)))))+(IKabs(((((-1.0)*x173))+x168)))+(IKabs(((((-1.0)*x171))+((new_r22*x170)))))+(IKabs(((((-1.0)*x168))+x173))));
if( IKabs(j2eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j2, j4]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j2evalpoly[1];
IkReal x174=new_r22*new_r22;
IkReal x175=((16.0)*new_r10);
IkReal x176=(new_r11*new_r22);
IkReal x177=(x174*x175);
IkReal x178=((((8.0)*x176))+(((-8.0)*new_r00)));
op[0]=x178;
op[1]=((((-1.0)*x177))+x175);
op[2]=((((-32.0)*new_r00*x174))+(((16.0)*new_r00))+(((16.0)*x176)));
op[3]=((((-1.0)*x175))+x177);
op[4]=x178;
polyroots4(op,zeror,numroots);
IkReal j2array[4], cj2array[4], sj2array[4], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[4]={true,true,true,true};
_nj2 = 4;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

IkReal x179=((16.0)*new_r01);
IkReal x180=new_r22*new_r22;
IkReal x181=(new_r00*new_r22);
IkReal x182=((8.0)*x181);
IkReal x183=(new_r11*x180);
IkReal x184=(x179*x180);
IkReal x185=((8.0)*x183);
j2evalpoly[0]=((((htj2*htj2)*(((((32.0)*new_r11))+(((-16.0)*x181))+(((-16.0)*x183))))))+(((-1.0)*x182))+(((htj2*htj2*htj2*htj2)*(((((-1.0)*x182))+x185))))+x185+((htj2*(((((-1.0)*x184))+x179))))+(((htj2*htj2*htj2)*(((((-1.0)*x179))+x184)))));
if( IKabs(j2evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x186=cj2*cj2;
IkReal x187=new_r22*new_r22;
IkReal x188=(new_r22*sj2);
IkReal x189=((1.0)*new_r10);
IkReal x190=(x186+x187+(((-1.0)*x186*x187)));
j4eval[0]=x190;
j4eval[1]=((IKabs(((((-1.0)*x188*x189))+(((-1.0)*cj2*new_r11)))))+(IKabs((((new_r11*x188))+(((-1.0)*cj2*x189))))));
j4eval[2]=IKsign(x190);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=new_r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x191=IKcos(j4);
IkReal x192=IKsin(j4);
IkReal x193=((1.0)*new_r22);
evalcond[0]=(x192+(((-1.0)*new_r00)));
evalcond[1]=(x191+(((-1.0)*new_r01)));
evalcond[2]=(((new_r22*x191))+new_r10);
evalcond[3]=((((-1.0)*x192*x193))+new_r11);
evalcond[4]=(x192+(((-1.0)*new_r11*x193)));
evalcond[5]=((((-1.0)*x191))+(((-1.0)*new_r10*x193)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x194=IKsin(j4);
IkReal x195=IKcos(j4);
evalcond[0]=(x194+new_r00);
evalcond[1]=(x195+new_r01);
evalcond[2]=(x194+((new_r11*new_r22)));
evalcond[3]=(((new_r22*x195))+(((-1.0)*new_r10)));
evalcond[4]=((((-1.0)*x195))+((new_r10*new_r22)));
evalcond[5]=((((-1.0)*new_r22*x194))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x196=new_r22*new_r22;
CheckValue<IkReal> x197=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x196))),-1);
if(!x197.valid){
continue;
}
if((((-1.0)*x196*(x197.value))) < -0.00001)
continue;
IkReal gconst78=IKsqrt(((-1.0)*x196*(x197.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst78)))))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
IkReal x198=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
if( IKabs((((new_r00*x198))+(((-1.0)*gconst78*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*x198))+(((-1.0)*gconst78*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*x198))+(((-1.0)*gconst78*new_r10))))+IKsqr((((new_r01*x198))+(((-1.0)*gconst78*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*x198))+(((-1.0)*gconst78*new_r10))), (((new_r01*x198))+(((-1.0)*gconst78*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x199=IKcos(j4);
IkReal x200=IKsin(j4);
IkReal x201=(gconst78*new_r01);
IkReal x202=((1.0)*new_r22);
IkReal x203=(gconst78*new_r00);
IkReal x204=(gconst78*x200);
IkReal x205=(new_r22*x199);
IkReal x206=x198;
IkReal x207=((1.0)*x206);
evalcond[0]=((((-1.0)*new_r00*x207))+x200+((gconst78*new_r10)));
evalcond[1]=(x199+((gconst78*new_r11))+(((-1.0)*new_r01*x207)));
evalcond[2]=(((new_r10*x206))+x205+x203);
evalcond[3]=((((-1.0)*x200*x202))+((new_r11*x206))+x201);
evalcond[4]=(((x205*x206))+x204+new_r10);
evalcond[5]=(((gconst78*x199))+new_r11+(((-1.0)*x200*x202*x206)));
evalcond[6]=(((gconst78*x205))+(((-1.0)*x200*x207))+new_r00);
evalcond[7]=((((-1.0)*x201*x202))+x200+(((-1.0)*new_r11*x202*x206)));
evalcond[8]=((((-1.0)*x202*x204))+(((-1.0)*x199*x207))+new_r01);
evalcond[9]=((((-1.0)*x199))+(((-1.0)*x202*x203))+(((-1.0)*new_r10*x202*x206)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x208=new_r22*new_r22;
CheckValue<IkReal> x209=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x208))),-1);
if(!x209.valid){
continue;
}
if((((-1.0)*x208*(x209.value))) < -0.00001)
continue;
IkReal gconst78=IKsqrt(((-1.0)*x208*(x209.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst78)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst78*gconst78))))) < -0.00001)
continue;
IkReal x210=IKsqrt(((1.0)+(((-1.0)*(gconst78*gconst78)))));
if( IKabs(((((-1.0)*gconst78*new_r10))+(((-1.0)*new_r00*x210)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst78*new_r11))+(((-1.0)*new_r01*x210)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst78*new_r10))+(((-1.0)*new_r00*x210))))+IKsqr(((((-1.0)*gconst78*new_r11))+(((-1.0)*new_r01*x210))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*gconst78*new_r10))+(((-1.0)*new_r00*x210))), ((((-1.0)*gconst78*new_r11))+(((-1.0)*new_r01*x210))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x211=IKcos(j4);
IkReal x212=IKsin(j4);
IkReal x213=(gconst78*new_r01);
IkReal x214=((1.0)*new_r22);
IkReal x215=(gconst78*new_r00);
IkReal x216=((1.0)*x211);
IkReal x217=(gconst78*x212);
IkReal x218=(new_r22*x211);
IkReal x219=x210;
IkReal x220=(new_r22*x219);
IkReal x221=((1.0)*x219);
evalcond[0]=(x212+((gconst78*new_r10))+((new_r00*x219)));
evalcond[1]=(x211+((gconst78*new_r11))+((new_r01*x219)));
evalcond[2]=(((gconst78*x211))+new_r11+((x212*x220)));
evalcond[3]=((((-1.0)*new_r10*x221))+x215+x218);
evalcond[4]=(((gconst78*x218))+((x212*x219))+new_r00);
evalcond[5]=(x212+((new_r11*x220))+(((-1.0)*x213*x214)));
evalcond[6]=((((-1.0)*new_r11*x221))+x213+(((-1.0)*x212*x214)));
evalcond[7]=(((x211*x219))+(((-1.0)*x214*x217))+new_r01);
evalcond[8]=(x217+new_r10+(((-1.0)*x211*x214*x219)));
evalcond[9]=(((new_r10*x220))+(((-1.0)*x214*x215))+(((-1.0)*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x222=new_r22*new_r22;
CheckValue<IkReal> x223=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x222))),-1);
if(!x223.valid){
continue;
}
if((((-1.0)*x222*(x223.value))) < -0.00001)
continue;
IkReal gconst79=((-1.0)*(IKsqrt(((-1.0)*x222*(x223.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst79)))))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
IkReal x224=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
if( IKabs((((new_r00*x224))+(((-1.0)*gconst79*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*x224))+(((-1.0)*gconst79*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*x224))+(((-1.0)*gconst79*new_r10))))+IKsqr((((new_r01*x224))+(((-1.0)*gconst79*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*x224))+(((-1.0)*gconst79*new_r10))), (((new_r01*x224))+(((-1.0)*gconst79*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x225=IKcos(j4);
IkReal x226=IKsin(j4);
IkReal x227=((1.0)*new_r22);
IkReal x228=(gconst79*new_r01);
IkReal x229=(gconst79*new_r00);
IkReal x230=(new_r22*x225);
IkReal x231=(gconst79*x226);
IkReal x232=x224;
IkReal x233=(new_r11*x232);
IkReal x234=(new_r10*x232);
IkReal x235=((1.0)*x232);
evalcond[0]=(x226+((gconst79*new_r10))+(((-1.0)*new_r00*x235)));
evalcond[1]=(x225+((gconst79*new_r11))+(((-1.0)*new_r01*x235)));
evalcond[2]=(x229+x230+x234);
evalcond[3]=(x228+x233+(((-1.0)*x226*x227)));
evalcond[4]=(((x230*x232))+x231+new_r10);
evalcond[5]=((((-1.0)*x226*x227*x232))+((gconst79*x225))+new_r11);
evalcond[6]=(((gconst79*x230))+(((-1.0)*x226*x235))+new_r00);
evalcond[7]=((((-1.0)*x227*x233))+(((-1.0)*x227*x228))+x226);
evalcond[8]=((((-1.0)*x225*x235))+(((-1.0)*x227*x231))+new_r01);
evalcond[9]=((((-1.0)*x227*x234))+(((-1.0)*x227*x229))+(((-1.0)*x225)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x236=new_r22*new_r22;
CheckValue<IkReal> x237=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x236))),-1);
if(!x237.valid){
continue;
}
if((((-1.0)*x236*(x237.value))) < -0.00001)
continue;
IkReal gconst79=((-1.0)*(IKsqrt(((-1.0)*x236*(x237.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj2+(((-1.0)*gconst79)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if((((1.0)+(((-1.0)*(gconst79*gconst79))))) < -0.00001)
continue;
IkReal x238=IKsqrt(((1.0)+(((-1.0)*(gconst79*gconst79)))));
if( IKabs(((((-1.0)*new_r00*x238))+(((-1.0)*gconst79*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x238))+(((-1.0)*gconst79*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x238))+(((-1.0)*gconst79*new_r10))))+IKsqr(((((-1.0)*new_r01*x238))+(((-1.0)*gconst79*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*x238))+(((-1.0)*gconst79*new_r10))), ((((-1.0)*new_r01*x238))+(((-1.0)*gconst79*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x239=IKsin(j4);
IkReal x240=IKcos(j4);
IkReal x241=((1.0)*new_r22);
IkReal x242=(gconst79*new_r01);
IkReal x243=(gconst79*new_r00);
IkReal x244=(new_r22*x240);
IkReal x245=(gconst79*x239);
IkReal x246=x238;
IkReal x247=(new_r10*x246);
IkReal x248=(new_r11*x246);
IkReal x249=(x239*x246);
IkReal x250=(x240*x246);
evalcond[0]=(x239+((new_r00*x246))+((gconst79*new_r10)));
evalcond[1]=(x240+((gconst79*new_r11))+((new_r01*x246)));
evalcond[2]=(((new_r22*x249))+((gconst79*x240))+new_r11);
evalcond[3]=((((-1.0)*x247))+x243+x244);
evalcond[4]=(((gconst79*x244))+x249+new_r00);
evalcond[5]=(((new_r22*x248))+(((-1.0)*x241*x242))+x239);
evalcond[6]=((((-1.0)*x248))+x242+(((-1.0)*x239*x241)));
evalcond[7]=((((-1.0)*x241*x245))+x250+new_r01);
evalcond[8]=((((-1.0)*x241*x250))+x245+new_r10);
evalcond[9]=((((-1.0)*x240))+((new_r22*x247))+(((-1.0)*x241*x243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x251=(new_r01*new_r22);
IkReal x252=(cj2*new_r11);
CheckValue<IkReal> x253=IKPowWithIntegerCheck(cj2,-1);
if(!x253.valid){
continue;
}
if( IKabs(((x253.value)*((((x251*(cj2*cj2)))+(((-1.0)*new_r10))+((new_r22*sj2*x252))+(((-1.0)*x251)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj2))+(((-1.0)*x252)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x253.value)*((((x251*(cj2*cj2)))+(((-1.0)*new_r10))+((new_r22*sj2*x252))+(((-1.0)*x251))))))+IKsqr((((new_r01*sj2))+(((-1.0)*x252))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x253.value)*((((x251*(cj2*cj2)))+(((-1.0)*new_r10))+((new_r22*sj2*x252))+(((-1.0)*x251))))), (((new_r01*sj2))+(((-1.0)*x252))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x254=IKcos(j4);
IkReal x255=IKsin(j4);
IkReal x256=(cj2*new_r01);
IkReal x257=(new_r10*sj2);
IkReal x258=((1.0)*new_r22);
IkReal x259=((1.0)*sj2);
IkReal x260=(new_r11*sj2);
IkReal x261=(cj2*new_r00);
IkReal x262=(cj2*x255);
IkReal x263=(new_r22*x254);
evalcond[0]=(x255+((cj2*new_r10))+(((-1.0)*new_r00*x259)));
evalcond[1]=((((-1.0)*new_r01*x259))+x254+((cj2*new_r11)));
evalcond[2]=(x257+x261+x263);
evalcond[3]=((((-1.0)*x255*x258))+x256+x260);
evalcond[4]=(((sj2*x263))+x262+new_r10);
evalcond[5]=((((-1.0)*sj2*x255*x258))+((cj2*x254))+new_r11);
evalcond[6]=((((-1.0)*x255*x259))+new_r00+((cj2*x263)));
evalcond[7]=((((-1.0)*x258*x260))+(((-1.0)*x256*x258))+x255);
evalcond[8]=((((-1.0)*x258*x262))+(((-1.0)*x254*x259))+new_r01);
evalcond[9]=((((-1.0)*x258*x261))+(((-1.0)*x257*x258))+(((-1.0)*x254)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x264=((1.0)*cj2);
CheckValue<IkReal> x265=IKPowWithIntegerCheck(new_r22,-1);
if(!x265.valid){
continue;
}
if( IKabs((((new_r00*sj2))+(((-1.0)*new_r10*x264)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x265.value)*(((((-1.0)*new_r00*x264))+(((-1.0)*new_r10*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj2))+(((-1.0)*new_r10*x264))))+IKsqr(((x265.value)*(((((-1.0)*new_r00*x264))+(((-1.0)*new_r10*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r00*sj2))+(((-1.0)*new_r10*x264))), ((x265.value)*(((((-1.0)*new_r00*x264))+(((-1.0)*new_r10*sj2))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x266=IKcos(j4);
IkReal x267=IKsin(j4);
IkReal x268=(cj2*new_r01);
IkReal x269=(new_r10*sj2);
IkReal x270=((1.0)*new_r22);
IkReal x271=((1.0)*sj2);
IkReal x272=(new_r11*sj2);
IkReal x273=(cj2*new_r00);
IkReal x274=(cj2*x267);
IkReal x275=(new_r22*x266);
evalcond[0]=((((-1.0)*new_r00*x271))+x267+((cj2*new_r10)));
evalcond[1]=((((-1.0)*new_r01*x271))+x266+((cj2*new_r11)));
evalcond[2]=(x269+x275+x273);
evalcond[3]=(x268+x272+(((-1.0)*x267*x270)));
evalcond[4]=(((sj2*x275))+x274+new_r10);
evalcond[5]=((((-1.0)*sj2*x267*x270))+new_r11+((cj2*x266)));
evalcond[6]=(new_r00+(((-1.0)*x267*x271))+((cj2*x275)));
evalcond[7]=(x267+(((-1.0)*x268*x270))+(((-1.0)*x270*x272)));
evalcond[8]=((((-1.0)*x266*x271))+(((-1.0)*x270*x274))+new_r01);
evalcond[9]=((((-1.0)*x266))+(((-1.0)*x269*x270))+(((-1.0)*x270*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x276=cj2*cj2;
IkReal x277=new_r22*new_r22;
IkReal x278=(new_r22*sj2);
IkReal x279=((1.0)*cj2);
CheckValue<IkReal> x280=IKPowWithIntegerCheck(IKsign(((((-1.0)*x276*x277))+x276+x277)),-1);
if(!x280.valid){
continue;
}
CheckValue<IkReal> x281 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x279))+((new_r11*x278)))),IkReal(((((-1.0)*new_r11*x279))+(((-1.0)*new_r10*x278)))),IKFAST_ATAN2_MAGTHRESH);
if(!x281.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x280.value)))+(x281.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x282=IKcos(j4);
IkReal x283=IKsin(j4);
IkReal x284=(cj2*new_r01);
IkReal x285=(new_r10*sj2);
IkReal x286=((1.0)*new_r22);
IkReal x287=((1.0)*sj2);
IkReal x288=(new_r11*sj2);
IkReal x289=(cj2*new_r00);
IkReal x290=(cj2*x283);
IkReal x291=(new_r22*x282);
evalcond[0]=((((-1.0)*new_r00*x287))+x283+((cj2*new_r10)));
evalcond[1]=(x282+(((-1.0)*new_r01*x287))+((cj2*new_r11)));
evalcond[2]=(x291+x289+x285);
evalcond[3]=(x288+x284+(((-1.0)*x283*x286)));
evalcond[4]=(x290+new_r10+((sj2*x291)));
evalcond[5]=((((-1.0)*sj2*x283*x286))+((cj2*x282))+new_r11);
evalcond[6]=(((cj2*x291))+new_r00+(((-1.0)*x283*x287)));
evalcond[7]=(x283+(((-1.0)*x284*x286))+(((-1.0)*x286*x288)));
evalcond[8]=((((-1.0)*x286*x290))+(((-1.0)*x282*x287))+new_r01);
evalcond[9]=((((-1.0)*x282))+(((-1.0)*x285*x286))+(((-1.0)*x286*x289)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x293=IKPowWithIntegerCheck(sj3,-1);
if(!x293.valid){
continue;
}
IkReal x292=x293.value;
CheckValue<IkReal> x294=IKPowWithIntegerCheck(new_r12,-1);
if(!x294.valid){
continue;
}
if( IKabs((x292*(x294.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x292)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x292*(x294.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))))+IKsqr((new_r02*x292))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x292*(x294.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj3*cj3)))))), (new_r02*x292));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x295=IKcos(j2);
IkReal x296=IKsin(j2);
IkReal x297=((1.0)*sj3);
IkReal x298=(new_r02*x295);
IkReal x299=(new_r12*x296);
IkReal x300=(x296*x297);
evalcond[0]=((((-1.0)*x295*x297))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x300)));
evalcond[2]=(((new_r12*x295))+(((-1.0)*new_r02*x296)));
evalcond[3]=((((-1.0)*x297))+x298+x299);
evalcond[4]=(((cj3*x299))+((cj3*x298))+((new_r22*sj3)));
evalcond[5]=((((-1.0)*new_r00*x295*x297))+((cj3*new_r20))+(((-1.0)*new_r10*x300)));
evalcond[6]=((((-1.0)*new_r11*x300))+(((-1.0)*new_r01*x295*x297))+((cj3*new_r21)));
evalcond[7]=((1.0)+(((-1.0)*x297*x298))+(((-1.0)*x297*x299))+((cj3*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
j4eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x301=((1.0)*cj2);
if( IKabs(((((-1.0)*new_r01*x301))+(((-1.0)*new_r11*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj2))+(((-1.0)*new_r11*x301)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x301))+(((-1.0)*new_r11*sj2))))+IKsqr((((new_r01*sj2))+(((-1.0)*new_r11*x301))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r01*x301))+(((-1.0)*new_r11*sj2))), (((new_r01*sj2))+(((-1.0)*new_r11*x301))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x302=IKsin(j4);
IkReal x303=IKcos(j4);
IkReal x304=((1.0)*sj2);
IkReal x305=(cj2*x302);
IkReal x306=(cj2*x303);
IkReal x307=(x303*x304);
evalcond[0]=(((new_r11*sj2))+x302+((cj2*new_r01)));
evalcond[1]=(x302+((cj2*new_r10))+(((-1.0)*new_r00*x304)));
evalcond[2]=(x303+(((-1.0)*new_r01*x304))+((cj2*new_r11)));
evalcond[3]=(((sj2*x302))+x306+new_r11);
evalcond[4]=(((new_r10*sj2))+(((-1.0)*x303))+((cj2*new_r00)));
evalcond[5]=(x305+new_r01+(((-1.0)*x307)));
evalcond[6]=(x305+new_r10+(((-1.0)*x307)));
evalcond[7]=((((-1.0)*x302*x304))+(((-1.0)*x306))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x308=((1.0)*new_r10);
if( IKabs(((((-1.0)*cj2*x308))+((new_r11*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj2*x308))+(((-1.0)*cj2*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj2*x308))+((new_r11*sj2))))+IKsqr(((((-1.0)*sj2*x308))+(((-1.0)*cj2*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj2*x308))+((new_r11*sj2))), ((((-1.0)*sj2*x308))+(((-1.0)*cj2*new_r11))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x309=IKcos(j4);
IkReal x310=IKsin(j4);
IkReal x311=((1.0)*sj2);
IkReal x312=(cj2*x309);
IkReal x313=((1.0)*x310);
IkReal x314=(x310*x311);
evalcond[0]=(((new_r10*sj2))+x309+((cj2*new_r00)));
evalcond[1]=((((-1.0)*new_r00*x311))+x310+((cj2*new_r10)));
evalcond[2]=(x309+((cj2*new_r11))+(((-1.0)*new_r01*x311)));
evalcond[3]=(((new_r11*sj2))+(((-1.0)*x313))+((cj2*new_r01)));
evalcond[4]=(((sj2*x309))+((cj2*x310))+new_r10);
evalcond[5]=(x312+(((-1.0)*x314))+new_r11);
evalcond[6]=(x312+(((-1.0)*x314))+new_r00);
evalcond[7]=(new_r01+(((-1.0)*x309*x311))+(((-1.0)*cj2*x313)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x315=IKsin(j4);
IkReal x316=IKcos(j4);
IkReal x317=((1.0)*x316);
evalcond[0]=(x315+new_r10);
evalcond[1]=(x316+new_r11);
evalcond[2]=(new_r21+((sj3*x315)));
evalcond[3]=(((cj3*x315))+new_r01);
evalcond[4]=((((-1.0)*sj3*x317))+new_r20);
evalcond[5]=(new_r00+(((-1.0)*cj3*x317)));
evalcond[6]=(x315+((cj3*new_r01))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x317))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x318=IKsin(j4);
IkReal x319=IKcos(j4);
IkReal x320=((1.0)*new_r00);
IkReal x321=((1.0)*new_r01);
IkReal x322=((1.0)*x319);
evalcond[0]=(new_r21+((sj3*x318)));
evalcond[1]=(x318+(((-1.0)*new_r10)));
evalcond[2]=(x319+(((-1.0)*new_r11)));
evalcond[3]=(new_r20+(((-1.0)*sj3*x322)));
evalcond[4]=((((-1.0)*x321))+((cj3*x318)));
evalcond[5]=((((-1.0)*cj3*x322))+(((-1.0)*x320)));
evalcond[6]=((((-1.0)*cj3*x321))+x318+((new_r21*sj3)));
evalcond[7]=((((-1.0)*cj3*x320))+((new_r20*sj3))+(((-1.0)*x322)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x323=IKsin(j4);
IkReal x324=IKcos(j4);
IkReal x325=((1.0)*x324);
evalcond[0]=(((sj3*x323))+new_r21);
evalcond[1]=(x323+(((-1.0)*new_r00)));
evalcond[2]=(x324+(((-1.0)*new_r01)));
evalcond[3]=(new_r11+((cj3*x323)));
evalcond[4]=(new_r20+(((-1.0)*sj3*x325)));
evalcond[5]=((((-1.0)*cj3*x325))+new_r10);
evalcond[6]=(x323+((cj3*new_r11))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x325))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x326=IKsin(j4);
IkReal x327=IKcos(j4);
IkReal x328=((1.0)*cj3);
IkReal x329=((1.0)*x327);
evalcond[0]=(x326+new_r00);
evalcond[1]=(x327+new_r01);
evalcond[2]=(((sj3*x326))+new_r21);
evalcond[3]=(new_r20+(((-1.0)*sj3*x329)));
evalcond[4]=((((-1.0)*new_r11))+((cj3*x326)));
evalcond[5]=((((-1.0)*x327*x328))+(((-1.0)*new_r10)));
evalcond[6]=(x326+((new_r21*sj3))+(((-1.0)*new_r11*x328)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x329))+(((-1.0)*new_r10*x328)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=((-1.0)*new_r22);
op[1]=0;
op[2]=new_r22;
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x331=IKPowWithIntegerCheck(sj3,-1);
if(!x331.valid){
continue;
}
IkReal x330=x331.value;
CheckValue<IkReal> x332=IKPowWithIntegerCheck(sj2,-1);
if(!x332.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x330)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x330*(x332.value)*((((new_r01*sj3))+(((-1.0)*cj2*cj3*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x330))+IKsqr((x330*(x332.value)*((((new_r01*sj3))+(((-1.0)*cj2*cj3*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x330), (x330*(x332.value)*((((new_r01*sj3))+(((-1.0)*cj2*cj3*new_r21))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x333=IKsin(j4);
IkReal x334=IKcos(j4);
IkReal x335=(cj2*new_r01);
IkReal x336=(new_r10*sj2);
IkReal x337=((1.0)*sj2);
IkReal x338=(cj3*sj2);
IkReal x339=(cj2*new_r00);
IkReal x340=((1.0)*x334);
IkReal x341=(cj2*x333);
evalcond[0]=(((sj3*x333))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj3*x340)));
evalcond[2]=(x333+(((-1.0)*new_r00*x337))+((cj2*new_r10)));
evalcond[3]=(x334+((cj2*new_r11))+(((-1.0)*new_r01*x337)));
evalcond[4]=(((new_r11*sj2))+((cj3*x333))+x335);
evalcond[5]=(((cj2*x334))+((x333*x338))+new_r11);
evalcond[6]=((((-1.0)*cj3*x340))+x339+x336);
evalcond[7]=(new_r01+(((-1.0)*x334*x337))+((cj3*x341)));
evalcond[8]=(x341+new_r10+(((-1.0)*cj3*x334*x337)));
evalcond[9]=((((-1.0)*x333*x337))+new_r00+(((-1.0)*cj2*cj3*x340)));
evalcond[10]=(((new_r11*x338))+((cj3*x335))+x333+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+((cj3*x339))+((cj3*x336))+(((-1.0)*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x343=IKPowWithIntegerCheck(sj3,-1);
if(!x343.valid){
continue;
}
IkReal x342=x343.value;
CheckValue<IkReal> x344=IKPowWithIntegerCheck(cj2,-1);
if(!x344.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x342)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x342*(x344.value)*((((cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x342))+IKsqr((x342*(x344.value)*((((cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x342), (x342*(x344.value)*((((cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x345=IKsin(j4);
IkReal x346=IKcos(j4);
IkReal x347=(cj2*new_r01);
IkReal x348=(new_r10*sj2);
IkReal x349=((1.0)*sj2);
IkReal x350=(cj3*sj2);
IkReal x351=(cj2*new_r00);
IkReal x352=((1.0)*x346);
IkReal x353=(cj2*x345);
evalcond[0]=(((sj3*x345))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj3*x352)));
evalcond[2]=(x345+(((-1.0)*new_r00*x349))+((cj2*new_r10)));
evalcond[3]=(x346+((cj2*new_r11))+(((-1.0)*new_r01*x349)));
evalcond[4]=(((new_r11*sj2))+x347+((cj3*x345)));
evalcond[5]=(((x345*x350))+new_r11+((cj2*x346)));
evalcond[6]=((((-1.0)*cj3*x352))+x351+x348);
evalcond[7]=(((cj3*x353))+(((-1.0)*x346*x349))+new_r01);
evalcond[8]=((((-1.0)*cj3*x346*x349))+x353+new_r10);
evalcond[9]=((((-1.0)*x345*x349))+(((-1.0)*cj2*cj3*x352))+new_r00);
evalcond[10]=(x345+((new_r21*sj3))+((new_r11*x350))+((cj3*x347)));
evalcond[11]=(((cj3*x351))+((new_r20*sj3))+(((-1.0)*x352))+((cj3*x348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x354=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x354.valid){
continue;
}
CheckValue<IkReal> x355 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x355.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x354.value)))+(x355.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x356=IKsin(j4);
IkReal x357=IKcos(j4);
IkReal x358=(cj2*new_r01);
IkReal x359=(new_r10*sj2);
IkReal x360=((1.0)*sj2);
IkReal x361=(cj3*sj2);
IkReal x362=(cj2*new_r00);
IkReal x363=((1.0)*x357);
IkReal x364=(cj2*x356);
evalcond[0]=(((sj3*x356))+new_r21);
evalcond[1]=((((-1.0)*sj3*x363))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x360))+x356+((cj2*new_r10)));
evalcond[3]=(x357+((cj2*new_r11))+(((-1.0)*new_r01*x360)));
evalcond[4]=(((cj3*x356))+((new_r11*sj2))+x358);
evalcond[5]=(((x356*x361))+new_r11+((cj2*x357)));
evalcond[6]=(x359+x362+(((-1.0)*cj3*x363)));
evalcond[7]=(new_r01+(((-1.0)*x357*x360))+((cj3*x364)));
evalcond[8]=(x364+(((-1.0)*cj3*x357*x360))+new_r10);
evalcond[9]=((((-1.0)*x356*x360))+(((-1.0)*cj2*cj3*x363))+new_r00);
evalcond[10]=(((cj3*x358))+x356+((new_r21*sj3))+((new_r11*x361)));
evalcond[11]=(((cj3*x359))+((new_r20*sj3))+(((-1.0)*x363))+((cj3*x362)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x365=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x365.valid){
continue;
}
CheckValue<IkReal> x366 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x366.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x365.value)))+(x366.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(new_r21+((sj3*(IKsin(j4)))));
evalcond[1]=((((-1.0)*sj3*(IKcos(j4))))+new_r20);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj3;
j2eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=new_r00;
j2eval[1]=sj3;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x367=((1.0)*sj4);
IkReal x368=(((new_r10*new_r11))+((new_r00*new_r01)));
j2eval[0]=x368;
j2eval[1]=((IKabs(((((-1.0)*new_r00*x367))+(((-1.0)*new_r11*x367)))))+(IKabs((((new_r01*sj4))+(((-1.0)*new_r10*x367))))));
j2eval[2]=IKsign(x368);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x369=((1.0)*new_r11);
IkReal x370=((new_r01*new_r01)+(new_r11*new_r11));
j2eval[0]=x370;
j2eval[1]=((IKabs(((((-1.0)*sj4*x369))+((cj4*new_r01)))))+(IKabs(((((-1.0)*cj4*x369))+(((-1.0)*new_r01*sj4))))));
j2eval[2]=IKsign(x370);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x371=(((cj4*new_r01))+((new_r11*sj4)));
j2eval[0]=x371;
j2eval[1]=IKsign(x371);
j2eval[2]=((IKabs(((-1.0)+(new_r01*new_r01)+(cj4*cj4))))+(IKabs(((((-1.0)*cj4*sj4))+(((-1.0)*new_r01*new_r11))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x373 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x373)==0){
continue;
}
IkReal x372=pow(x373,-0.5);
CheckValue<IkReal> x374 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x374.valid){
continue;
}
IkReal gconst66=((-1.0)*(x374.value));
IkReal gconst67=((-1.0)*new_r01*x372);
IkReal gconst68=(new_r11*x372);
CheckValue<IkReal> x375 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x375.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x375.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x378 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x378.valid){
continue;
}
IkReal x376=((-1.0)*(x378.value));
IkReal x377=x372;
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x376;
IkReal gconst66=x376;
IkReal gconst67=((-1.0)*new_r01*x377);
IkReal gconst68=(new_r11*x377);
IkReal x379=new_r01*new_r01;
IkReal x380=(new_r00*new_r01);
IkReal x381=(((new_r10*new_r11))+x380);
IkReal x382=x372;
IkReal x383=(new_r01*x382);
j2eval[0]=x381;
j2eval[1]=((IKabs((((new_r10*x383))+(((-1.0)*x379*x382)))))+(IKabs((((new_r11*x383))+((x380*x382))))));
j2eval[2]=IKsign(x381);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x386 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x386.valid){
continue;
}
IkReal x384=((-1.0)*(x386.value));
IkReal x385=x372;
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x384;
IkReal gconst66=x384;
IkReal gconst67=((-1.0)*new_r01*x385);
IkReal gconst68=(new_r11*x385);
IkReal x387=((new_r01*new_r01)+(new_r11*new_r11));
j2eval[0]=x387;
j2eval[1]=IKsign(x387);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x390 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x390.valid){
continue;
}
IkReal x388=((-1.0)*(x390.value));
IkReal x389=x372;
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x388;
IkReal gconst66=x388;
IkReal gconst67=((-1.0)*new_r01*x389);
IkReal gconst68=(new_r11*x389);
IkReal x391=new_r01*new_r01;
IkReal x392=new_r11*new_r11;
IkReal x393=((1.0)*x391);
CheckValue<IkReal> x399=IKPowWithIntegerCheck((x391+x392),-1);
if(!x399.valid){
continue;
}
IkReal x394=x399.value;
CheckValue<IkReal> x400=IKPowWithIntegerCheck(((((-1.0)*x393))+(((-1.0)*x392))),-1);
if(!x400.valid){
continue;
}
IkReal x395=x400.value;
IkReal x396=((1.0)*x395);
IkReal x397=(new_r11*x396);
IkReal x398=(new_r01*x396);
j2eval[0]=((IKabs((((x394*(x392*x392)))+((x391*x392*x394))+(((-1.0)*x393*x394)))))+(IKabs(((((-1.0)*new_r01*x397))+(((-1.0)*x397*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x397*(new_r11*new_r11)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x402 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x402.valid){
continue;
}
IkReal x401=((-1.0)*(x402.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x401;
new_r11=0;
new_r00=0;
IkReal gconst66=x401;
IkReal x403 = new_r01*new_r01;
if(IKabs(x403)==0){
continue;
}
IkReal gconst67=((-1.0)*new_r01*(pow(x403,-0.5)));
IkReal gconst68=0;
j2eval[0]=new_r10;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x405 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x405.valid){
continue;
}
IkReal x404=((-1.0)*(x405.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x404;
new_r11=0;
new_r00=0;
IkReal gconst66=x404;
IkReal x406 = new_r01*new_r01;
if(IKabs(x406)==0){
continue;
}
IkReal gconst67=((-1.0)*new_r01*(pow(x406,-0.5)));
IkReal gconst68=0;
j2eval[0]=new_r01;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x407=IKPowWithIntegerCheck(gconst67,-1);
if(!x407.valid){
continue;
}
cj2array[0]=((-1.0)*new_r01*(x407.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x408=IKsin(j2);
IkReal x409=IKcos(j2);
evalcond[0]=(gconst67*x408);
evalcond[1]=(new_r10*x408);
evalcond[2]=((-1.0)*new_r01*x408);
evalcond[3]=(gconst67+((new_r10*x409)));
evalcond[4]=(gconst67+((new_r01*x409)));
evalcond[5]=(((gconst67*x409))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x410=IKPowWithIntegerCheck(new_r01,-1);
if(!x410.valid){
continue;
}
cj2array[0]=((-1.0)*gconst67*(x410.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x411=IKsin(j2);
IkReal x412=IKcos(j2);
IkReal x413=(gconst67*x412);
evalcond[0]=(gconst67*x411);
evalcond[1]=(new_r10*x411);
evalcond[2]=((-1.0)*new_r01*x411);
evalcond[3]=(gconst67+((new_r10*x412)));
evalcond[4]=(x413+new_r01);
evalcond[5]=(x413+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x414=IKPowWithIntegerCheck(new_r10,-1);
if(!x414.valid){
continue;
}
cj2array[0]=((-1.0)*gconst67*(x414.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x415=IKsin(j2);
IkReal x416=IKcos(j2);
IkReal x417=(gconst67*x416);
evalcond[0]=(gconst67*x415);
evalcond[1]=(new_r10*x415);
evalcond[2]=((-1.0)*new_r01*x415);
evalcond[3]=(gconst67+((new_r01*x416)));
evalcond[4]=(x417+new_r01);
evalcond[5]=(x417+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst67;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x419 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x419.valid){
continue;
}
IkReal x418=((-1.0)*(x419.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x418;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst66=x418;
IkReal gconst67=((-1.0)*new_r01);
IkReal gconst68=new_r11;
j2eval[0]=-1.0;
j2eval[1]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
j2eval[2]=-1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x421 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x421.valid){
continue;
}
IkReal x420=((-1.0)*(x421.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x420;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst66=x420;
IkReal gconst67=((-1.0)*new_r01);
IkReal gconst68=new_r11;
j2eval[0]=-1.0;
j2eval[1]=-1.0;
j2eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x423 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x423.valid){
continue;
}
IkReal x422=((-1.0)*(x423.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x422;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst66=x422;
IkReal gconst67=((-1.0)*new_r01);
IkReal gconst68=new_r11;
j2eval[0]=1.0;
j2eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j2eval[2]=1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x424=((1.0)*gconst67);
CheckValue<IkReal> x425 = IKatan2WithCheck(IkReal((((gconst68*new_r01))+(((-1.0)*new_r11*x424)))),IkReal(((((-1.0)*gconst68*new_r11))+(((-1.0)*new_r01*x424)))),IKFAST_ATAN2_MAGTHRESH);
if(!x425.valid){
continue;
}
CheckValue<IkReal> x426=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x426.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x425.value)+(((1.5707963267949)*(x426.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x427=IKcos(j2);
IkReal x428=IKsin(j2);
IkReal x429=((1.0)*gconst68);
IkReal x430=(gconst67*x427);
IkReal x431=((1.0)*x428);
IkReal x432=(x428*x429);
evalcond[0]=(gconst67+((new_r11*x428))+((new_r01*x427)));
evalcond[1]=(((gconst67*x428))+new_r11+((gconst68*x427)));
evalcond[2]=((((-1.0)*x432))+x430);
evalcond[3]=((((-1.0)*new_r01*x431))+gconst68+((new_r11*x427)));
evalcond[4]=((((-1.0)*x432))+x430+new_r01);
evalcond[5]=((((-1.0)*x427*x429))+(((-1.0)*gconst67*x431)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x433 = IKatan2WithCheck(IkReal((gconst67*new_r11)),IkReal((gconst68*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x433.valid){
continue;
}
CheckValue<IkReal> x434=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst67*gconst67)))+(((-1.0)*(gconst68*gconst68))))),-1);
if(!x434.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x433.value)+(((1.5707963267949)*(x434.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x435=IKcos(j2);
IkReal x436=IKsin(j2);
IkReal x437=((1.0)*gconst68);
IkReal x438=(gconst67*x435);
IkReal x439=((1.0)*x436);
IkReal x440=(x436*x437);
evalcond[0]=(((new_r01*x435))+gconst67+((new_r11*x436)));
evalcond[1]=(((gconst68*x435))+new_r11+((gconst67*x436)));
evalcond[2]=((((-1.0)*x440))+x438);
evalcond[3]=((((-1.0)*new_r01*x439))+gconst68+((new_r11*x435)));
evalcond[4]=((((-1.0)*x440))+x438+new_r01);
evalcond[5]=((((-1.0)*x435*x437))+(((-1.0)*gconst67*x439)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x441=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst68*new_r11))+((gconst67*new_r01)))),-1);
if(!x441.valid){
continue;
}
CheckValue<IkReal> x442 = IKatan2WithCheck(IkReal((gconst67*gconst68)),IkReal(((-1.0)*(gconst67*gconst67))),IKFAST_ATAN2_MAGTHRESH);
if(!x442.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x441.value)))+(x442.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x443=IKcos(j2);
IkReal x444=IKsin(j2);
IkReal x445=((1.0)*gconst68);
IkReal x446=(gconst67*x443);
IkReal x447=((1.0)*x444);
IkReal x448=(x444*x445);
evalcond[0]=(((new_r01*x443))+gconst67+((new_r11*x444)));
evalcond[1]=(((gconst68*x443))+new_r11+((gconst67*x444)));
evalcond[2]=((((-1.0)*x448))+x446);
evalcond[3]=((((-1.0)*new_r01*x447))+gconst68+((new_r11*x443)));
evalcond[4]=((((-1.0)*x448))+x446+new_r01);
evalcond[5]=((((-1.0)*gconst67*x447))+(((-1.0)*x443*x445)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x449=IKPowWithIntegerCheck(gconst68,-1);
if(!x449.valid){
continue;
}
cj2array[0]=(new_r00*(x449.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x450=IKsin(j2);
IkReal x451=IKcos(j2);
IkReal x452=((-1.0)*x450);
evalcond[0]=(new_r11*x450);
evalcond[1]=(new_r00*x452);
evalcond[2]=(gconst68*x452);
evalcond[3]=(((new_r11*x451))+gconst68);
evalcond[4]=(((gconst68*x451))+new_r11);
evalcond[5]=((((-1.0)*gconst68))+((new_r00*x451)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
IkReal x453=((-1.0)*(x454.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x453;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst66=x453;
IkReal gconst67=0;
IkReal x455 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x455)==0){
continue;
}
IkReal gconst68=(new_r11*(pow(x455,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x457 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x457.valid){
continue;
}
IkReal x456=((-1.0)*(x457.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x456;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst66=x456;
IkReal gconst67=0;
IkReal x458 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x458)==0){
continue;
}
IkReal gconst68=(new_r11*(pow(x458,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x460 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x460.valid){
continue;
}
IkReal x459=((-1.0)*(x460.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x459;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst66=x459;
IkReal gconst67=0;
IkReal x461 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x461)==0){
continue;
}
IkReal gconst68=(new_r11*(pow(x461,-0.5)));
j2eval[0]=new_r10;
j2eval[1]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x462=IKPowWithIntegerCheck(new_r10,-1);
if(!x462.valid){
continue;
}
CheckValue<IkReal> x463=IKPowWithIntegerCheck(new_r11,-1);
if(!x463.valid){
continue;
}
if( IKabs((gconst68*(x462.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst68*(x463.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst68*(x462.value)))+IKsqr(((-1.0)*gconst68*(x463.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((gconst68*(x462.value)), ((-1.0)*gconst68*(x463.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x464=IKsin(j2);
IkReal x465=IKcos(j2);
IkReal x466=(gconst68*x464);
IkReal x467=(gconst68*x465);
evalcond[0]=(new_r10*x465);
evalcond[1]=(new_r11*x464);
evalcond[2]=((-1.0)*x466);
evalcond[3]=((-1.0)*x467);
evalcond[4]=(((new_r11*x465))+gconst68);
evalcond[5]=(x467+new_r11);
evalcond[6]=((((-1.0)*x466))+new_r10);
evalcond[7]=(((new_r10*x464))+(((-1.0)*gconst68)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x468=IKPowWithIntegerCheck(gconst68,-1);
if(!x468.valid){
continue;
}
CheckValue<IkReal> x469=IKPowWithIntegerCheck(new_r11,-1);
if(!x469.valid){
continue;
}
if( IKabs((new_r10*(x468.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst68*(x469.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x468.value)))+IKsqr(((-1.0)*gconst68*(x469.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x468.value)), ((-1.0)*gconst68*(x469.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x470=IKsin(j2);
IkReal x471=IKcos(j2);
IkReal x472=(gconst68*x470);
IkReal x473=(gconst68*x471);
evalcond[0]=(new_r10*x471);
evalcond[1]=(new_r11*x470);
evalcond[2]=((-1.0)*x472);
evalcond[3]=((-1.0)*x473);
evalcond[4]=(gconst68+((new_r11*x471)));
evalcond[5]=(x473+new_r11);
evalcond[6]=((((-1.0)*x472))+new_r10);
evalcond[7]=((((-1.0)*gconst68))+((new_r10*x470)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x474=IKPowWithIntegerCheck(IKsign(gconst68),-1);
if(!x474.valid){
continue;
}
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x474.value)))+(x475.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x476=IKsin(j2);
IkReal x477=IKcos(j2);
IkReal x478=(gconst68*x476);
IkReal x479=(gconst68*x477);
evalcond[0]=(new_r10*x477);
evalcond[1]=(new_r11*x476);
evalcond[2]=((-1.0)*x478);
evalcond[3]=((-1.0)*x479);
evalcond[4]=(gconst68+((new_r11*x477)));
evalcond[5]=(x479+new_r11);
evalcond[6]=((((-1.0)*x478))+new_r10);
evalcond[7]=((((-1.0)*gconst68))+((new_r10*x476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x481 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x481.valid){
continue;
}
IkReal x480=((-1.0)*(x481.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x480;
new_r01=0;
IkReal gconst66=x480;
IkReal gconst67=0;
IkReal x482 = new_r11*new_r11;
if(IKabs(x482)==0){
continue;
}
IkReal gconst68=(new_r11*(pow(x482,-0.5)));
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x484 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x484.valid){
continue;
}
IkReal x483=((-1.0)*(x484.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x483;
new_r01=0;
IkReal gconst66=x483;
IkReal gconst67=0;
IkReal x485 = new_r11*new_r11;
if(IKabs(x485)==0){
continue;
}
IkReal gconst68=(new_r11*(pow(x485,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x487 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x487.valid){
continue;
}
IkReal x486=((-1.0)*(x487.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst67;
cj4=gconst68;
j4=x486;
new_r01=0;
IkReal gconst66=x486;
IkReal gconst67=0;
IkReal x488 = new_r11*new_r11;
if(IKabs(x488)==0){
continue;
}
IkReal gconst68=(new_r11*(pow(x488,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x489=IKPowWithIntegerCheck(gconst68,-1);
if(!x489.valid){
continue;
}
CheckValue<IkReal> x490=IKPowWithIntegerCheck(new_r11,-1);
if(!x490.valid){
continue;
}
if( IKabs((new_r10*(x489.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst68*(x490.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x489.value)))+IKsqr(((-1.0)*gconst68*(x490.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x489.value)), ((-1.0)*gconst68*(x490.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x491=IKsin(j2);
IkReal x492=IKcos(j2);
IkReal x493=((1.0)*gconst68);
evalcond[0]=(new_r11*x491);
evalcond[1]=((-1.0)*gconst68*x491);
evalcond[2]=(gconst68+((new_r11*x492)));
evalcond[3]=(((gconst68*x492))+new_r11);
evalcond[4]=((((-1.0)*x491*x493))+new_r10);
evalcond[5]=(new_r00+(((-1.0)*x492*x493)));
evalcond[6]=(((new_r10*x492))+(((-1.0)*new_r00*x491)));
evalcond[7]=((((-1.0)*x493))+((new_r10*x491))+((new_r00*x492)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x494=IKPowWithIntegerCheck(IKsign(gconst68),-1);
if(!x494.valid){
continue;
}
CheckValue<IkReal> x495 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x495.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x494.value)))+(x495.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x496=IKsin(j2);
IkReal x497=IKcos(j2);
IkReal x498=((1.0)*gconst68);
evalcond[0]=(new_r11*x496);
evalcond[1]=((-1.0)*gconst68*x496);
evalcond[2]=(gconst68+((new_r11*x497)));
evalcond[3]=(((gconst68*x497))+new_r11);
evalcond[4]=((((-1.0)*x496*x498))+new_r10);
evalcond[5]=((((-1.0)*x497*x498))+new_r00);
evalcond[6]=(((new_r10*x497))+(((-1.0)*new_r00*x496)));
evalcond[7]=((((-1.0)*x498))+((new_r10*x496))+((new_r00*x497)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x499=IKPowWithIntegerCheck(IKsign(gconst68),-1);
if(!x499.valid){
continue;
}
CheckValue<IkReal> x500 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x500.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x499.value)))+(x500.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x501=IKsin(j2);
IkReal x502=IKcos(j2);
IkReal x503=((1.0)*gconst68);
evalcond[0]=(new_r11*x501);
evalcond[1]=((-1.0)*gconst68*x501);
evalcond[2]=(gconst68+((new_r11*x502)));
evalcond[3]=(((gconst68*x502))+new_r11);
evalcond[4]=((((-1.0)*x501*x503))+new_r10);
evalcond[5]=((((-1.0)*x502*x503))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x501))+((new_r10*x502)));
evalcond[7]=((((-1.0)*x503))+((new_r10*x501))+((new_r00*x502)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x504=((1.0)*new_r11);
CheckValue<IkReal> x505=IKPowWithIntegerCheck(IKsign((((gconst67*new_r01))+(((-1.0)*gconst68*x504)))),-1);
if(!x505.valid){
continue;
}
CheckValue<IkReal> x506 = IKatan2WithCheck(IkReal((((gconst67*gconst68))+(((-1.0)*new_r01*x504)))),IkReal(((((-1.0)*(gconst67*gconst67)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x506.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x505.value)))+(x506.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x507=IKcos(j2);
IkReal x508=IKsin(j2);
IkReal x509=((1.0)*gconst68);
IkReal x510=(gconst67*x507);
IkReal x511=((1.0)*x508);
IkReal x512=(x508*x509);
evalcond[0]=(gconst67+((new_r11*x508))+((new_r01*x507)));
evalcond[1]=(((gconst67*x508))+((gconst68*x507))+new_r11);
evalcond[2]=(gconst67+((new_r10*x507))+(((-1.0)*new_r00*x511)));
evalcond[3]=(gconst68+((new_r11*x507))+(((-1.0)*new_r01*x511)));
evalcond[4]=(x510+new_r01+(((-1.0)*x512)));
evalcond[5]=(x510+new_r10+(((-1.0)*x512)));
evalcond[6]=((((-1.0)*x509))+((new_r10*x508))+((new_r00*x507)));
evalcond[7]=((((-1.0)*x507*x509))+new_r00+(((-1.0)*gconst67*x511)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x513=((1.0)*gconst67);
CheckValue<IkReal> x514 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x513))+((gconst68*new_r01)))),IkReal(((((-1.0)*gconst68*new_r11))+(((-1.0)*new_r01*x513)))),IKFAST_ATAN2_MAGTHRESH);
if(!x514.valid){
continue;
}
CheckValue<IkReal> x515=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x515.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x514.value)+(((1.5707963267949)*(x515.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x516=IKcos(j2);
IkReal x517=IKsin(j2);
IkReal x518=((1.0)*gconst68);
IkReal x519=(gconst67*x516);
IkReal x520=((1.0)*x517);
IkReal x521=(x517*x518);
evalcond[0]=(((new_r01*x516))+((new_r11*x517))+gconst67);
evalcond[1]=(new_r11+((gconst67*x517))+((gconst68*x516)));
evalcond[2]=(((new_r10*x516))+gconst67+(((-1.0)*new_r00*x520)));
evalcond[3]=(((new_r11*x516))+gconst68+(((-1.0)*new_r01*x520)));
evalcond[4]=((((-1.0)*x521))+x519+new_r01);
evalcond[5]=((((-1.0)*x521))+x519+new_r10);
evalcond[6]=(((new_r00*x516))+((new_r10*x517))+(((-1.0)*x518)));
evalcond[7]=((((-1.0)*x516*x518))+(((-1.0)*gconst67*x520))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x522=((1.0)*gconst67);
CheckValue<IkReal> x523 = IKatan2WithCheck(IkReal((((gconst67*new_r01))+(((-1.0)*new_r10*x522)))),IkReal(((((-1.0)*new_r00*x522))+(((-1.0)*new_r11*x522)))),IKFAST_ATAN2_MAGTHRESH);
if(!x523.valid){
continue;
}
CheckValue<IkReal> x524=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x524.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x523.value)+(((1.5707963267949)*(x524.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x525=IKcos(j2);
IkReal x526=IKsin(j2);
IkReal x527=((1.0)*gconst68);
IkReal x528=(gconst67*x525);
IkReal x529=((1.0)*x526);
IkReal x530=(x526*x527);
evalcond[0]=(((new_r01*x525))+gconst67+((new_r11*x526)));
evalcond[1]=(((gconst67*x526))+((gconst68*x525))+new_r11);
evalcond[2]=(gconst67+(((-1.0)*new_r00*x529))+((new_r10*x525)));
evalcond[3]=(gconst68+((new_r11*x525))+(((-1.0)*new_r01*x529)));
evalcond[4]=((((-1.0)*x530))+x528+new_r01);
evalcond[5]=((((-1.0)*x530))+x528+new_r10);
evalcond[6]=((((-1.0)*x527))+((new_r10*x526))+((new_r00*x525)));
evalcond[7]=((((-1.0)*x525*x527))+(((-1.0)*gconst67*x529))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x532 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x532)==0){
continue;
}
IkReal x531=pow(x532,-0.5);
CheckValue<IkReal> x533 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x533.valid){
continue;
}
IkReal gconst69=((3.14159265358979)+(((-1.0)*(x533.value))));
IkReal gconst70=((1.0)*new_r01*x531);
IkReal gconst71=((-1.0)*new_r11*x531);
CheckValue<IkReal> x534 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x534.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x534.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
CheckValue<IkReal> x537 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x537.valid){
continue;
}
IkReal x535=((1.0)*(x537.value));
IkReal x536=x531;
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x535)));
IkReal gconst69=((3.14159265358979)+(((-1.0)*x535)));
IkReal gconst70=((1.0)*new_r01*x536);
IkReal gconst71=((-1.0)*new_r11*x536);
IkReal x538=new_r01*new_r01;
IkReal x539=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x540=x531;
IkReal x541=((1.0)*new_r01*x540);
j2eval[0]=x539;
j2eval[1]=IKsign(x539);
j2eval[2]=((IKabs(((((-1.0)*new_r00*x541))+(((-1.0)*new_r11*x541)))))+(IKabs(((((-1.0)*new_r10*x541))+((x538*x540))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x544 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x544.valid){
continue;
}
IkReal x542=((1.0)*(x544.value));
IkReal x543=x531;
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x542)));
IkReal gconst69=((3.14159265358979)+(((-1.0)*x542)));
IkReal gconst70=((1.0)*new_r01*x543);
IkReal gconst71=((-1.0)*new_r11*x543);
IkReal x545=((new_r01*new_r01)+(new_r11*new_r11));
j2eval[0]=x545;
j2eval[1]=IKsign(x545);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x548 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x548.valid){
continue;
}
IkReal x546=((1.0)*(x548.value));
IkReal x547=x531;
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x546)));
IkReal gconst69=((3.14159265358979)+(((-1.0)*x546)));
IkReal gconst70=((1.0)*new_r01*x547);
IkReal gconst71=((-1.0)*new_r11*x547);
IkReal x549=new_r01*new_r01;
IkReal x550=new_r11*new_r11;
IkReal x551=((1.0)*x549);
CheckValue<IkReal> x557=IKPowWithIntegerCheck((x550+x549),-1);
if(!x557.valid){
continue;
}
IkReal x552=x557.value;
CheckValue<IkReal> x558=IKPowWithIntegerCheck(((((-1.0)*x550))+(((-1.0)*x551))),-1);
if(!x558.valid){
continue;
}
IkReal x553=x558.value;
IkReal x554=((1.0)*x553);
IkReal x555=(new_r11*x554);
IkReal x556=(new_r01*x554);
j2eval[0]=((IKabs(((((-1.0)*x551*x552))+((x549*x550*x552))+((x552*(x550*x550))))))+(IKabs(((((-1.0)*new_r01*x555*(new_r11*new_r11)))+(((-1.0)*new_r01*x555))+(((-1.0)*x555*(new_r01*new_r01*new_r01)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x560 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x560.valid){
continue;
}
IkReal x559=((1.0)*(x560.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x559)));
new_r11=0;
new_r00=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x559)));
IkReal x561 = new_r01*new_r01;
if(IKabs(x561)==0){
continue;
}
IkReal gconst70=((1.0)*new_r01*(pow(x561,-0.5)));
IkReal gconst71=0;
j2eval[0]=new_r10;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x563 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x563.valid){
continue;
}
IkReal x562=((1.0)*(x563.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x562)));
new_r11=0;
new_r00=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x562)));
IkReal x564 = new_r01*new_r01;
if(IKabs(x564)==0){
continue;
}
IkReal gconst70=((1.0)*new_r01*(pow(x564,-0.5)));
IkReal gconst71=0;
j2eval[0]=new_r01;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x565=IKPowWithIntegerCheck(gconst70,-1);
if(!x565.valid){
continue;
}
cj2array[0]=((-1.0)*new_r01*(x565.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x566=IKsin(j2);
IkReal x567=IKcos(j2);
evalcond[0]=(gconst70*x566);
evalcond[1]=(new_r10*x566);
evalcond[2]=((-1.0)*new_r01*x566);
evalcond[3]=(gconst70+((new_r10*x567)));
evalcond[4]=(gconst70+((new_r01*x567)));
evalcond[5]=(((gconst70*x567))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x568=IKPowWithIntegerCheck(new_r01,-1);
if(!x568.valid){
continue;
}
cj2array[0]=((-1.0)*gconst70*(x568.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x569=IKsin(j2);
IkReal x570=IKcos(j2);
IkReal x571=(gconst70*x570);
evalcond[0]=(gconst70*x569);
evalcond[1]=(new_r10*x569);
evalcond[2]=((-1.0)*new_r01*x569);
evalcond[3]=(((new_r10*x570))+gconst70);
evalcond[4]=(x571+new_r01);
evalcond[5]=(x571+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x572=IKPowWithIntegerCheck(new_r10,-1);
if(!x572.valid){
continue;
}
cj2array[0]=((-1.0)*gconst70*(x572.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x573=IKsin(j2);
IkReal x574=IKcos(j2);
IkReal x575=(gconst70*x574);
evalcond[0]=(gconst70*x573);
evalcond[1]=(new_r10*x573);
evalcond[2]=((-1.0)*new_r01*x573);
evalcond[3]=(((new_r01*x574))+gconst70);
evalcond[4]=(x575+new_r01);
evalcond[5]=(x575+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst70;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[4];
CheckValue<IkReal> x577 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x577.valid){
continue;
}
IkReal x576=((1.0)*(x577.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x576)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x576)));
IkReal gconst70=((1.0)*new_r01);
IkReal gconst71=((-1.0)*new_r11);
j2eval[0]=1.0;
j2eval[1]=new_r01;
j2eval[2]=1.0;
j2eval[3]=1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  || IKabs(j2eval[3]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x579 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x579.valid){
continue;
}
IkReal x578=((1.0)*(x579.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x578)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x578)));
IkReal gconst70=((1.0)*new_r01);
IkReal gconst71=((-1.0)*new_r11);
j2eval[0]=-1.0;
j2eval[1]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
j2eval[2]=-1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x581 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x581.valid){
continue;
}
IkReal x580=((1.0)*(x581.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x580)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x580)));
IkReal gconst70=((1.0)*new_r01);
IkReal gconst71=((-1.0)*new_r11);
j2eval[0]=1.0;
j2eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j2eval[2]=1.0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x582=((1.0)*gconst70);
CheckValue<IkReal> x583=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x583.valid){
continue;
}
CheckValue<IkReal> x584 = IKatan2WithCheck(IkReal((((gconst71*new_r01))+(((-1.0)*new_r11*x582)))),IkReal(((((-1.0)*new_r01*x582))+(((-1.0)*gconst71*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x584.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x583.value)))+(x584.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x585=IKcos(j2);
IkReal x586=IKsin(j2);
IkReal x587=(gconst70*x585);
IkReal x588=((1.0)*x586);
IkReal x589=(gconst71*x585);
IkReal x590=(gconst71*x588);
evalcond[0]=(gconst70+((new_r01*x585))+((new_r11*x586)));
evalcond[1]=(((gconst70*x586))+x589+new_r11);
evalcond[2]=((((-1.0)*x590))+x587);
evalcond[3]=((((-1.0)*new_r01*x588))+gconst71+((new_r11*x585)));
evalcond[4]=((((-1.0)*x590))+x587+new_r01);
evalcond[5]=((((-1.0)*x589))+(((-1.0)*gconst70*x588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x591 = IKatan2WithCheck(IkReal((gconst70*new_r11)),IkReal((gconst71*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x591.valid){
continue;
}
CheckValue<IkReal> x592=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst71*gconst71)))+(((-1.0)*(gconst70*gconst70))))),-1);
if(!x592.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x591.value)+(((1.5707963267949)*(x592.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x593=IKcos(j2);
IkReal x594=IKsin(j2);
IkReal x595=(gconst70*x593);
IkReal x596=((1.0)*x594);
IkReal x597=(gconst71*x593);
IkReal x598=(gconst71*x596);
evalcond[0]=(((new_r11*x594))+gconst70+((new_r01*x593)));
evalcond[1]=(x597+new_r11+((gconst70*x594)));
evalcond[2]=((((-1.0)*x598))+x595);
evalcond[3]=(((new_r11*x593))+(((-1.0)*new_r01*x596))+gconst71);
evalcond[4]=((((-1.0)*x598))+x595+new_r01);
evalcond[5]=((((-1.0)*x597))+(((-1.0)*gconst70*x596)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x599 = IKatan2WithCheck(IkReal((gconst70*gconst71)),IkReal(((-1.0)*(gconst70*gconst70))),IKFAST_ATAN2_MAGTHRESH);
if(!x599.valid){
continue;
}
CheckValue<IkReal> x600=IKPowWithIntegerCheck(IKsign((((gconst70*new_r01))+(((-1.0)*gconst71*new_r11)))),-1);
if(!x600.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x599.value)+(((1.5707963267949)*(x600.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x601=IKcos(j2);
IkReal x602=IKsin(j2);
IkReal x603=(gconst70*x601);
IkReal x604=((1.0)*x602);
IkReal x605=(gconst71*x601);
IkReal x606=(gconst71*x604);
evalcond[0]=(gconst70+((new_r11*x602))+((new_r01*x601)));
evalcond[1]=(((gconst70*x602))+x605+new_r11);
evalcond[2]=(x603+(((-1.0)*x606)));
evalcond[3]=(gconst71+((new_r11*x601))+(((-1.0)*new_r01*x604)));
evalcond[4]=(x603+(((-1.0)*x606))+new_r01);
evalcond[5]=((((-1.0)*x605))+(((-1.0)*gconst70*x604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x607=IKPowWithIntegerCheck(gconst71,-1);
if(!x607.valid){
continue;
}
cj2array[0]=(new_r00*(x607.value));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x608=IKsin(j2);
IkReal x609=IKcos(j2);
IkReal x610=((-1.0)*x608);
evalcond[0]=(new_r11*x608);
evalcond[1]=(new_r00*x610);
evalcond[2]=(gconst71*x610);
evalcond[3]=(gconst71+((new_r11*x609)));
evalcond[4]=(((gconst71*x609))+new_r11);
evalcond[5]=((((-1.0)*gconst71))+((new_r00*x609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
IkReal x611=((1.0)*(x612.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x611)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x611)));
IkReal gconst70=0;
IkReal x613 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x613)==0){
continue;
}
IkReal gconst71=((-1.0)*new_r11*(pow(x613,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x615 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x615.valid){
continue;
}
IkReal x614=((1.0)*(x615.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x614)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x614)));
IkReal gconst70=0;
IkReal x616 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x616)==0){
continue;
}
IkReal gconst71=((-1.0)*new_r11*(pow(x616,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x618 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x618.valid){
continue;
}
IkReal x617=((1.0)*(x618.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x617)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x617)));
IkReal gconst70=0;
IkReal x619 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x619)==0){
continue;
}
IkReal gconst71=((-1.0)*new_r11*(pow(x619,-0.5)));
j2eval[0]=new_r10;
j2eval[1]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x620=IKPowWithIntegerCheck(new_r10,-1);
if(!x620.valid){
continue;
}
CheckValue<IkReal> x621=IKPowWithIntegerCheck(new_r11,-1);
if(!x621.valid){
continue;
}
if( IKabs((gconst71*(x620.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst71*(x621.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst71*(x620.value)))+IKsqr(((-1.0)*gconst71*(x621.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((gconst71*(x620.value)), ((-1.0)*gconst71*(x621.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x622=IKsin(j2);
IkReal x623=IKcos(j2);
IkReal x624=((1.0)*gconst71);
IkReal x625=((-1.0)*gconst71);
evalcond[0]=(new_r10*x623);
evalcond[1]=(new_r11*x622);
evalcond[2]=(x622*x625);
evalcond[3]=(x623*x625);
evalcond[4]=(gconst71+((new_r11*x623)));
evalcond[5]=(((gconst71*x623))+new_r11);
evalcond[6]=((((-1.0)*x622*x624))+new_r10);
evalcond[7]=((((-1.0)*x624))+((new_r10*x622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x626=IKPowWithIntegerCheck(gconst71,-1);
if(!x626.valid){
continue;
}
CheckValue<IkReal> x627=IKPowWithIntegerCheck(new_r11,-1);
if(!x627.valid){
continue;
}
if( IKabs((new_r10*(x626.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst71*(x627.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x626.value)))+IKsqr(((-1.0)*gconst71*(x627.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x626.value)), ((-1.0)*gconst71*(x627.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x628=IKsin(j2);
IkReal x629=IKcos(j2);
IkReal x630=((1.0)*gconst71);
IkReal x631=((-1.0)*gconst71);
evalcond[0]=(new_r10*x629);
evalcond[1]=(new_r11*x628);
evalcond[2]=(x628*x631);
evalcond[3]=(x629*x631);
evalcond[4]=(gconst71+((new_r11*x629)));
evalcond[5]=(((gconst71*x629))+new_r11);
evalcond[6]=((((-1.0)*x628*x630))+new_r10);
evalcond[7]=((((-1.0)*x630))+((new_r10*x628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x632 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x632.valid){
continue;
}
CheckValue<IkReal> x633=IKPowWithIntegerCheck(IKsign(gconst71),-1);
if(!x633.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x632.value)+(((1.5707963267949)*(x633.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x634=IKsin(j2);
IkReal x635=IKcos(j2);
IkReal x636=((1.0)*gconst71);
IkReal x637=((-1.0)*gconst71);
evalcond[0]=(new_r10*x635);
evalcond[1]=(new_r11*x634);
evalcond[2]=(x634*x637);
evalcond[3]=(x635*x637);
evalcond[4]=(gconst71+((new_r11*x635)));
evalcond[5]=(((gconst71*x635))+new_r11);
evalcond[6]=((((-1.0)*x634*x636))+new_r10);
evalcond[7]=((((-1.0)*x636))+((new_r10*x634)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
IkReal x638=((1.0)*(x639.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x638)));
new_r01=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x638)));
IkReal gconst70=0;
IkReal x640 = new_r11*new_r11;
if(IKabs(x640)==0){
continue;
}
IkReal gconst71=((-1.0)*new_r11*(pow(x640,-0.5)));
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
IkReal x641=((1.0)*(x642.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x641)));
new_r01=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x641)));
IkReal gconst70=0;
IkReal x643 = new_r11*new_r11;
if(IKabs(x643)==0){
continue;
}
IkReal gconst71=((-1.0)*new_r11*(pow(x643,-0.5)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
CheckValue<IkReal> x645 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x645.valid){
continue;
}
IkReal x644=((1.0)*(x645.value));
sj3=0;
cj3=1.0;
j3=0;
sj4=gconst70;
cj4=gconst71;
j4=((3.14159265)+(((-1.0)*x644)));
new_r01=0;
IkReal gconst69=((3.14159265358979)+(((-1.0)*x644)));
IkReal gconst70=0;
IkReal x646 = new_r11*new_r11;
if(IKabs(x646)==0){
continue;
}
IkReal gconst71=((-1.0)*new_r11*(pow(x646,-0.5)));
j2eval[0]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x647=IKPowWithIntegerCheck(gconst71,-1);
if(!x647.valid){
continue;
}
CheckValue<IkReal> x648=IKPowWithIntegerCheck(new_r11,-1);
if(!x648.valid){
continue;
}
if( IKabs((new_r10*(x647.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst71*(x648.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x647.value)))+IKsqr(((-1.0)*gconst71*(x648.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((new_r10*(x647.value)), ((-1.0)*gconst71*(x648.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x649=IKsin(j2);
IkReal x650=IKcos(j2);
IkReal x651=((1.0)*gconst71);
IkReal x652=((1.0)*x649);
evalcond[0]=(new_r11*x649);
evalcond[1]=((-1.0)*gconst71*x649);
evalcond[2]=(gconst71+((new_r11*x650)));
evalcond[3]=(((gconst71*x650))+new_r11);
evalcond[4]=((((-1.0)*x649*x651))+new_r10);
evalcond[5]=((((-1.0)*x650*x651))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x652))+((new_r10*x650)));
evalcond[7]=((((-1.0)*x651))+((new_r10*x649))+((new_r00*x650)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x653 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x653.valid){
continue;
}
CheckValue<IkReal> x654=IKPowWithIntegerCheck(IKsign(gconst71),-1);
if(!x654.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x653.value)+(((1.5707963267949)*(x654.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x655=IKsin(j2);
IkReal x656=IKcos(j2);
IkReal x657=((1.0)*gconst71);
IkReal x658=((1.0)*x655);
evalcond[0]=(new_r11*x655);
evalcond[1]=((-1.0)*gconst71*x655);
evalcond[2]=(gconst71+((new_r11*x656)));
evalcond[3]=(((gconst71*x656))+new_r11);
evalcond[4]=((((-1.0)*x655*x657))+new_r10);
evalcond[5]=((((-1.0)*x656*x657))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x658))+((new_r10*x656)));
evalcond[7]=((((-1.0)*x657))+((new_r10*x655))+((new_r00*x656)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x659 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x659.valid){
continue;
}
CheckValue<IkReal> x660=IKPowWithIntegerCheck(IKsign(gconst71),-1);
if(!x660.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x659.value)+(((1.5707963267949)*(x660.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x661=IKsin(j2);
IkReal x662=IKcos(j2);
IkReal x663=((1.0)*gconst71);
IkReal x664=((1.0)*x661);
evalcond[0]=(new_r11*x661);
evalcond[1]=((-1.0)*gconst71*x661);
evalcond[2]=(gconst71+((new_r11*x662)));
evalcond[3]=(((gconst71*x662))+new_r11);
evalcond[4]=((((-1.0)*x661*x663))+new_r10);
evalcond[5]=((((-1.0)*x662*x663))+new_r00);
evalcond[6]=(((new_r10*x662))+(((-1.0)*new_r00*x664)));
evalcond[7]=(((new_r10*x661))+(((-1.0)*x663))+((new_r00*x662)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x665=((1.0)*new_r11);
CheckValue<IkReal> x666=IKPowWithIntegerCheck(IKsign((((gconst70*new_r01))+(((-1.0)*gconst71*x665)))),-1);
if(!x666.valid){
continue;
}
CheckValue<IkReal> x667 = IKatan2WithCheck(IkReal((((gconst70*gconst71))+(((-1.0)*new_r01*x665)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst70*gconst70))))),IKFAST_ATAN2_MAGTHRESH);
if(!x667.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x666.value)))+(x667.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x668=IKcos(j2);
IkReal x669=IKsin(j2);
IkReal x670=((1.0)*gconst71);
IkReal x671=(gconst70*x668);
IkReal x672=((1.0)*x669);
IkReal x673=(x669*x670);
evalcond[0]=(gconst70+((new_r11*x669))+((new_r01*x668)));
evalcond[1]=(((gconst70*x669))+((gconst71*x668))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x672))+gconst70+((new_r10*x668)));
evalcond[3]=((((-1.0)*new_r01*x672))+gconst71+((new_r11*x668)));
evalcond[4]=(x671+new_r01+(((-1.0)*x673)));
evalcond[5]=(x671+new_r10+(((-1.0)*x673)));
evalcond[6]=(((new_r10*x669))+((new_r00*x668))+(((-1.0)*x670)));
evalcond[7]=((((-1.0)*gconst70*x672))+(((-1.0)*x668*x670))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x674=((1.0)*gconst70);
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((((gconst71*new_r01))+(((-1.0)*new_r11*x674)))),IkReal(((((-1.0)*new_r01*x674))+(((-1.0)*gconst71*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x676.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x675.value)+(((1.5707963267949)*(x676.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x677=IKcos(j2);
IkReal x678=IKsin(j2);
IkReal x679=((1.0)*gconst71);
IkReal x680=(gconst70*x677);
IkReal x681=((1.0)*x678);
IkReal x682=(x678*x679);
evalcond[0]=(((new_r11*x678))+((new_r01*x677))+gconst70);
evalcond[1]=(((gconst71*x677))+((gconst70*x678))+new_r11);
evalcond[2]=(((new_r10*x677))+gconst70+(((-1.0)*new_r00*x681)));
evalcond[3]=(((new_r11*x677))+(((-1.0)*new_r01*x681))+gconst71);
evalcond[4]=((((-1.0)*x682))+x680+new_r01);
evalcond[5]=((((-1.0)*x682))+x680+new_r10);
evalcond[6]=(((new_r00*x677))+((new_r10*x678))+(((-1.0)*x679)));
evalcond[7]=(new_r00+(((-1.0)*x677*x679))+(((-1.0)*gconst70*x681)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x683=((1.0)*gconst70);
CheckValue<IkReal> x684 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x683))+((gconst70*new_r01)))),IkReal(((((-1.0)*new_r11*x683))+(((-1.0)*new_r00*x683)))),IKFAST_ATAN2_MAGTHRESH);
if(!x684.valid){
continue;
}
CheckValue<IkReal> x685=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x685.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x684.value)+(((1.5707963267949)*(x685.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x686=IKcos(j2);
IkReal x687=IKsin(j2);
IkReal x688=((1.0)*gconst71);
IkReal x689=(gconst70*x686);
IkReal x690=((1.0)*x687);
IkReal x691=(x687*x688);
evalcond[0]=(gconst70+((new_r01*x686))+((new_r11*x687)));
evalcond[1]=(((gconst71*x686))+((gconst70*x687))+new_r11);
evalcond[2]=(gconst70+(((-1.0)*new_r00*x690))+((new_r10*x686)));
evalcond[3]=((((-1.0)*new_r01*x690))+gconst71+((new_r11*x686)));
evalcond[4]=(x689+(((-1.0)*x691))+new_r01);
evalcond[5]=(x689+(((-1.0)*x691))+new_r10);
evalcond[6]=((((-1.0)*x688))+((new_r00*x686))+((new_r10*x687)));
evalcond[7]=((((-1.0)*gconst70*x690))+(((-1.0)*x686*x688))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=1.0;
j3=0;
new_r01=0;
new_r11=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x693 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x693.valid){
continue;
}
IkReal x692=x693.value;
j2array[0]=((-1.0)*x692);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x692)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j2))))+((new_r10*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x694=IKcos(j2);
IkReal x695=IKsin(j2);
IkReal x696=((1.0)*x695);
evalcond[0]=(x694+new_r11);
evalcond[1]=((((-1.0)*x696))+new_r01);
evalcond[2]=((((-1.0)*x696))+new_r10);
evalcond[3]=(new_r00+(((-1.0)*x694)));
evalcond[4]=(((new_r11*x695))+((new_r01*x694)));
evalcond[5]=(((new_r10*x694))+(((-1.0)*new_r00*x696)));
evalcond[6]=((-1.0)+((new_r10*x695))+((new_r00*x694)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x696))+((new_r11*x694)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x697=IKsin(j2);
IkReal x698=IKcos(j2);
IkReal x699=((1.0)*x697);
evalcond[0]=(x697+new_r01);
evalcond[1]=(x697+new_r10);
evalcond[2]=(x698+new_r00);
evalcond[3]=(new_r11+(((-1.0)*x698)));
evalcond[4]=(((new_r11*x697))+((new_r01*x698)));
evalcond[5]=(((new_r10*x698))+(((-1.0)*new_r00*x699)));
evalcond[6]=((1.0)+((new_r10*x697))+((new_r00*x698)));
evalcond[7]=((-1.0)+(((-1.0)*new_r01*x699))+((new_r11*x698)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
new_r11=0;
new_r00=0;
j2eval[0]=new_r01;
j2eval[1]=((IKabs(cj4))+(IKabs(sj4)));
j2eval[2]=IKsign(new_r01);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
new_r11=0;
new_r00=0;
j2eval[0]=new_r10;
j2eval[1]=((IKabs(cj4))+(IKabs(sj4)));
j2eval[2]=IKsign(new_r10);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj3=0;
cj3=1.0;
j3=0;
new_r11=0;
new_r00=0;
j2eval[0]=new_r01;
j2eval[1]=new_r10;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x700=IKPowWithIntegerCheck(new_r01,-1);
if(!x700.valid){
continue;
}
CheckValue<IkReal> x701=IKPowWithIntegerCheck(new_r10,-1);
if(!x701.valid){
continue;
}
if( IKabs((cj4*(x700.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj4*(x701.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj4*(x700.value)))+IKsqr(((-1.0)*sj4*(x701.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((cj4*(x700.value)), ((-1.0)*sj4*(x701.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x702=IKcos(j2);
IkReal x703=IKsin(j2);
IkReal x704=((1.0)*cj4);
IkReal x705=(sj4*x702);
IkReal x706=(x703*x704);
evalcond[0]=(sj4+((new_r10*x702)));
evalcond[1]=(sj4+((new_r01*x702)));
evalcond[2]=(cj4+(((-1.0)*new_r01*x703)));
evalcond[3]=((((-1.0)*x704))+((new_r10*x703)));
evalcond[4]=(((cj4*x702))+((sj4*x703)));
evalcond[5]=((((-1.0)*x706))+x705+new_r01);
evalcond[6]=((((-1.0)*x706))+x705+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x707=IKPowWithIntegerCheck(IKsign(new_r10),-1);
if(!x707.valid){
continue;
}
CheckValue<IkReal> x708 = IKatan2WithCheck(IkReal(cj4),IkReal(((-1.0)*sj4)),IKFAST_ATAN2_MAGTHRESH);
if(!x708.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x707.value)))+(x708.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x709=IKcos(j2);
IkReal x710=IKsin(j2);
IkReal x711=((1.0)*cj4);
IkReal x712=(sj4*x709);
IkReal x713=(x710*x711);
evalcond[0]=(sj4+((new_r10*x709)));
evalcond[1]=(sj4+((new_r01*x709)));
evalcond[2]=(cj4+(((-1.0)*new_r01*x710)));
evalcond[3]=((((-1.0)*x711))+((new_r10*x710)));
evalcond[4]=(((sj4*x710))+((cj4*x709)));
evalcond[5]=((((-1.0)*x713))+x712+new_r01);
evalcond[6]=((((-1.0)*x713))+x712+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x714=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x714.valid){
continue;
}
CheckValue<IkReal> x715 = IKatan2WithCheck(IkReal(cj4),IkReal(((-1.0)*sj4)),IKFAST_ATAN2_MAGTHRESH);
if(!x715.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x714.value)))+(x715.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x716=IKcos(j2);
IkReal x717=IKsin(j2);
IkReal x718=((1.0)*cj4);
IkReal x719=(sj4*x716);
IkReal x720=(x717*x718);
evalcond[0]=(sj4+((new_r10*x716)));
evalcond[1]=(sj4+((new_r01*x716)));
evalcond[2]=(cj4+(((-1.0)*new_r01*x717)));
evalcond[3]=((((-1.0)*x718))+((new_r10*x717)));
evalcond[4]=(((sj4*x717))+((cj4*x716)));
evalcond[5]=((((-1.0)*x720))+x719+new_r01);
evalcond[6]=((((-1.0)*x720))+x719+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=1.0;
j3=0;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x722 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x722.valid){
continue;
}
IkReal x721=x722.value;
j2array[0]=((-1.0)*x721);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x721)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j2))))+((new_r10*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=1.0;
j3=0;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x724 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x724.valid){
continue;
}
IkReal x723=x724.value;
j2array[0]=((-1.0)*x723);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x723)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r01*(IKsin(j2))))+((new_r11*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=1.0;
j3=0;
new_r01=0;
new_r10=0;
j2eval[0]=new_r11;
j2eval[1]=IKsign(new_r11);
j2eval[2]=((IKabs(cj4))+(IKabs(sj4)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj3=0;
cj3=1.0;
j3=0;
new_r01=0;
new_r10=0;
j2eval[0]=new_r00;
j2eval[1]=new_r11;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj3=0;
cj3=1.0;
j3=0;
new_r01=0;
new_r10=0;
j2eval[0]=new_r11;
j2eval[1]=sj4;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
cj2array[0]=new_r00;
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x725=IKsin(j2);
IkReal x726=IKcos(j2);
IkReal x727=((-1.0)*x725);
evalcond[0]=(new_r11*x725);
evalcond[1]=(x726+new_r11);
evalcond[2]=x727;
evalcond[3]=(new_r00*x727);
evalcond[4]=((1.0)+((new_r11*x726)));
evalcond[5]=((-1.0)+((new_r00*x726)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
cj2array[0]=new_r11;
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x728=IKsin(j2);
IkReal x729=IKcos(j2);
evalcond[0]=x728;
evalcond[1]=(new_r11*x728);
evalcond[2]=(x729+new_r00);
evalcond[3]=((-1.0)*new_r00*x728);
evalcond[4]=((-1.0)+((new_r11*x729)));
evalcond[5]=((1.0)+((new_r00*x729)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x731=IKPowWithIntegerCheck(new_r11,-1);
if(!x731.valid){
continue;
}
IkReal x730=x731.value;
CheckValue<IkReal> x732=IKPowWithIntegerCheck(sj4,-1);
if(!x732.valid){
continue;
}
CheckValue<IkReal> x733=IKPowWithIntegerCheck(x730,-2);
if(!x733.valid){
continue;
}
if( IKabs((x730*(x732.value)*(((cj4*cj4)+(((-1.0)*(x733.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj4*x730)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x730*(x732.value)*(((cj4*cj4)+(((-1.0)*(x733.value)))))))+IKsqr(((-1.0)*cj4*x730))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x730*(x732.value)*(((cj4*cj4)+(((-1.0)*(x733.value)))))), ((-1.0)*cj4*x730));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x734=IKsin(j2);
IkReal x735=IKcos(j2);
IkReal x736=((1.0)*cj4);
IkReal x737=((1.0)*x734);
evalcond[0]=(cj4+((new_r11*x735)));
evalcond[1]=(sj4+((new_r11*x734)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x737)));
evalcond[3]=(((new_r00*x735))+(((-1.0)*x736)));
evalcond[4]=(((cj4*x735))+((sj4*x734))+new_r11);
evalcond[5]=((((-1.0)*x734*x736))+((sj4*x735)));
evalcond[6]=((((-1.0)*x735*x736))+new_r00+(((-1.0)*sj4*x737)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x738=IKPowWithIntegerCheck(new_r00,-1);
if(!x738.valid){
continue;
}
CheckValue<IkReal> x739=IKPowWithIntegerCheck(new_r11,-1);
if(!x739.valid){
continue;
}
if( IKabs((sj4*(x738.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj4*(x739.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj4*(x738.value)))+IKsqr(((-1.0)*cj4*(x739.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((sj4*(x738.value)), ((-1.0)*cj4*(x739.value)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x740=IKsin(j2);
IkReal x741=IKcos(j2);
IkReal x742=((1.0)*cj4);
IkReal x743=((1.0)*x740);
evalcond[0]=(cj4+((new_r11*x741)));
evalcond[1]=(sj4+((new_r11*x740)));
evalcond[2]=((((-1.0)*new_r00*x743))+sj4);
evalcond[3]=(((new_r00*x741))+(((-1.0)*x742)));
evalcond[4]=(((sj4*x740))+new_r11+((cj4*x741)));
evalcond[5]=(((sj4*x741))+(((-1.0)*x740*x742)));
evalcond[6]=((((-1.0)*sj4*x743))+(((-1.0)*x741*x742))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x744=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x744.valid){
continue;
}
CheckValue<IkReal> x745 = IKatan2WithCheck(IkReal(((-1.0)*sj4)),IkReal(((-1.0)*cj4)),IKFAST_ATAN2_MAGTHRESH);
if(!x745.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x744.value)))+(x745.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[7];
IkReal x746=IKsin(j2);
IkReal x747=IKcos(j2);
IkReal x748=((1.0)*cj4);
IkReal x749=((1.0)*x746);
evalcond[0]=(cj4+((new_r11*x747)));
evalcond[1]=(sj4+((new_r11*x746)));
evalcond[2]=((((-1.0)*new_r00*x749))+sj4);
evalcond[3]=(((new_r00*x747))+(((-1.0)*x748)));
evalcond[4]=(((sj4*x746))+new_r11+((cj4*x747)));
evalcond[5]=(((sj4*x747))+(((-1.0)*x746*x748)));
evalcond[6]=((((-1.0)*sj4*x749))+(((-1.0)*x747*x748))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x750=IKPowWithIntegerCheck(IKsign((((cj4*new_r01))+((new_r11*sj4)))),-1);
if(!x750.valid){
continue;
}
CheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(((-1.0)+(new_r01*new_r01)+(cj4*cj4))),IkReal(((((-1.0)*cj4*sj4))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x751.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x750.value)))+(x751.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x752=IKsin(j2);
IkReal x753=IKcos(j2);
IkReal x754=((1.0)*cj4);
IkReal x755=(sj4*x753);
IkReal x756=((1.0)*x752);
IkReal x757=(x752*x754);
evalcond[0]=(sj4+((new_r11*x752))+((new_r01*x753)));
evalcond[1]=(((sj4*x752))+new_r11+((cj4*x753)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x756))+((new_r10*x753)));
evalcond[3]=((((-1.0)*new_r01*x756))+cj4+((new_r11*x753)));
evalcond[4]=(x755+new_r01+(((-1.0)*x757)));
evalcond[5]=(x755+new_r10+(((-1.0)*x757)));
evalcond[6]=(((new_r00*x753))+((new_r10*x752))+(((-1.0)*x754)));
evalcond[7]=((((-1.0)*sj4*x756))+(((-1.0)*x753*x754))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x758=((1.0)*new_r11);
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal((((cj4*new_r01))+(((-1.0)*sj4*x758)))),IkReal(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x758)))),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
CheckValue<IkReal> x760=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x760.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x759.value)+(((1.5707963267949)*(x760.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x761=IKsin(j2);
IkReal x762=IKcos(j2);
IkReal x763=((1.0)*cj4);
IkReal x764=(sj4*x762);
IkReal x765=((1.0)*x761);
IkReal x766=(x761*x763);
evalcond[0]=(sj4+((new_r11*x761))+((new_r01*x762)));
evalcond[1]=(((sj4*x761))+((cj4*x762))+new_r11);
evalcond[2]=(((new_r10*x762))+sj4+(((-1.0)*new_r00*x765)));
evalcond[3]=(((new_r11*x762))+cj4+(((-1.0)*new_r01*x765)));
evalcond[4]=((((-1.0)*x766))+x764+new_r01);
evalcond[5]=((((-1.0)*x766))+x764+new_r10);
evalcond[6]=(((new_r10*x761))+(((-1.0)*x763))+((new_r00*x762)));
evalcond[7]=((((-1.0)*x762*x763))+new_r00+(((-1.0)*sj4*x765)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x767=((1.0)*sj4);
CheckValue<IkReal> x768 = IKatan2WithCheck(IkReal((((new_r01*sj4))+(((-1.0)*new_r10*x767)))),IkReal(((((-1.0)*new_r00*x767))+(((-1.0)*new_r11*x767)))),IKFAST_ATAN2_MAGTHRESH);
if(!x768.valid){
continue;
}
CheckValue<IkReal> x769=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x769.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x768.value)+(((1.5707963267949)*(x769.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x770=IKsin(j2);
IkReal x771=IKcos(j2);
IkReal x772=((1.0)*cj4);
IkReal x773=(sj4*x771);
IkReal x774=((1.0)*x770);
IkReal x775=(x770*x772);
evalcond[0]=(sj4+((new_r11*x770))+((new_r01*x771)));
evalcond[1]=(((sj4*x770))+new_r11+((cj4*x771)));
evalcond[2]=(sj4+(((-1.0)*new_r00*x774))+((new_r10*x771)));
evalcond[3]=(cj4+(((-1.0)*new_r01*x774))+((new_r11*x771)));
evalcond[4]=(x773+(((-1.0)*x775))+new_r01);
evalcond[5]=(x773+(((-1.0)*x775))+new_r10);
evalcond[6]=(((new_r00*x771))+((new_r10*x770))+(((-1.0)*x772)));
evalcond[7]=((((-1.0)*sj4*x774))+(((-1.0)*x771*x772))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x776=((1.0)*new_r10);
IkReal x777=((new_r10*new_r10)+(new_r00*new_r00));
j2eval[0]=x777;
j2eval[1]=IKsign(x777);
j2eval[2]=((IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x776)))))+(IKabs(((((-1.0)*cj4*x776))+((new_r00*sj4))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x778=((1.0)*cj4);
IkReal x779=(((new_r10*new_r11))+((new_r00*new_r01)));
j2eval[0]=x779;
j2eval[1]=((IKabs(((((-1.0)*new_r01*x778))+(((-1.0)*new_r10*x778)))))+(IKabs((((cj4*new_r00))+(((-1.0)*new_r11*x778))))));
j2eval[2]=IKsign(x779);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x780=((1.0)*new_r10);
IkReal x781=(((cj4*new_r00))+(((-1.0)*sj4*x780)));
j2eval[0]=x781;
j2eval[1]=IKsign(x781);
j2eval[2]=((IKabs(((((-1.0)*(cj4*cj4)))+(new_r10*new_r10))))+(IKabs((((cj4*sj4))+(((-1.0)*new_r00*x780))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x784 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x784)==0){
continue;
}
IkReal x782=pow(x784,-0.5);
IkReal x783=((-1.0)*x782);
CheckValue<IkReal> x785 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x785.valid){
continue;
}
IkReal gconst72=((-1.0)*(x785.value));
IkReal gconst73=(new_r00*x783);
IkReal gconst74=(new_r10*x783);
CheckValue<IkReal> x786 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x786.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x786.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
CheckValue<IkReal> x790 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x790.valid){
continue;
}
IkReal x787=((-1.0)*(x790.value));
IkReal x788=x782;
IkReal x789=((-1.0)*x788);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x787;
IkReal gconst72=x787;
IkReal gconst73=(new_r00*x789);
IkReal gconst74=(new_r10*x789);
IkReal x791=((new_r10*new_r10)+(new_r00*new_r00));
j2eval[0]=x791;
j2eval[1]=IKsign(x791);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x795 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x795.valid){
continue;
}
IkReal x792=((-1.0)*(x795.value));
IkReal x793=x782;
IkReal x794=((-1.0)*x793);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x792;
IkReal gconst72=x792;
IkReal gconst73=(new_r00*x794);
IkReal gconst74=(new_r10*x794);
IkReal x796=new_r10*new_r10;
IkReal x797=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x798=x782;
IkReal x799=(new_r10*x798);
j2eval[0]=x797;
j2eval[1]=((IKabs((((new_r11*x799))+(((-1.0)*new_r00*x799)))))+(IKabs((((x796*x798))+((new_r01*x799))))));
j2eval[2]=IKsign(x797);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
CheckValue<IkReal> x803 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x803.valid){
continue;
}
IkReal x800=((-1.0)*(x803.value));
IkReal x801=x782;
IkReal x802=((-1.0)*x801);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst73;
cj4=gconst74;
j4=x800;
IkReal gconst72=x800;
IkReal gconst73=(new_r00*x802);
IkReal gconst74=(new_r10*x802);
IkReal x804=new_r10*new_r10;
IkReal x805=new_r11*new_r11;
IkReal x806=new_r00*new_r00;
j2eval[0]=(x804+x806);
j2eval[1]=((((2.0)*x804*x805*x806))+((x805*(x804*x804)))+x804+((x805*(x806*x806))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x807=IKPowWithIntegerCheck(IKsign((((gconst74*new_r10))+((gconst73*new_r00)))),-1);
if(!x807.valid){
continue;
}
CheckValue<IkReal> x808 = IKatan2WithCheck(IkReal((((new_r00*new_r11))+(((-1.0)*(gconst74*gconst74))))),IkReal(((((-1.0)*gconst73*gconst74))+(((-1.0)*new_r10*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x808.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x807.value)))+(x808.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x809=IKsin(j2);
IkReal x810=IKcos(j2);
IkReal x811=((1.0)*gconst73);
IkReal x812=(gconst74*x810);
IkReal x813=((1.0)*x809);
IkReal x814=(x809*x811);
evalcond[0]=(((new_r00*x810))+gconst74+((new_r10*x809)));
evalcond[1]=(((gconst73*x810))+((gconst74*x809))+new_r10);
evalcond[2]=(((new_r10*x810))+gconst73+(((-1.0)*new_r00*x813)));
evalcond[3]=(((new_r11*x810))+gconst74+(((-1.0)*new_r01*x813)));
evalcond[4]=((((-1.0)*x814))+new_r11+x812);
evalcond[5]=((((-1.0)*x814))+new_r00+x812);
evalcond[6]=(((new_r01*x810))+(((-1.0)*x811))+((new_r11*x809)));
evalcond[7]=((((-1.0)*gconst74*x813))+(((-1.0)*x810*x811))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x815=((1.0)*gconst74);
CheckValue<IkReal> x816 = IKatan2WithCheck(IkReal((((gconst74*new_r00))+(((-1.0)*new_r11*x815)))),IkReal(((((-1.0)*new_r10*x815))+(((-1.0)*new_r01*x815)))),IKFAST_ATAN2_MAGTHRESH);
if(!x816.valid){
continue;
}
CheckValue<IkReal> x817=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x817.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x816.value)+(((1.5707963267949)*(x817.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x818=IKsin(j2);
IkReal x819=IKcos(j2);
IkReal x820=((1.0)*gconst73);
IkReal x821=(gconst74*x819);
IkReal x822=((1.0)*x818);
IkReal x823=(x818*x820);
evalcond[0]=(((new_r00*x819))+((new_r10*x818))+gconst74);
evalcond[1]=(((gconst73*x819))+((gconst74*x818))+new_r10);
evalcond[2]=(((new_r10*x819))+gconst73+(((-1.0)*new_r00*x822)));
evalcond[3]=(((new_r11*x819))+gconst74+(((-1.0)*new_r01*x822)));
evalcond[4]=((((-1.0)*x823))+new_r11+x821);
evalcond[5]=((((-1.0)*x823))+new_r00+x821);
evalcond[6]=(((new_r11*x818))+((new_r01*x819))+(((-1.0)*x820)));
evalcond[7]=((((-1.0)*x819*x820))+new_r01+(((-1.0)*gconst74*x822)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x824=((1.0)*new_r10);
CheckValue<IkReal> x825=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x825.valid){
continue;
}
CheckValue<IkReal> x826 = IKatan2WithCheck(IkReal((((gconst73*new_r00))+(((-1.0)*gconst74*x824)))),IkReal(((((-1.0)*gconst74*new_r00))+(((-1.0)*gconst73*x824)))),IKFAST_ATAN2_MAGTHRESH);
if(!x826.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x825.value)))+(x826.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x827=IKsin(j2);
IkReal x828=IKcos(j2);
IkReal x829=((1.0)*gconst73);
IkReal x830=(gconst74*x828);
IkReal x831=((1.0)*x827);
IkReal x832=(x827*x829);
evalcond[0]=(((new_r10*x827))+gconst74+((new_r00*x828)));
evalcond[1]=(((gconst74*x827))+new_r10+((gconst73*x828)));
evalcond[2]=(((new_r10*x828))+gconst73+(((-1.0)*new_r00*x831)));
evalcond[3]=(gconst74+((new_r11*x828))+(((-1.0)*new_r01*x831)));
evalcond[4]=((((-1.0)*x832))+new_r11+x830);
evalcond[5]=((((-1.0)*x832))+new_r00+x830);
evalcond[6]=(((new_r01*x828))+(((-1.0)*x829))+((new_r11*x827)));
evalcond[7]=((((-1.0)*x828*x829))+(((-1.0)*gconst74*x831))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x835 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x835)==0){
continue;
}
IkReal x833=pow(x835,-0.5);
IkReal x834=((1.0)*x833);
CheckValue<IkReal> x836 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x836.valid){
continue;
}
IkReal gconst75=((3.14159265358979)+(((-1.0)*(x836.value))));
IkReal gconst76=(new_r00*x834);
IkReal gconst77=(new_r10*x834);
CheckValue<IkReal> x837 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x837.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x837.value)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
CheckValue<IkReal> x841 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x841.valid){
continue;
}
IkReal x838=((1.0)*(x841.value));
IkReal x839=x833;
IkReal x840=((1.0)*x839);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x838)));
IkReal gconst75=((3.14159265358979)+(((-1.0)*x838)));
IkReal gconst76=(new_r00*x840);
IkReal gconst77=(new_r10*x840);
IkReal x842=((new_r10*new_r10)+(new_r00*new_r00));
j2eval[0]=x842;
j2eval[1]=IKsign(x842);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
CheckValue<IkReal> x846 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x846.valid){
continue;
}
IkReal x843=((1.0)*(x846.value));
IkReal x844=x833;
IkReal x845=((1.0)*x844);
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj4=gconst76;
cj4=gconst77;
j4=((3.14159265)+(((-1.0)*x843)));
IkReal gconst75=((3.14159265358979)+(((-1.0)*x843)));
IkReal gconst76=(new_r00*x845);
IkReal gconst77=(new_r10*x845);
IkReal x847=new_r10*new_r10;
IkReal x848=(new_r10*new_r11);
IkReal x849=(((new_r00*new_r01))+x848);
IkReal x850=x833;
IkReal x851=((1.0)*x850);
j2eval[0]=x849;
j2eval[1]=((IKabs(((((-1.0)*new_r01*new_r10*x851))+(((-1.0)*x847*x851)))))+(IKabs(((((-1.0)*x848*x851))+((new_r00*new_r10*x850))))));
j2eval[2]=IKsign(x849);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x852=IKPowWithIntegerCheck(IKsign((((gconst76*new_r00))+((gconst77*new_r10)))),-1);
if(!x852.valid){
continue;
}
CheckValue<IkReal> x853 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst77*gconst77)))+((new_r00*new_r11)))),IkReal(((((-1.0)*gconst76*gconst77))+(((-1.0)*new_r10*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x853.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x852.value)))+(x853.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x854=IKsin(j2);
IkReal x855=IKcos(j2);
IkReal x856=((1.0)*gconst76);
IkReal x857=(gconst77*x855);
IkReal x858=(gconst77*x854);
IkReal x859=((1.0)*x854);
IkReal x860=(x854*x856);
evalcond[0]=(gconst77+((new_r10*x854))+((new_r00*x855)));
evalcond[1]=(((gconst76*x855))+new_r10+x858);
evalcond[2]=(gconst76+(((-1.0)*new_r00*x859))+((new_r10*x855)));
evalcond[3]=((((-1.0)*new_r01*x859))+gconst77+((new_r11*x855)));
evalcond[4]=((((-1.0)*x860))+new_r11+x857);
evalcond[5]=((((-1.0)*x860))+new_r00+x857);
evalcond[6]=((((-1.0)*x856))+((new_r11*x854))+((new_r01*x855)));
evalcond[7]=((((-1.0)*x858))+(((-1.0)*x855*x856))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x861=((1.0)*gconst77);
CheckValue<IkReal> x862 = IKatan2WithCheck(IkReal((((gconst77*new_r00))+(((-1.0)*new_r11*x861)))),IkReal(((((-1.0)*new_r01*x861))+(((-1.0)*new_r10*x861)))),IKFAST_ATAN2_MAGTHRESH);
if(!x862.valid){
continue;
}
CheckValue<IkReal> x863=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x863.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x862.value)+(((1.5707963267949)*(x863.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x864=IKsin(j2);
IkReal x865=IKcos(j2);
IkReal x866=((1.0)*gconst76);
IkReal x867=(gconst77*x865);
IkReal x868=(gconst77*x864);
IkReal x869=((1.0)*x864);
IkReal x870=(x864*x866);
evalcond[0]=(((new_r00*x865))+gconst77+((new_r10*x864)));
evalcond[1]=(((gconst76*x865))+new_r10+x868);
evalcond[2]=((((-1.0)*new_r00*x869))+gconst76+((new_r10*x865)));
evalcond[3]=((((-1.0)*new_r01*x869))+gconst77+((new_r11*x865)));
evalcond[4]=(new_r11+x867+(((-1.0)*x870)));
evalcond[5]=(new_r00+x867+(((-1.0)*x870)));
evalcond[6]=(((new_r01*x865))+(((-1.0)*x866))+((new_r11*x864)));
evalcond[7]=((((-1.0)*x865*x866))+(((-1.0)*x868))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x871=((1.0)*new_r10);
CheckValue<IkReal> x872=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x872.valid){
continue;
}
CheckValue<IkReal> x873 = IKatan2WithCheck(IkReal((((gconst76*new_r00))+(((-1.0)*gconst77*x871)))),IkReal(((((-1.0)*gconst76*x871))+(((-1.0)*gconst77*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x873.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x872.value)))+(x873.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x874=IKsin(j2);
IkReal x875=IKcos(j2);
IkReal x876=((1.0)*gconst76);
IkReal x877=(gconst77*x875);
IkReal x878=(gconst77*x874);
IkReal x879=((1.0)*x874);
IkReal x880=(x874*x876);
evalcond[0]=(((new_r00*x875))+gconst77+((new_r10*x874)));
evalcond[1]=(((gconst76*x875))+new_r10+x878);
evalcond[2]=((((-1.0)*new_r00*x879))+gconst76+((new_r10*x875)));
evalcond[3]=(gconst77+(((-1.0)*new_r01*x879))+((new_r11*x875)));
evalcond[4]=((((-1.0)*x880))+new_r11+x877);
evalcond[5]=((((-1.0)*x880))+new_r00+x877);
evalcond[6]=(((new_r01*x875))+((new_r11*x874))+(((-1.0)*x876)));
evalcond[7]=((((-1.0)*x878))+(((-1.0)*x875*x876))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x881=IKcos(j2);
IkReal x882=IKsin(j2);
IkReal x883=((1.0)*x882);
evalcond[0]=(new_r10+x881);
evalcond[1]=((((-1.0)*x883))+new_r11);
evalcond[2]=((((-1.0)*x881))+new_r01);
evalcond[3]=((((-1.0)*x883))+new_r00);
evalcond[4]=(((new_r10*x882))+((new_r00*x881)));
evalcond[5]=(((new_r11*x881))+(((-1.0)*new_r01*x883)));
evalcond[6]=((-1.0)+((new_r01*x881))+((new_r11*x882)));
evalcond[7]=((1.0)+((new_r10*x881))+(((-1.0)*new_r00*x883)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r11), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x884=IKsin(j2);
IkReal x885=IKcos(j2);
IkReal x886=((1.0)*x884);
evalcond[0]=(new_r11+x884);
evalcond[1]=(new_r01+x885);
evalcond[2]=(new_r00+x884);
evalcond[3]=((((-1.0)*x885))+new_r10);
evalcond[4]=(((new_r10*x884))+((new_r00*x885)));
evalcond[5]=(((new_r11*x885))+(((-1.0)*new_r01*x886)));
evalcond[6]=((1.0)+((new_r01*x885))+((new_r11*x884)));
evalcond[7]=((-1.0)+((new_r10*x885))+(((-1.0)*new_r00*x886)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r10*new_r10)+(new_r00*new_r00));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r10=0;
new_r00=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x888 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x888.valid){
continue;
}
IkReal x887=x888.value;
j2array[0]=((-1.0)*x887);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x887)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r01*(IKsin(j2))))+((new_r11*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x890 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x890.valid){
continue;
}
IkReal x889=x890.value;
j2array[0]=((-1.0)*x889);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x889)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r01*(IKsin(j2))))+((new_r11*(IKcos(j2)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x891=((1.0)*new_r10);
CheckValue<IkReal> x892 = IKatan2WithCheck(IkReal((((cj4*sj4))+(((-1.0)*new_r00*x891)))),IkReal(((((-1.0)*(cj4*cj4)))+(new_r10*new_r10))),IKFAST_ATAN2_MAGTHRESH);
if(!x892.valid){
continue;
}
CheckValue<IkReal> x893=IKPowWithIntegerCheck(IKsign((((cj4*new_r00))+(((-1.0)*sj4*x891)))),-1);
if(!x893.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x892.value)+(((1.5707963267949)*(x893.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x894=IKsin(j2);
IkReal x895=IKcos(j2);
IkReal x896=((1.0)*sj4);
IkReal x897=(cj4*x895);
IkReal x898=((1.0)*x894);
IkReal x899=(x894*x896);
evalcond[0]=(cj4+((new_r00*x895))+((new_r10*x894)));
evalcond[1]=(((sj4*x895))+((cj4*x894))+new_r10);
evalcond[2]=(sj4+((new_r10*x895))+(((-1.0)*new_r00*x898)));
evalcond[3]=(((new_r11*x895))+cj4+(((-1.0)*new_r01*x898)));
evalcond[4]=((((-1.0)*x899))+new_r11+x897);
evalcond[5]=((((-1.0)*x899))+new_r00+x897);
evalcond[6]=(((new_r11*x894))+((new_r01*x895))+(((-1.0)*x896)));
evalcond[7]=((((-1.0)*x895*x896))+(((-1.0)*cj4*x898))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x900=((1.0)*cj4);
CheckValue<IkReal> x901 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x900))+((cj4*new_r00)))),IkReal(((((-1.0)*new_r01*x900))+(((-1.0)*new_r10*x900)))),IKFAST_ATAN2_MAGTHRESH);
if(!x901.valid){
continue;
}
CheckValue<IkReal> x902=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x902.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x901.value)+(((1.5707963267949)*(x902.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x903=IKsin(j2);
IkReal x904=IKcos(j2);
IkReal x905=((1.0)*sj4);
IkReal x906=(cj4*x904);
IkReal x907=((1.0)*x903);
IkReal x908=(x903*x905);
evalcond[0]=(cj4+((new_r10*x903))+((new_r00*x904)));
evalcond[1]=(((cj4*x903))+((sj4*x904))+new_r10);
evalcond[2]=(sj4+((new_r10*x904))+(((-1.0)*new_r00*x907)));
evalcond[3]=(cj4+((new_r11*x904))+(((-1.0)*new_r01*x907)));
evalcond[4]=((((-1.0)*x908))+new_r11+x906);
evalcond[5]=((((-1.0)*x908))+new_r00+x906);
evalcond[6]=((((-1.0)*x905))+((new_r11*x903))+((new_r01*x904)));
evalcond[7]=((((-1.0)*cj4*x907))+new_r01+(((-1.0)*x904*x905)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x909=((1.0)*new_r10);
CheckValue<IkReal> x910=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x910.valid){
continue;
}
CheckValue<IkReal> x911 = IKatan2WithCheck(IkReal((((new_r00*sj4))+(((-1.0)*cj4*x909)))),IkReal(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x909)))),IKFAST_ATAN2_MAGTHRESH);
if(!x911.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x910.value)))+(x911.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x912=IKsin(j2);
IkReal x913=IKcos(j2);
IkReal x914=((1.0)*sj4);
IkReal x915=(cj4*x913);
IkReal x916=((1.0)*x912);
IkReal x917=(x912*x914);
evalcond[0]=(cj4+((new_r10*x912))+((new_r00*x913)));
evalcond[1]=(((cj4*x912))+new_r10+((sj4*x913)));
evalcond[2]=(sj4+((new_r10*x913))+(((-1.0)*new_r00*x916)));
evalcond[3]=(cj4+((new_r11*x913))+(((-1.0)*new_r01*x916)));
evalcond[4]=((((-1.0)*x917))+new_r11+x915);
evalcond[5]=((((-1.0)*x917))+new_r00+x915);
evalcond[6]=(((new_r11*x912))+(((-1.0)*x914))+((new_r01*x913)));
evalcond[7]=((((-1.0)*x913*x914))+(((-1.0)*cj4*x916))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x918=((-1.0)*new_r22);
CheckValue<IkReal> x920 = IKatan2WithCheck(IkReal((new_r01*x918)),IkReal((new_r11*x918)),IKFAST_ATAN2_MAGTHRESH);
if(!x920.valid){
continue;
}
IkReal x919=x920.value;
j2array[0]=((-1.0)*x919);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x919)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x921=IKcos(j2);
IkReal x922=IKsin(j2);
IkReal x923=((1.0)*new_r00);
IkReal x924=(new_r10*x922);
evalcond[0]=(((new_r01*x921))+((new_r11*x922)));
evalcond[1]=(((new_r00*x921))+x924);
evalcond[2]=(((new_r10*x921))+(((-1.0)*x922*x923)));
evalcond[3]=((((-1.0)*new_r01*x922))+((new_r11*x921)));
evalcond[4]=((((-1.0)*new_r22*x921*x923))+(((-1.0)*new_r22*x924)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x926 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x926.valid){
continue;
}
IkReal x925=x926.value;
j2array[0]=((-1.0)*x925);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x925)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x927=IKcos(j2);
IkReal x928=IKsin(j2);
IkReal x929=((1.0)*new_r22);
IkReal x930=(new_r11*x928);
IkReal x931=((1.0)*x928);
IkReal x932=(new_r01*x927);
evalcond[0]=(x930+x932);
evalcond[1]=((((-1.0)*new_r00*x931))+((new_r10*x927)));
evalcond[2]=((((-1.0)*new_r01*x931))+((new_r11*x927)));
evalcond[3]=((((-1.0)*x929*x932))+(((-1.0)*x929*x930)));
evalcond[4]=((((-1.0)*new_r10*x928*x929))+(((-1.0)*new_r00*x927*x929)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
CheckValue<IkReal> x934 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x934.valid){
continue;
}
IkReal x933=x934.value;
j2array[0]=((-1.0)*x933);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x933)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x935=IKcos(j2);
IkReal x936=IKsin(j2);
IkReal x937=((1.0)*new_r22);
IkReal x938=(new_r00*x935);
IkReal x939=((1.0)*x936);
IkReal x940=(new_r10*x936);
evalcond[0]=(x938+x940);
evalcond[1]=((((-1.0)*new_r00*x939))+((new_r10*x935)));
evalcond[2]=((((-1.0)*new_r01*x939))+((new_r11*x935)));
evalcond[3]=((((-1.0)*new_r01*x935*x937))+(((-1.0)*new_r11*x936*x937)));
evalcond[4]=((((-1.0)*x937*x938))+(((-1.0)*x937*x940)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x942=IKPowWithIntegerCheck(sj3,-1);
if(!x942.valid){
continue;
}
IkReal x941=x942.value;
CheckValue<IkReal> x943=IKPowWithIntegerCheck(new_r00,-1);
if(!x943.valid){
continue;
}
if( IKabs((x941*(x943.value)*((((sj3*sj4))+((new_r02*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x941)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x941*(x943.value)*((((sj3*sj4))+((new_r02*new_r10))))))+IKsqr((new_r02*x941))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((x941*(x943.value)*((((sj3*sj4))+((new_r02*new_r10))))), (new_r02*x941));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x944=IKcos(j2);
IkReal x945=IKsin(j2);
IkReal x946=((1.0)*sj3);
IkReal x947=((1.0)*cj4);
IkReal x948=(new_r01*x944);
IkReal x949=(new_r02*x944);
IkReal x950=(cj3*x945);
IkReal x951=(cj3*x947);
IkReal x952=(sj4*x944);
IkReal x953=(new_r11*x945);
IkReal x954=((1.0)*x945);
IkReal x955=(new_r00*x944);
IkReal x956=(new_r10*x945);
IkReal x957=(new_r12*x945);
evalcond[0]=((((-1.0)*x944*x946))+new_r02);
evalcond[1]=((((-1.0)*x945*x946))+new_r12);
evalcond[2]=(((new_r12*x944))+(((-1.0)*new_r02*x954)));
evalcond[3]=(sj4+(((-1.0)*new_r00*x954))+((new_r10*x944)));
evalcond[4]=(cj4+(((-1.0)*new_r01*x954))+((new_r11*x944)));
evalcond[5]=(((sj4*x950))+new_r11+((cj4*x944)));
evalcond[6]=((((-1.0)*x946))+x957+x949);
evalcond[7]=(x953+x948+((cj3*sj4)));
evalcond[8]=((((-1.0)*x945*x947))+((cj3*x952))+new_r01);
evalcond[9]=((((-1.0)*x947*x950))+new_r10+x952);
evalcond[10]=((((-1.0)*x951))+x956+x955);
evalcond[11]=((((-1.0)*x944*x951))+new_r00+(((-1.0)*sj4*x954)));
evalcond[12]=(((new_r22*sj3))+((cj3*x949))+((new_r12*x950)));
evalcond[13]=(sj4+((cj3*x948))+((new_r21*sj3))+((new_r11*x950)));
evalcond[14]=((((-1.0)*x946*x956))+(((-1.0)*x946*x955))+((cj3*new_r20)));
evalcond[15]=((((-1.0)*x946*x948))+(((-1.0)*x946*x953))+((cj3*new_r21)));
evalcond[16]=((1.0)+(((-1.0)*x946*x949))+(((-1.0)*x946*x957))+((cj3*new_r22)));
evalcond[17]=(((new_r10*x950))+(((-1.0)*x947))+((new_r20*sj3))+((cj3*x955)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x958=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x958.valid){
continue;
}
CheckValue<IkReal> x959 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x959.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x958.value)))+(x959.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[18];
IkReal x960=IKcos(j2);
IkReal x961=IKsin(j2);
IkReal x962=((1.0)*sj3);
IkReal x963=((1.0)*cj4);
IkReal x964=(new_r01*x960);
IkReal x965=(new_r02*x960);
IkReal x966=(cj3*x961);
IkReal x967=(cj3*x963);
IkReal x968=(sj4*x960);
IkReal x969=(new_r11*x961);
IkReal x970=((1.0)*x961);
IkReal x971=(new_r00*x960);
IkReal x972=(new_r10*x961);
IkReal x973=(new_r12*x961);
evalcond[0]=((((-1.0)*x960*x962))+new_r02);
evalcond[1]=((((-1.0)*x961*x962))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x970))+((new_r12*x960)));
evalcond[3]=(sj4+(((-1.0)*new_r00*x970))+((new_r10*x960)));
evalcond[4]=(((new_r11*x960))+cj4+(((-1.0)*new_r01*x970)));
evalcond[5]=(((sj4*x966))+new_r11+((cj4*x960)));
evalcond[6]=(x973+x965+(((-1.0)*x962)));
evalcond[7]=(x964+x969+((cj3*sj4)));
evalcond[8]=((((-1.0)*x961*x963))+((cj3*x968))+new_r01);
evalcond[9]=((((-1.0)*x963*x966))+new_r10+x968);
evalcond[10]=(x971+x972+(((-1.0)*x967)));
evalcond[11]=((((-1.0)*x960*x967))+new_r00+(((-1.0)*sj4*x970)));
evalcond[12]=(((new_r22*sj3))+((cj3*x965))+((new_r12*x966)));
evalcond[13]=(((new_r11*x966))+sj4+((cj3*x964))+((new_r21*sj3)));
evalcond[14]=((((-1.0)*x962*x972))+(((-1.0)*x962*x971))+((cj3*new_r20)));
evalcond[15]=((((-1.0)*x962*x969))+(((-1.0)*x962*x964))+((cj3*new_r21)));
evalcond[16]=((1.0)+(((-1.0)*x962*x965))+(((-1.0)*x962*x973))+((cj3*new_r22)));
evalcond[17]=(((new_r20*sj3))+((cj3*x971))+(((-1.0)*x963))+((new_r10*x966)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x974=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x974.valid){
continue;
}
CheckValue<IkReal> x975 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x975.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x974.value)))+(x975.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x976=IKcos(j2);
IkReal x977=IKsin(j2);
IkReal x978=((1.0)*sj3);
IkReal x979=(new_r02*x976);
IkReal x980=(new_r12*x977);
IkReal x981=(x977*x978);
evalcond[0]=((((-1.0)*x976*x978))+new_r02);
evalcond[1]=((((-1.0)*x981))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x977))+((new_r12*x976)));
evalcond[3]=(x980+x979+(((-1.0)*x978)));
evalcond[4]=(((new_r22*sj3))+((cj3*x980))+((cj3*x979)));
evalcond[5]=((((-1.0)*new_r10*x981))+(((-1.0)*new_r00*x976*x978))+((cj3*new_r20)));
evalcond[6]=((((-1.0)*new_r11*x981))+((cj3*new_r21))+(((-1.0)*new_r01*x976*x978)));
evalcond[7]=((1.0)+(((-1.0)*x978*x980))+(((-1.0)*x978*x979))+((cj3*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
j4eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x982=((1.0)*cj2);
if( IKabs(((((-1.0)*new_r01*x982))+(((-1.0)*new_r11*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj2))+(((-1.0)*new_r11*x982)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x982))+(((-1.0)*new_r11*sj2))))+IKsqr((((new_r01*sj2))+(((-1.0)*new_r11*x982))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r01*x982))+(((-1.0)*new_r11*sj2))), (((new_r01*sj2))+(((-1.0)*new_r11*x982))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x983=IKsin(j4);
IkReal x984=IKcos(j4);
IkReal x985=((1.0)*sj2);
IkReal x986=(cj2*x983);
IkReal x987=(cj2*x984);
IkReal x988=(x984*x985);
evalcond[0]=(((new_r11*sj2))+((cj2*new_r01))+x983);
evalcond[1]=((((-1.0)*new_r00*x985))+((cj2*new_r10))+x983);
evalcond[2]=((((-1.0)*new_r01*x985))+((cj2*new_r11))+x984);
evalcond[3]=(new_r11+x987+((sj2*x983)));
evalcond[4]=((((-1.0)*x984))+((new_r10*sj2))+((cj2*new_r00)));
evalcond[5]=((((-1.0)*x988))+new_r01+x986);
evalcond[6]=((((-1.0)*x988))+new_r10+x986);
evalcond[7]=((((-1.0)*x987))+new_r00+(((-1.0)*x983*x985)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x989=((1.0)*new_r10);
if( IKabs((((new_r11*sj2))+(((-1.0)*cj2*x989)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj2*new_r11))+(((-1.0)*sj2*x989)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*sj2))+(((-1.0)*cj2*x989))))+IKsqr(((((-1.0)*cj2*new_r11))+(((-1.0)*sj2*x989))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((new_r11*sj2))+(((-1.0)*cj2*x989))), ((((-1.0)*cj2*new_r11))+(((-1.0)*sj2*x989))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x990=IKcos(j4);
IkReal x991=IKsin(j4);
IkReal x992=((1.0)*sj2);
IkReal x993=(cj2*x990);
IkReal x994=((1.0)*x991);
IkReal x995=(x991*x992);
evalcond[0]=(((new_r10*sj2))+((cj2*new_r00))+x990);
evalcond[1]=((((-1.0)*new_r00*x992))+((cj2*new_r10))+x991);
evalcond[2]=((((-1.0)*new_r01*x992))+((cj2*new_r11))+x990);
evalcond[3]=(((new_r11*sj2))+(((-1.0)*x994))+((cj2*new_r01)));
evalcond[4]=(((sj2*x990))+new_r10+((cj2*x991)));
evalcond[5]=((((-1.0)*x995))+new_r11+x993);
evalcond[6]=((((-1.0)*x995))+new_r00+x993);
evalcond[7]=((((-1.0)*x990*x992))+(((-1.0)*cj2*x994))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x996=IKsin(j4);
IkReal x997=IKcos(j4);
IkReal x998=((1.0)*x997);
evalcond[0]=(new_r10+x996);
evalcond[1]=(new_r11+x997);
evalcond[2]=(((sj3*x996))+new_r21);
evalcond[3]=(new_r01+((cj3*x996)));
evalcond[4]=((((-1.0)*sj3*x998))+new_r20);
evalcond[5]=((((-1.0)*cj3*x998))+new_r00);
evalcond[6]=(((cj3*new_r01))+((new_r21*sj3))+x996);
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x998))+((cj3*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r10, new_r11);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x999=IKsin(j4);
IkReal x1000=IKcos(j4);
IkReal x1001=((1.0)*new_r00);
IkReal x1002=((1.0)*new_r01);
IkReal x1003=((1.0)*x1000);
evalcond[0]=(((sj3*x999))+new_r21);
evalcond[1]=((((-1.0)*new_r10))+x999);
evalcond[2]=(x1000+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*sj3*x1003))+new_r20);
evalcond[4]=((((-1.0)*x1002))+((cj3*x999)));
evalcond[5]=((((-1.0)*x1001))+(((-1.0)*cj3*x1003)));
evalcond[6]=((((-1.0)*cj3*x1002))+((new_r21*sj3))+x999);
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x1003))+(((-1.0)*cj3*x1001)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, new_r01);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1004=IKsin(j4);
IkReal x1005=IKcos(j4);
IkReal x1006=((1.0)*x1005);
evalcond[0]=(((sj3*x1004))+new_r21);
evalcond[1]=(x1004+(((-1.0)*new_r00)));
evalcond[2]=(x1005+(((-1.0)*new_r01)));
evalcond[3]=(((cj3*x1004))+new_r11);
evalcond[4]=((((-1.0)*sj3*x1006))+new_r20);
evalcond[5]=((((-1.0)*cj3*x1006))+new_r10);
evalcond[6]=(x1004+((cj3*new_r11))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x1006))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x1007=IKsin(j4);
IkReal x1008=IKcos(j4);
IkReal x1009=((1.0)*cj3);
IkReal x1010=((1.0)*x1008);
evalcond[0]=(x1007+new_r00);
evalcond[1]=(x1008+new_r01);
evalcond[2]=(((sj3*x1007))+new_r21);
evalcond[3]=(new_r20+(((-1.0)*sj3*x1010)));
evalcond[4]=(((cj3*x1007))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*x1008*x1009))+(((-1.0)*new_r10)));
evalcond[6]=(x1007+(((-1.0)*new_r11*x1009))+((new_r21*sj3)));
evalcond[7]=(((new_r20*sj3))+(((-1.0)*x1010))+(((-1.0)*new_r10*x1009)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j4eval[0]=IKabs(new_r22);
if( IKabs(j4eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=((-1.0)*new_r22);
op[1]=0;
op[2]=new_r22;
polyroots2(op,zeror,numroots);
IkReal j4array[2], cj4array[2], sj4array[2], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[2]={true,true};
_nj4 = 2;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1012=IKPowWithIntegerCheck(sj3,-1);
if(!x1012.valid){
continue;
}
IkReal x1011=x1012.value;
CheckValue<IkReal> x1013=IKPowWithIntegerCheck(sj2,-1);
if(!x1013.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x1011)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1011*(x1013.value)*((((new_r01*sj3))+(((-1.0)*cj2*cj3*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x1011))+IKsqr((x1011*(x1013.value)*((((new_r01*sj3))+(((-1.0)*cj2*cj3*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x1011), (x1011*(x1013.value)*((((new_r01*sj3))+(((-1.0)*cj2*cj3*new_r21))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x1014=IKsin(j4);
IkReal x1015=IKcos(j4);
IkReal x1016=(cj2*new_r01);
IkReal x1017=(new_r10*sj2);
IkReal x1018=((1.0)*sj2);
IkReal x1019=(cj3*sj2);
IkReal x1020=(cj2*new_r00);
IkReal x1021=((1.0)*x1015);
IkReal x1022=(cj2*x1014);
evalcond[0]=(((sj3*x1014))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj3*x1021)));
evalcond[2]=(x1014+((cj2*new_r10))+(((-1.0)*new_r00*x1018)));
evalcond[3]=(x1015+((cj2*new_r11))+(((-1.0)*new_r01*x1018)));
evalcond[4]=(x1016+((cj3*x1014))+((new_r11*sj2)));
evalcond[5]=(((x1014*x1019))+((cj2*x1015))+new_r11);
evalcond[6]=(x1017+x1020+(((-1.0)*cj3*x1021)));
evalcond[7]=((((-1.0)*x1015*x1018))+new_r01+((cj3*x1022)));
evalcond[8]=(x1022+(((-1.0)*cj3*x1015*x1018))+new_r10);
evalcond[9]=((((-1.0)*x1014*x1018))+(((-1.0)*cj2*cj3*x1021))+new_r00);
evalcond[10]=(x1014+((new_r11*x1019))+((cj3*x1016))+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+((cj3*x1017))+(((-1.0)*x1021))+((cj3*x1020)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1024=IKPowWithIntegerCheck(sj3,-1);
if(!x1024.valid){
continue;
}
IkReal x1023=x1024.value;
CheckValue<IkReal> x1025=IKPowWithIntegerCheck(cj2,-1);
if(!x1025.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x1023)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1023*(x1025.value)*((((cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x1023))+IKsqr((x1023*(x1025.value)*((((cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r21*x1023), (x1023*(x1025.value)*((((cj3*new_r21*sj2))+(((-1.0)*new_r11*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x1026=IKsin(j4);
IkReal x1027=IKcos(j4);
IkReal x1028=(cj2*new_r01);
IkReal x1029=(new_r10*sj2);
IkReal x1030=((1.0)*sj2);
IkReal x1031=(cj3*sj2);
IkReal x1032=(cj2*new_r00);
IkReal x1033=((1.0)*x1027);
IkReal x1034=(cj2*x1026);
evalcond[0]=(new_r21+((sj3*x1026)));
evalcond[1]=((((-1.0)*sj3*x1033))+new_r20);
evalcond[2]=(x1026+((cj2*new_r10))+(((-1.0)*new_r00*x1030)));
evalcond[3]=(x1027+((cj2*new_r11))+(((-1.0)*new_r01*x1030)));
evalcond[4]=(x1028+((new_r11*sj2))+((cj3*x1026)));
evalcond[5]=(((cj2*x1027))+((x1026*x1031))+new_r11);
evalcond[6]=(x1032+x1029+(((-1.0)*cj3*x1033)));
evalcond[7]=((((-1.0)*x1027*x1030))+((cj3*x1034))+new_r01);
evalcond[8]=(x1034+(((-1.0)*cj3*x1027*x1030))+new_r10);
evalcond[9]=((((-1.0)*x1026*x1030))+(((-1.0)*cj2*cj3*x1033))+new_r00);
evalcond[10]=(x1026+((new_r11*x1031))+((new_r21*sj3))+((cj3*x1028)));
evalcond[11]=((((-1.0)*x1033))+((new_r20*sj3))+((cj3*x1032))+((cj3*x1029)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1035=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1035.valid){
continue;
}
CheckValue<IkReal> x1036 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x1036.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1035.value)))+(x1036.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x1037=IKsin(j4);
IkReal x1038=IKcos(j4);
IkReal x1039=(cj2*new_r01);
IkReal x1040=(new_r10*sj2);
IkReal x1041=((1.0)*sj2);
IkReal x1042=(cj3*sj2);
IkReal x1043=(cj2*new_r00);
IkReal x1044=((1.0)*x1038);
IkReal x1045=(cj2*x1037);
evalcond[0]=(((sj3*x1037))+new_r21);
evalcond[1]=((((-1.0)*sj3*x1044))+new_r20);
evalcond[2]=(x1037+(((-1.0)*new_r00*x1041))+((cj2*new_r10)));
evalcond[3]=(x1038+(((-1.0)*new_r01*x1041))+((cj2*new_r11)));
evalcond[4]=(x1039+((cj3*x1037))+((new_r11*sj2)));
evalcond[5]=(((cj2*x1038))+((x1037*x1042))+new_r11);
evalcond[6]=((((-1.0)*cj3*x1044))+x1043+x1040);
evalcond[7]=((((-1.0)*x1038*x1041))+((cj3*x1045))+new_r01);
evalcond[8]=((((-1.0)*cj3*x1038*x1041))+x1045+new_r10);
evalcond[9]=((((-1.0)*cj2*cj3*x1044))+(((-1.0)*x1037*x1041))+new_r00);
evalcond[10]=(x1037+((cj3*x1039))+((new_r11*x1042))+((new_r21*sj3)));
evalcond[11]=(((new_r20*sj3))+((cj3*x1043))+((cj3*x1040))+(((-1.0)*x1044)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - motoman_sia10f (d3d2a05152fbfdef103aadddecd9b201)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
